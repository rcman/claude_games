<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valheim Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
            /* width: 100%; handled by JS */
            /* height: 100vh; handled by JS */
        }
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex; /* Changed later */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #loading img {
            width: 200px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #5d8834;
            width: 0%;
            transition: width 0.5s;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            pointer-events: none;
        }
        #health-bar, #stamina-bar, #food-bar {
            height: 20px;
            margin-right: 10px;
            border-radius: 5px;
            overflow: hidden;
            flex: 1;
            background-color: rgba(50,50,50,0.7);
        }
        #health-bar .fill {
            background: #c93636;
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
        }
        #stamina-bar .fill {
            background: #3665c9;
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
        }
        #food-bar .fill {
            background: #c9a336;
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
        }
        #inventory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            /* height: 400px; */
            max-height: 80vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #5d8834;
            color: #fff;
            padding: 20px;
            display: none;
            pointer-events: auto;
            z-index: 500;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .inventory-slot {
            width: 60px;
            height: 60px;
            background: #333;
            border: 1px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 24px; /* Icon size */
            position: relative;
            cursor: pointer;
            user-select: none; /* Prevent text selection during drag */
        }
         .inventory-slot:hover {
            background: #555;
         }
         .inventory-slot.drag-over { /* Style for drag-over */
             background-color: #444;
             border-color: #888;
         }
        .inventory-slot img { /* If using images */
            max-width: 80%;
            max-height: 80%;
        }
        .inventory-slot .count {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 3px;
        }
        #hotbar {
            position: absolute;
            bottom: 80px; /* Increased to avoid overlap */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            pointer-events: auto; /* Enable interaction */
             z-index: 400;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(50, 50, 50, 0.7);
            border: 1px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px; /* Icon size */
            color: white;
            position: relative;
            user-select: none;
        }
         .hotbar-slot.drag-over { /* Style for drag-over */
             background-color: rgba(70, 70, 70, 0.9);
             border-color: #aaa;
         }
        .hotbar-slot.active {
            border: 2px solid #fff;
            background: rgba(70, 70, 70, 0.9);
        }
         .hotbar-slot .count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 9px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 3px;
            border-radius: 2px;
        }
         .hotbar-slot .index {
             position: absolute;
             top: 2px;
             left: 2px;
             font-size: 9px;
             color: rgba(255,255,255,0.7);
         }
        #crafting {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 250px;
            max-height: 70vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #5d8834;
            color: #fff;
            padding: 10px;
            display: none;
            pointer-events: auto;
            z-index: 500;
        }
        .crafting-item {
            margin: 10px 0;
            cursor: pointer;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #444;
        }
        .crafting-item:hover {
            background: #333;
            border-color: #666;
        }
        .crafting-item.can-craft {
            border-color: #5d8834;
        }
        .crafting-item .materials {
            font-size: 10px;
            color: #aaa;
            margin-top: 4px;
        }
        #interaction {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 16px;
            text-shadow: 1px 1px 2px #000;
            display: none;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            white-space: pre; /* Preserve formatting */
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #5d8834;
            z-index: 400;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px; /* Smaller */
            height: 10px; /* Smaller */
            pointer-events: none;
            z-index: 300;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }
        .crosshair::before { /* Horizontal */
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        .crosshair::after { /* Vertical */
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.9)), url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAASElEQVQoU2NkIBIwEqmOgSEDvvbNm/8NEf7///+PRSEjVBF2k9DV/f//H6gBbjJU4X+8ChkZGbGbDHT9f2ZmJoKK0BVitw4ArNcfGx5yiRsAAAAASUVORK5CYII=') repeat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 1000;
            /* display: none; /* Initially hidden */
        }
        #menu h1 {
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #5d8834;
            letter-spacing: 4px;
        }
        .menu-button {
            background: rgba(93, 136, 52, 0.7);
            border: none;
            color: #fff;
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            width: 200px;
            text-align: center;
        }
        .menu-button:hover {
            background: rgba(93, 136, 52, 1);
            transform: scale(1.05);
        }
        #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #c93636;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
        #death-screen h2 {
            font-size: 72px;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h1>VALHEIM CLONE</h1>
        <p>Loading world...</p>
        <div class="progress-bar">
            <div class="progress-fill" id="loading-progress"></div>
        </div>
    </div>

    <div id="menu">
        <h1>VALHEIM CLONE</h1>
        <button class="menu-button" id="start-game">Start Game</button>
        <button class="menu-button" id="options" disabled>Options (N/A)</button>
        <p style="margin-top: 50px; font-size: 12px; opacity: 0.7;">HTML5 Adaptation - Use WASD to move, Space to jump, Shift to run, Mouse to look, Left Click to attack/use, E to interact, TAB for inventory/crafting, 1-8 for hotbar.</p>
    </div>

    <div id="death-screen">
        <h2>YOU DIED</h2>
        <p>Odin is disappointed</p>
        <button class="menu-button" id="respawn">Respawn</button>
    </div>

    <canvas id="game-canvas"></canvas>

    <div id="ui">
        <div id="health-bar"><div class="fill"></div></div>
        <div id="stamina-bar"><div class="fill"></div></div>
        <div id="food-bar"><div class="fill"></div></div>
    </div>

    <div id="hotbar">
        <!-- Hotbar slots generated by JS -->
    </div>

    <div id="interaction">Press E to interact</div>

    <div id="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>

    <div class="crosshair"></div>

    <div id="debug"></div>

    <div id="inventory">
        <h3>Inventory</h3>
        <div class="inventory-grid">
            <!-- Inventory slots will be generated by JS -->
        </div>
    </div>

    <div id="crafting">
        <h3>Crafting</h3>
        <div class="crafting-list">
            <!-- Crafting items will be generated by JS -->
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        // Game Configuration
        const config = {
            worldSize: 1024, // Power of 2 is often good
            chunkSize: 32,
            chunkResolution: 16, // Vertices per chunk edge (resolution x resolution)
            renderDistance: 4, // Chunks away from player
            treeDensity: 0.02, // Adjusted
            rockDensity: 0.01,
            enemyDensity: 0.001, // Lowered for performance/sanity
            gravity: 0.008, // Lowered for less bouncy feel
            dayNightCycle: 1200, // seconds per day
            playerSpeed: 0.08,
            playerRunSpeed: 0.15,
            jumpForce: 0.18,
            staminaDrainRun: 0.2,
            staminaRegen: 0.5,
            interactionDistance: 4,
            fogDistance: 100, // Render distance related
            cameraOffset: { x: 0, y: 1.8, z: 0 }, // Relative to player feet
            thirdPersonDistance: 5,
            mouseSensitivity: 0.002
        };

        // Game state
        const game = {
            started: false,
            paused: false,
            showInventory: false,
            showCrafting: false,
            isDead: false,
            currentTime: 0,
            dayTime: 0.5, // Start at noon
            weather: 'clear',
            player: {
                position: { x: config.chunkSize / 2, y: 50, z: config.chunkSize / 2 }, // Start near center, high up to fall onto terrain
                rotation: { x: 0, y: 0 }, // x: pitch, y: yaw
                velocity: { x: 0, y: 0, z: 0 },
                onGround: false,
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                food: 100, // Base food, specific food items will add buffs
                maxFood: 100,
                inventory: Array(32).fill(null), // 4x8 grid
                hotbar: Array(8).fill(null), // References indices in main inventory
                activeHotbarSlot: 0,
                state: 'idle', // idle, walking, running, jumping, attacking
                isAttacking: false,
                attackCooldown: 0,
                interactionTarget: null,
                buildMode: false, // True when hammer equipped and active
                buildTarget: null, // { position, rotation, valid }
                buildPiece: null // id of building piece selected
            },
            world: {
                seed: Math.floor(Math.random() * 1000000),
                chunks: {}, // Key: "x,z", Value: { meshData, terrainMesh, waterMesh, entities }
                entities: [], // Global entities: Enemies, dropped items
                builtObjects: [] // Placed structures
            },
            camera: {
                position: { x: 0, y: 0, z: 0 },
                rotation: { x: 0, y: 0 }, // Same as player for first person
                fov: 75 * Math.PI / 180 // Convert to radians
            },
            input: {
                keys: {},
                mouse: { x: 0, y: 0, dx: 0, dy: 0, down: false, clicked: false },
                pointer: { locked: false }
            },
            lastFrameTime: performance.now(),
            deltaTime: 0,
            noise: new SimplexNoise(Math.random().toString()), // Seeded noise generator
            webgl: { // Store WebGL related stuff here
                gl: null,
                programs: {},
                buffers: {},
                textures: {},
                uniformLocations: {},
                attributeLocations: {},
                meshes: {} // Predefined meshes like cube, sphere etc.
            }
        };

        // Item definitions
        const items = {
            wood: { id: "wood", name: "Wood", type: "resource", icon: "ü™µ", stackable: true, maxStack: 50 },
            stone: { id: "stone", name: "Stone", type: "resource", icon: "ü™®", stackable: true, maxStack: 50 },
            flint: { id: "flint", name: "Flint", type: "resource", icon: "üî™", stackable: true, maxStack: 30 },
            resin: { id: "resin", name: "Resin", type: "resource", icon: "üíß", stackable: true, maxStack: 50 },
            berries: { id: "berries", name: "Raspberries", type: "food", icon: "üçì", stackable: true, maxStack: 20, effects: { food: 10, healthRegen: 1, duration: 300 } },
            mushroom: { id: "mushroom", name: "Mushroom", type: "food", icon: "üçÑ", stackable: true, maxStack: 20, effects: { food: 15, staminaRegen: 1, duration: 400 } },
            meat_raw: { id: "meat_raw", name: "Raw Meat", type: "food", icon: "üçñ", stackable: true, maxStack: 10 },
            meat_cooked: { id: "meat_cooked", name: "Cooked Meat", type: "food", icon: "üçó", stackable: true, maxStack: 10, effects: { food: 40, healthRegen: 2, duration: 600 } },
            hammer: { id: "hammer", name: "Hammer", type: "tool", icon: "üî®", stackable: false, durability: 100, action: 'build' },
            axe_stone: { id: "axe_stone", name: "Stone Axe", type: "weapon", icon: "ü™ì", stackable: false, damage: 15, durability: 100, action: 'chop' },
            club: { id: "club", name: "Club", type: "weapon", icon: "ü™µ", stackable: false, damage: 12, durability: 50, action: 'attack' },
            pickaxe_stone: { id: "pickaxe_stone", name: "Stone Pickaxe", type: "tool", icon: "‚õèÔ∏è", stackable: false, damage: 10, durability: 80, action: 'mine' },
            torch: { id: "torch", name: "Torch", type: "tool", icon: "üî•", stackable: false, durability: 300, action: 'light' }
            // Add leather_scraps, bone_fragments etc. if needed
        };

        // Crafting recipes
        const recipes = [
            { id: "axe_stone", name: "Stone Axe", materials: [{ item: "wood", count: 5 }, { item: "stone", count: 3 }], result: "axe_stone", station: null },
            { id: "club", name: "Club", materials: [{ item: "wood", count: 6 }], result: "club", station: null },
            { id: "hammer", name: "Hammer", materials: [{ item: "wood", count: 3 }, { item: "stone", count: 2 }], result: "hammer", station: null },
            { id: "pickaxe_stone", name: "Stone Pickaxe", materials: [{ item: "wood", count: 4 }, { item: "stone", count: 5 }], result: "pickaxe_stone", station: "workbench" },
            { id: "torch", name: "Torch", materials: [{ item: "wood", count: 1 }, { item: "resin", count: 1 }], result: "torch", station: null }
            // Workbench is now a building piece, not crafted directly into inventory
        ];

        // Building pieces (Requires Hammer)
        const buildings = [
            { id: "workbench", name: "Workbench", icon: "üõ†Ô∏è", model: 'cube', color: [0.7, 0.5, 0.3, 1.0], materials: [{ item: "wood", count: 10 }], requireWorkbench: false, category: "Crafting" },
            { id: "floor_wood", name: "Wooden Floor", icon: "üü´", model: 'cube', color: [0.6, 0.4, 0.2, 1.0], materials: [{ item: "wood", count: 2 }], requireWorkbench: true, category: "Building" },
            { id: "wall_wood", name: "Wooden Wall", icon: "üß±", model: 'cube', color: [0.6, 0.4, 0.2, 1.0], materials: [{ item: "wood", count: 2 }], requireWorkbench: true, category: "Building" },
            { id: "roof_wood_26", name: "Thatch Roof 26¬∞", icon: "üìê", model: 'cube', color: [0.7, 0.6, 0.3, 1.0], materials: [{ item: "wood", count: 2 }], requireWorkbench: true, category: "Building" },
            { id: "roof_wood_45", name: "Thatch Roof 45¬∞", icon: "üìê", model: 'cube', color: [0.7, 0.6, 0.3, 1.0], materials: [{ item: "wood", count: 2 }], requireWorkbench: true, category: "Building" },
            { id: "door_wood", name: "Wooden Door", icon: "üö™", model: 'cube', color: [0.6, 0.4, 0.2, 1.0], materials: [{ item: "wood", count: 4 }], requireWorkbench: true, category: "Building" },
            { id: "firepit", name: "Campfire", icon: "üî•", model: 'cylinder', color: [0.4, 0.4, 0.4, 1.0], materials: [{ item: "stone", count: 5 }, { item: "wood", count: 2 }], requireWorkbench: false, category: "Furniture" },
        ];

        // Enemy types
        const enemyTypes = [
            { id: "greyling", name: "Greyling", health: 20, damage: 5, speed: 0.06, model: "sphere", color: [0.4, 0.5, 0.4, 1.0], drops: [{ item: "resin", chance: 0.8, min: 1, max: 2 }] },
            { id: "boar", name: "Boar", health: 25, damage: 6, speed: 0.08, model: "cube", color: [0.6, 0.4, 0.2, 1.0], drops: [{ item: "meat_raw", chance: 1.0, min: 1, max: 1 }/*, { item: "leather_scraps", chance: 0.5, min: 1, max: 1 }*/] }, // Leather scraps item needed
        ];

        // UI Elements
        const loadingScreen = document.getElementById('loading');
        const loadingProgress = document.getElementById('loading-progress');
        const menuScreen = document.getElementById('menu');
        const deathScreen = document.getElementById('death-screen');
        const canvas = document.getElementById('game-canvas');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const healthBarFill = document.querySelector('#health-bar .fill');
        const staminaBarFill = document.querySelector('#stamina-bar .fill');
        const foodBarFill = document.querySelector('#food-bar .fill');
        const inventoryUI = document.getElementById('inventory');
        const inventoryGrid = inventoryUI.querySelector('.inventory-grid');
        const hotbarUI = document.getElementById('hotbar');
        const craftingUI = document.getElementById('crafting');
        const craftingList = craftingUI.querySelector('.crafting-list');
        const interactionPrompt = document.getElementById('interaction');
        const debugInfo = document.getElementById('debug');

        // Initialize WebGL context
        const gl = canvas.getContext('webgl', { alpha: false, antialias: true });
        game.webgl.gl = gl;
        const minimapCtx = minimapCanvas.getContext('2d');

        if (!gl) {
            alert('WebGL not supported or disabled. Please use a modern browser like Chrome or Firefox.');
            loadingScreen.innerHTML = "<h2>Error: WebGL Not Supported</h2><p>Could not initialize WebGL. Please ensure your browser supports it and hardware acceleration is enabled.</p>";
            throw new Error('WebGL not supported');
        }

        // ----------------------------------------------
        // Shader Code (Vertex Shader Precision Fixed)
        // ----------------------------------------------

        const vertexShaderSource = `
            precision mediump float; // <<< Precision Added

            attribute vec3 a_position;
            attribute vec3 a_normal;
            attribute vec2 a_texcoord;

            uniform mat4 u_modelMatrix;
            uniform mat4 u_viewMatrix;
            uniform mat4 u_projectionMatrix;
            uniform float u_time;
            uniform float u_swayFactor;

            varying vec3 v_normal;
            varying vec2 v_texcoord;
            varying vec3 v_worldPosition;

            void main() {
                vec3 pos = a_position;
                vec3 normal = a_normal;

                if (a_position.y > 0.0 && u_swayFactor > 0.0) {
                    float swayAmount = sin(u_time * 0.5 + a_position.x * 0.5 + a_position.z * 0.3) * a_position.y * 0.1 * u_swayFactor;
                    pos.x += swayAmount;
                    pos.z += swayAmount * 0.5;
                }

                mat4 modelViewMatrix = u_viewMatrix * u_modelMatrix;
                v_normal = mat3(modelViewMatrix) * normal;
                v_texcoord = a_texcoord;
                v_worldPosition = (u_modelMatrix * vec4(pos, 1.0)).xyz;

                gl_Position = u_projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const basicFragmentShaderSource = `
            precision mediump float;

            varying vec3 v_normal;
            varying vec3 v_worldPosition;

            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            uniform vec4 u_color;
            uniform float u_fogDistance;
            uniform vec3 u_fogColor;
            uniform float u_ambientLight;

            void main() {
                vec3 normal = normalize(v_normal);
                vec3 lightDir = normalize(u_lightDirection);
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 diffuse = diff * u_color.rgb;
                vec3 ambient = u_ambientLight * u_color.rgb;
                vec3 lighting = ambient + diffuse;
                float distanceToCamera = length(v_worldPosition - u_viewPosition);
                float fogFactor = smoothstep(u_fogDistance * 0.7, u_fogDistance, distanceToCamera);
                vec3 color = mix(lighting, u_fogColor, fogFactor);
                gl_FragColor = vec4(color, u_color.a);
            }
        `;

        const terrainFragmentShaderSource = `
            precision mediump float;

            varying vec3 v_normal;
            varying vec3 v_worldPosition;

            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            uniform float u_time; // Note: u_time is currently unused in terrain shader
            uniform float u_fogDistance;
            uniform vec3 u_fogColor;
            uniform float u_ambientLight;

            float hash( vec2 p ) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }

            const vec3 GRASS_COLOR = vec3(0.3, 0.6, 0.2);
            const vec3 DIRT_COLOR = vec3(0.5, 0.35, 0.2);
            const vec3 ROCK_COLOR = vec3(0.5, 0.5, 0.5);
            const vec3 SAND_COLOR = vec3(0.8, 0.7, 0.4);
            const vec3 SNOW_COLOR = vec3(0.9, 0.9, 0.95);
            const float WATER_LEVEL = 0.5;

            void main() {
                vec3 normal = normalize(v_normal); // Use world normal received from vertex shader
                vec3 lightDir = normalize(u_lightDirection);
                float diff = max(dot(normal, lightDir), 0.0);

                float height = v_worldPosition.y;
                // Calculate slope based on the world normal's Y component
                float slope = 1.0 - clamp(normal.y, 0.0, 1.0);

                vec3 baseColor;
                float rockFactor = smoothstep(0.3, 0.6, slope);
                float snowFactor = smoothstep(15.0, 20.0, height);
                float sandFactor = smoothstep(WATER_LEVEL + 1.0, WATER_LEVEL, height);
                float dirtMix = smoothstep(0.1, 0.3, slope);
                float largeNoise = hash(floor(v_worldPosition.xz * 0.1)) * 0.3 - 0.15;
                vec3 groundColor = mix(GRASS_COLOR + largeNoise, DIRT_COLOR, dirtMix);

                baseColor = mix(groundColor, ROCK_COLOR, rockFactor);
                baseColor = mix(baseColor, SAND_COLOR, sandFactor);
                baseColor = mix(baseColor, SNOW_COLOR, snowFactor);

                vec3 ambient = u_ambientLight * baseColor;
                vec3 diffuse = diff * baseColor;
                vec3 lighting = ambient + diffuse;
                float detailNoise = hash(v_worldPosition.xz * 2.0) * 0.1 - 0.05;
                lighting += detailNoise;

                float distanceToCamera = length(v_worldPosition - u_viewPosition);
                float fogFactor = smoothstep(u_fogDistance * 0.7, u_fogDistance, distanceToCamera);
                vec3 color = mix(lighting, u_fogColor, fogFactor);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const waterFragmentShaderSource = `
            precision mediump float;

            varying vec3 v_normal;
            varying vec3 v_worldPosition;

            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            uniform float u_time;
            uniform float u_fogDistance;
            uniform vec3 u_fogColor;
            uniform float u_ambientLight;

            float hash( vec2 p ) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
            float noise( vec2 p ) {
                vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f);
                float a = hash(i + vec2(0.0,0.0)); float b = hash(i + vec2(1.0,0.0));
                float c = hash(i + vec2(0.0,1.0)); float d = hash(i + vec2(1.0,1.0));
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            void main() {
                vec3 normalFromVert = normalize(v_normal); // Normal passed from vertex (likely just 0,1,0)
                vec3 viewDir = normalize(u_viewPosition - v_worldPosition);

                float waveSpeed = 0.3; float waveScale = 8.0; float waveHeight = 0.1;
                vec2 waveNormalOffset = vec2(
                    noise(v_worldPosition.xz * waveScale + u_time * waveSpeed + 10.0) - 0.5,
                    noise(v_worldPosition.xz * waveScale + u_time * waveSpeed + 20.0) - 0.5
                ) * 0.5;
                vec3 normal = normalize(vec3(waveNormalOffset.x, 1.0, waveNormalOffset.y)); // Perturbed normal for lighting

                vec3 lightDir = normalize(u_lightDirection);
                float diff = max(dot(normal, lightDir), 0.0);
                float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0) * 0.5;

                float depth = max(0.5 - v_worldPosition.y, 0.0);
                vec3 deepWaterColor = vec3(0.1, 0.3, 0.5);
                vec3 shallowWaterColor = vec3(0.3, 0.5, 0.7);
                vec3 waterColor = mix(shallowWaterColor, deepWaterColor, smoothstep(0.0, 10.0, depth));

                vec3 ambient = u_ambientLight * waterColor;
                vec3 diffuse = diff * waterColor * 0.8;
                vec3 reflectionColor = vec3(0.8, 0.9, 1.0);
                vec3 specularHighlight = vec3(1.0) * spec;
                vec3 lighting = ambient + diffuse + mix(specularHighlight, reflectionColor, fresnel * 0.8);

                float distanceToCamera = length(v_worldPosition - u_viewPosition);
                float fogFactor = smoothstep(u_fogDistance * 0.7, u_fogDistance, distanceToCamera);
                vec3 color = mix(lighting, u_fogColor, fogFactor);

                gl_FragColor = vec4(color, 0.85);
            }
        `;

        const skyboxVertexShaderSource = `
            attribute vec3 a_position;
            uniform mat4 u_viewMatrix;
            uniform mat4 u_projectionMatrix;
            varying vec3 v_texcoord;

            void main() {
                v_texcoord = a_position;
                mat4 viewRotationMatrix = mat4(mat3(u_viewMatrix));
                vec4 pos = u_projectionMatrix * viewRotationMatrix * vec4(a_position, 1.0);
                gl_Position = pos.xyww;
            }
        `;

        const skyboxFragmentShaderSource = `
            precision mediump float;
            varying vec3 v_texcoord;

            uniform float u_time;
            uniform float u_dayTime;

            float hash( vec3 p ) { p = fract(p * 0.3183099 + 0.1); p *= 17.0; return fract(p.x*p.y*p.z*(p.x+p.y+p.z)); }

            void main() {
                vec3 dir = normalize(v_texcoord);
                float y = dir.y;
                vec3 sunDir = normalize(vec3(sin(u_dayTime * 2.0 * 3.14159), cos(u_dayTime * 2.0 * 3.14159), 0.3));
                float sunElevation = max(0.0, sunDir.y);
                float nightFactor = 1.0 - smoothstep(0.0, 0.15, sunElevation);

                vec3 dayZenithColor = vec3(0.2, 0.4, 0.8) * sunElevation + 0.1;
                vec3 dayHorizonColor = vec3(0.5, 0.7, 1.0) * sunElevation + 0.1;
                vec3 daySky = mix(dayHorizonColor, dayZenithColor, smoothstep(0.0, 0.5, y));

                float sunsetFactor = smoothstep(0.0, 0.1, sunElevation) * (1.0 - smoothstep(0.1, 0.2, sunElevation));
                vec3 sunsetHorizonColor = vec3(1.0, 0.5, 0.2);
                vec3 sunsetZenithColor = vec3(0.5, 0.3, 0.6);
                float sunDot = max(0.0, dot(dir, sunDir));
                vec3 sunsetGlow = mix(sunsetZenithColor, sunsetHorizonColor, smoothstep(-0.1, 0.3, y)) * pow(sunDot, 2.0) * sunsetFactor * 2.0;

                vec3 nightZenithColor = vec3(0.01, 0.01, 0.05);
                vec3 nightHorizonColor = vec3(0.05, 0.05, 0.15);
                vec3 nightSky = mix(nightHorizonColor, nightZenithColor, smoothstep(0.0, 0.4, y));

                vec3 color = mix(daySky + sunsetGlow, nightSky, nightFactor);

                float sunSize = smoothstep(0.998, 1.0, sunDot);
                color += vec3(1.0, 0.9, 0.7) * sunSize * (1.0 - nightFactor);

                if (nightFactor > 0.1) {
                    float starDensity = 1000.0;
                    float starIntensity = hash(floor(dir * starDensity)) * smoothstep(0.995, 0.999, hash(floor(dir * starDensity) + 0.5));
                    starIntensity *= starIntensity;
                    starIntensity *= (0.7 + 0.3 * sin(u_time * 2.0 + hash(floor(dir * starDensity) + 1.0) * 6.28));
                    color += vec3(1.0) * starIntensity * nightFactor;
                }

                gl_FragColor = vec4(color, 1.0);
            }
        `;


        // ----------------------------------------------
        // WebGL Helper Functions (Readable)
        // ----------------------------------------------

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(`Shader compilation error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`, gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = compileShader(gl, vertexSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
            if (!vertexShader || !fragmentShader) return null;

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);
                return null;
            }

            // Detach shaders after successful link (optional but good practice)
            gl.detachShader(program, vertexShader);
            gl.detachShader(program, fragmentShader);
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);

            return program;
        }

        function getAttribUniformLocations(gl, program, attributes, uniforms) {
            const locations = { attribs: {}, uniforms: {} };
            attributes.forEach(name => {
                locations.attribs[name] = gl.getAttribLocation(program, name);
                 if (locations.attribs[name] < 0) console.warn(`Attribute '${name}' not found or unused in shader program.`);
            });
            uniforms.forEach(name => {
                locations.uniforms[name] = gl.getUniformLocation(program, name);
                 if (!locations.uniforms[name]) console.warn(`Uniform '${name}' not found or unused in shader program.`);
            });
            return locations;
        }

        function createBuffer(gl, data, target = gl.ARRAY_BUFFER, usage = gl.STATIC_DRAW) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(target, buffer);
            gl.bufferData(target, data, usage);
            gl.bindBuffer(target, null); // Unbind
            return buffer;
        }

        function createVertexArrayObject(gl) {
            if (gl.createVertexArray) {
                return gl.createVertexArray();
            }
            console.warn("VAOs not supported, using standard attribute binding.");
            return { bind: () => {}, _isFallback: true };
        }

        function bindVertexArrayObject(gl, vao) {
             if (vao && !vao._isFallback && gl.bindVertexArray) {
                 gl.bindVertexArray(vao);
             }
        }

        function setupAttributes(gl, programLocations, meshBuffers) {
             const { a_position, a_normal, a_texcoord } = programLocations.attribs;

             if (a_position >= 0 && meshBuffers.position) {
                 gl.bindBuffer(gl.ARRAY_BUFFER, meshBuffers.position);
                 gl.enableVertexAttribArray(a_position);
                 gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
             } else if (a_position >=0) {
                 gl.disableVertexAttribArray(a_position); // Explicitly disable if not used
             }

             if (a_normal >= 0 && meshBuffers.normal) {
                 gl.bindBuffer(gl.ARRAY_BUFFER, meshBuffers.normal);
                 gl.enableVertexAttribArray(a_normal);
                 gl.vertexAttribPointer(a_normal, 3, gl.FLOAT, false, 0, 0);
             } else if (a_normal >= 0) {
                 gl.disableVertexAttribArray(a_normal);
             }

             if (a_texcoord >= 0 && meshBuffers.texcoord) {
                 gl.bindBuffer(gl.ARRAY_BUFFER, meshBuffers.texcoord);
                 gl.enableVertexAttribArray(a_texcoord);
                 gl.vertexAttribPointer(a_texcoord, 2, gl.FLOAT, false, 0, 0);
             } else if (a_texcoord >= 0) {
                  gl.disableVertexAttribArray(a_texcoord);
             }

             // Bind the element array buffer (indices) AFTER setting up attribute pointers
             if (meshBuffers.indices) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshBuffers.indices);
             }
        }

        // ----------------------------------------------
        // 3D Math Helper Functions (Readable)
        // ----------------------------------------------
        const mat4 = {
            identity: function() { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; },
            perspective: function(fovRadians, aspect, near, far) {
                const f = 1.0 / Math.tan(fovRadians / 2); const rangeInv = 1 / (near - far);
                return [ f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (near + far) * rangeInv, -1, 0, 0, near * far * rangeInv * 2, 0 ];
            },
            translation: function(tx, ty, tz) { return [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1 ]; },
            xRotation: function(angleInRadians) { const c = Math.cos(angleInRadians), s = Math.sin(angleInRadians); return [ 1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1 ]; },
            yRotation: function(angleInRadians) { const c = Math.cos(angleInRadians), s = Math.sin(angleInRadians); return [ c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1 ]; },
            zRotation: function(angleInRadians) { const c = Math.cos(angleInRadians), s = Math.sin(angleInRadians); return [ c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; },
            scaling: function(sx, sy, sz) { return [ sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1 ]; },
            multiply: function(a, b) {
                const a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];
                const b00=b[0],b01=b[1],b02=b[2],b03=b[3],b10=b[4],b11=b[5],b12=b[6],b13=b[7],b20=b[8],b21=b[9],b22=b[10],b23=b[11],b30=b[12],b31=b[13],b32=b[14],b33=b[15];
                return [
                    a00*b00+a01*b10+a02*b20+a03*b30, a00*b01+a01*b11+a02*b21+a03*b31, a00*b02+a01*b12+a02*b22+a03*b32, a00*b03+a01*b13+a02*b23+a03*b33,
                    a10*b00+a11*b10+a12*b20+a13*b30, a10*b01+a11*b11+a12*b21+a13*b31, a10*b02+a11*b12+a12*b22+a13*b32, a10*b03+a11*b13+a12*b23+a13*b33,
                    a20*b00+a21*b10+a22*b20+a23*b30, a20*b01+a21*b11+a22*b21+a23*b31, a20*b02+a21*b12+a22*b22+a23*b32, a20*b03+a21*b13+a22*b23+a23*b33,
                    a30*b00+a31*b10+a32*b20+a33*b30, a30*b01+a31*b11+a32*b21+a33*b31, a30*b02+a31*b12+a32*b22+a33*b32, a30*b03+a31*b13+a32*b23+a33*b33 ];
            },
            inverse: function(m) {
                 const m00=m[0],m01=m[1],m02=m[2],m03=m[3],m10=m[4],m11=m[5],m12=m[6],m13=m[7],m20=m[8],m21=m[9],m22=m[10],m23=m[11],m30=m[12],m31=m[13],m32=m[14],m33=m[15];
                 const t0=m22*m33,t1=m32*m23,t2=m12*m33,t3=m32*m13,t4=m12*m23,t5=m22*m13,t6=m02*m33,t7=m32*m03,t8=m02*m23,t9=m22*m03,t10=m02*m13,t11=m12*m03;
                 const t12=m20*m31,t13=m30*m21,t14=m10*m31,t15=m30*m11,t16=m10*m21,t17=m20*m11,t18=m00*m31,t19=m30*m01,t20=m00*m21,t21=m20*m01,t22=m00*m11,t23=m10*m01;
                 const dt0=(t0*m11+t3*m21+t4*m31)-(t1*m11+t2*m21+t5*m31); const dt1=(t1*m01+t6*m21+t9*m31)-(t0*m01+t7*m21+t8*m31);
                 const dt2=(t2*m01+t7*m11+t10*m31)-(t3*m01+t6*m11+t11*m31); const dt3=(t5*m01+t8*m11+t11*m21)-(t4*m01+t9*m11+t10*m21);
                 const d=1/(m00*dt0+m10*dt1+m20*dt2+m30*dt3);
                 if (!isFinite(d)) { console.warn("Matrix is not invertible."); return mat4.identity(); }
                 return [ d*dt0, d*dt1, d*dt2, d*dt3,
                          d*((t1*m10+t2*m20+t5*m30)-(t0*m10+t3*m20+t4*m30)), d*((t0*m00+t7*m20+t8*m30)-(t1*m00+t6*m20+t9*m30)),
                          d*((t3*m00+t6*m10+t11*m30)-(t2*m00+t7*m10+t10*m30)), d*((t4*m00+t9*m10+t10*m20)-(t5*m00+t8*m10+t11*m20)),
                          d*((t12*m13+t15*m23+t16*m33)-(t13*m13+t14*m23+t17*m33)), d*((t13*m03+t18*m23+t21*m33)-(t12*m03+t19*m23+t20*m33)),
                          d*((t14*m03+t19*m13+t22*m33)-(t15*m03+t18*m13+t23*m33)), d*((t17*m03+t20*m13+t23*m23)-(t16*m03+t21*m13+t22*m23)),
                          d*((t14*m22+t17*m32+t13*m12)-(t16*m32+t12*m12+t15*m22)), d*((t20*m32+t12*m02+t19*m22)-(t18*m22+t21*m32+t13*m02)),
                          d*((t18*m12+t23*m32+t15*m02)-(t22*m32+t14*m02+t19*m12)), d*((t22*m22+t16*m02+t21*m12)-(t20*m12+t23*m22+t17*m02)) ];
            },
            lookAt: function(eye, target, up) {
                const zAxis = normalize(subtractVectors(eye, target)); const xAxis = normalize(cross(up, zAxis)); const yAxis = normalize(cross(zAxis, xAxis));
                return [ xAxis[0], xAxis[1], xAxis[2], 0, yAxis[0], yAxis[1], yAxis[2], 0, zAxis[0], zAxis[1], zAxis[2], 0, eye[0], eye[1], eye[2], 1 ];
            },
            transform: function(tx, ty, tz, rx, ry, rz, sx, sy, sz) {
                let m = mat4.identity();
                m = mat4.multiply(m, mat4.translation(tx, ty, tz));
                m = mat4.multiply(m, mat4.yRotation(ry));
                m = mat4.multiply(m, mat4.xRotation(rx));
                m = mat4.multiply(m, mat4.zRotation(rz));
                m = mat4.multiply(m, mat4.scaling(sx, sy, sz));
                return m;
            },
             cameraView: function(eye, pitch, yaw) {
                let target = [0, 0, -1];
                let camMat = mat4.identity();
                camMat = mat4.multiply(camMat, mat4.xRotation(pitch));
                camMat = mat4.multiply(camMat, mat4.yRotation(yaw));
                const rotatedTarget = transformVector(target, camMat);
                const finalTarget = addVectors([eye.x, eye.y, eye.z], rotatedTarget);
                let up = [0, 1, 0];
                const rotatedUp = transformVector(up, camMat);
                const lookMat = mat4.lookAt([eye.x, eye.y, eye.z], finalTarget, rotatedUp);
                return mat4.inverse(lookMat);
            }
        };

        function normalize(v) { const l=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return l > 0.00001 ? [v[0]/l, v[1]/l, v[2]/l] : [0,0,0]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function subtractVectors(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function addVectors(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
        function scaleVector(v, s) { return [v[0]*s, v[1]*s, v[2]*s]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        function length(v) { return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); }
        function distanceSquared(a, b) { const dx = a.x-b.x, dy = a.y-b.y, dz = a.z-b.z; return dx*dx + dy*dy + dz*dz; }
        function distance(a, b) { return Math.sqrt(distanceSquared(a,b)); }
        function transformVector(v, m) {
            const x = v[0], y = v[1], z = v[2];
            return [ x * m[0] + y * m[4] + z * m[8], x * m[1] + y * m[5] + z * m[9], x * m[2] + y * m[6] + z * m[10] ];
        }


        // ----------------------------------------------
        // Game Mesh Generation Functions (Readable)
        // ----------------------------------------------

        function createUnitCubeMesh(gl) {
            const positions = [ // X, Y, Z
                -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, // Front
                -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, // Back
                -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5, // Top
                -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, // Bottom
                 0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5, // Right
                -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, // Left
            ];
            const normals = [
                0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1, // Front
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, // Back
                0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0, // Top
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // Bottom
                1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0, // Right
               -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // Left
            ];
            const texcoords = [ // U, V
                0, 0, 1, 0, 1, 1, 0, 1, // Front
                1, 0, 1, 1, 0, 1, 0, 0, // Back
                0, 1, 0, 0, 1, 0, 1, 1, // Top
                0, 0, 1, 0, 1, 1, 0, 1, // Bottom
                1, 0, 1, 1, 0, 1, 0, 0, // Right
                0, 0, 1, 0, 1, 1, 0, 1, // Left
            ];
            const indices = [
                 0,  1,  2,  0,  2,  3, // Front
                 4,  5,  6,  4,  6,  7, // Back
                 8,  9, 10,  8, 10, 11, // Top
                12, 13, 14, 12, 14, 15, // Bottom
                16, 17, 18, 16, 18, 19, // Right
                20, 21, 22, 20, 22, 23, // Left
            ];
            return { positions: new Float32Array(positions), normals: new Float32Array(normals), texcoords: new Float32Array(texcoords), indices: new Uint16Array(indices), numElements: indices.length, buffers: null };
        }

        function createSphereMesh(gl, radius = 0.5, latBands = 16, longBands = 16) {
             const positions = []; const normals = []; const texcoords = []; const indices = [];
             for (let lat = 0; lat <= latBands; lat++) {
                 const theta = lat * Math.PI / latBands; const sinTheta = Math.sin(theta); const cosTheta = Math.cos(theta);
                 for (let lon = 0; lon <= longBands; lon++) {
                     const phi = lon * 2 * Math.PI / longBands; const sinPhi = Math.sin(phi); const cosPhi = Math.cos(phi);
                     const x = cosPhi * sinTheta; const y = cosTheta; const z = sinPhi * sinTheta;
                     const u = 1 - (lon / longBands); const v = 1 - (lat / latBands);
                     positions.push(radius * x, radius * y, radius * z); normals.push(x, y, z); texcoords.push(u, v);
                 }
             }
             for (let lat = 0; lat < latBands; lat++) {
                 for (let lon = 0; lon < longBands; lon++) {
                     const first = (lat * (longBands + 1)) + lon; const second = first + longBands + 1;
                     indices.push(first, second, first + 1); indices.push(second, second + 1, first + 1);
                 }
             }
             return { positions: new Float32Array(positions), normals: new Float32Array(normals), texcoords: new Float32Array(texcoords), indices: new Uint16Array(indices), numElements: indices.length, buffers: null };
        }

        function createCylinderMesh(gl, radiusTop = 0.0, radiusBottom = 0.5, height = 1.0, segments = 12) {
            const positions = []; const normals = []; const texcoords = []; const indices = [];
            const halfHeight = height / 2;
            positions.push(0, halfHeight, 0); normals.push(0, 1, 0); texcoords.push(0.5, 1); // Top center
            positions.push(0, -halfHeight, 0); normals.push(0, -1, 0); texcoords.push(0.5, 0); // Bottom center
            const topCapStart = 0; const bottomCapStart = 1; const sideStart = 2;

            for (let i = 0; i <= segments; i++) { // Side vertices
                const theta = (i / segments) * Math.PI * 2;
                const sinTheta = Math.sin(theta); const cosTheta = Math.cos(theta);
                const u = i / segments;
                const normal = normalize([cosTheta * height, radiusBottom - radiusTop, sinTheta * height]);
                positions.push(radiusTop * cosTheta, halfHeight, radiusTop * sinTheta); // Top ring
                normals.push(normal[0], normal[1], normal[2]); texcoords.push(u, 1);
                positions.push(radiusBottom * cosTheta, -halfHeight, radiusBottom * sinTheta); // Bottom ring
                normals.push(normal[0], normal[1], normal[2]); texcoords.push(u, 0);
            }
            for (let i = 0; i < segments; i++) { // Side indices
                const i0 = sideStart + i * 2; const i1 = sideStart + i * 2 + 1;
                const i2 = sideStart + (i + 1) * 2; const i3 = sideStart + (i + 1) * 2 + 1;
                indices.push(i0, i1, i2); indices.push(i1, i3, i2);
            }
            if (radiusTop > 0) { // Top cap indices
                 for (let i = 0; i < segments; i++) {
                     indices.push(topCapStart, sideStart + (i + 1) * 2, sideStart + i * 2);
                 }
             }
             if (radiusBottom > 0) { // Bottom cap indices
                 for (let i = 0; i < segments; i++) {
                     indices.push(bottomCapStart, sideStart + i * 2 + 1, sideStart + (i + 1) * 2 + 1);
                 }
            }
             return { positions: new Float32Array(positions), normals: new Float32Array(normals), texcoords: new Float32Array(texcoords), indices: new Uint16Array(indices), numElements: indices.length, buffers: null };
        }

        function createTerrainMesh(chunkX, chunkZ, size, resolution) {
            const positions = []; const normals = []; const texcoords = []; const indices = [];
            const step = size / (resolution - 1);
            for (let z = 0; z < resolution; z++) { // Vertices
                for (let x = 0; x < resolution; x++) {
                    const worldX = chunkX * size + x * step; const worldZ = chunkZ * size + z * step;
                    const height = getTerrainHeight(worldX, worldZ);
                    positions.push(x * step, height, z * step);
                    texcoords.push(x / (resolution - 1), z / (resolution - 1));
                    normals.push(0, 1, 0); // Placeholder
                }
            }
            for (let z = 0; z < resolution - 1; z++) { // Indices
                for (let x = 0; x < resolution - 1; x++) {
                    const i0 = z * resolution + x; const i1 = i0 + 1;
                    const i2 = (z + 1) * resolution + x; const i3 = i2 + 1;
                    indices.push(i0, i2, i1); indices.push(i1, i2, i3);
                }
            }
            const tempNormals = Array(positions.length / 3).fill(0).map(() => [0, 0, 0]); // Normals calc
            for (let i = 0; i < indices.length; i += 3) {
                const i0 = indices[i]; const i1 = indices[i+1]; const i2 = indices[i+2];
                const p0 = [positions[i0*3], positions[i0*3+1], positions[i0*3+2]];
                const p1 = [positions[i1*3], positions[i1*3+1], positions[i1*3+2]];
                const p2 = [positions[i2*3], positions[i2*3+1], positions[i2*3+2]];
                const edge1 = subtractVectors(p1, p0); const edge2 = subtractVectors(p2, p0);
                const faceNormal = normalize(cross(edge1, edge2));
                tempNormals[i0] = addVectors(tempNormals[i0], faceNormal);
                tempNormals[i1] = addVectors(tempNormals[i1], faceNormal);
                tempNormals[i2] = addVectors(tempNormals[i2], faceNormal);
            }
            for (let i = 0; i < tempNormals.length; i++) { // Normalize and flatten
                const n = normalize(tempNormals[i]);
                normals[i*3] = n[0]; normals[i*3+1] = n[1]; normals[i*3+2] = n[2];
            }
            return { positions: new Float32Array(positions), normals: new Float32Array(normals), texcoords: new Float32Array(texcoords), indices: new Uint16Array(indices), numElements: indices.length, buffers: null };
        }

        function createWaterMesh(chunkX, chunkZ, size, resolution) {
             const positions = []; const normals = []; const texcoords = []; const indices = [];
             const step = size / (resolution - 1); const waterHeight = 0.5;
             for (let z = 0; z < resolution; z++) { // Vertices
                 for (let x = 0; x < resolution; x++) {
                     positions.push(x * step, waterHeight, z * step);
                     normals.push(0, 1, 0);
                     texcoords.push(x / (resolution - 1), z / (resolution - 1));
                 }
             }
             for (let z = 0; z < resolution - 1; z++) { // Indices
                 for (let x = 0; x < resolution - 1; x++) {
                     const i0 = z * resolution + x; const i1 = i0 + 1;
                     const i2 = (z + 1) * resolution + x; const i3 = i2 + 1;
                     indices.push(i0, i2, i1); indices.push(i1, i2, i3);
                 }
             }
             return { positions: new Float32Array(positions), normals: new Float32Array(normals), texcoords: new Float32Array(texcoords), indices: new Uint16Array(indices), numElements: indices.length, buffers: null };
        }

        function createMeshBuffers(gl, meshData) {
            if (!meshData || meshData.buffers) return;
            meshData.buffers = {
                position: createBuffer(gl, meshData.positions, gl.ARRAY_BUFFER),
                normal: meshData.normals ? createBuffer(gl, meshData.normals, gl.ARRAY_BUFFER) : null,
                texcoord: meshData.texcoords ? createBuffer(gl, meshData.texcoords, gl.ARRAY_BUFFER) : null,
                indices: meshData.indices ? createBuffer(gl, meshData.indices, gl.ELEMENT_ARRAY_BUFFER) : null,
                vao: createVertexArrayObject(gl)
            };
        }

        // ----------------------------------------------
        // World Generation (Placement Y Offset Fixed)
        // ----------------------------------------------

        function getTerrainHeight(worldX, worldZ) {
            const scale = 0.015; const persistence = 0.5; const lacunarity = 2.0;
            const octaves = 5; let amplitude = 8.0; let frequency = scale; let totalHeight = 0;
            for (let i = 0; i < octaves; i++) { let noiseVal = (game.noise.noise2D(worldX * frequency, worldZ * frequency) + 1) / 2; totalHeight += noiseVal * amplitude; amplitude *= persistence; frequency *= lacunarity; }
            let baseLevel = 2.0; let largeFeatureScale = 0.002; let largeFeatureHeight = 15.0; totalHeight += game.noise.noise2D(worldX * largeFeatureScale, worldZ * largeFeatureScale) * largeFeatureHeight;
             return baseLevel + totalHeight;
        }

        function getChunkKey(chunkX, chunkZ) {
            return `${chunkX},${chunkZ}`;
        }

        function generateChunk(chunkX, chunkZ) {
            const key = getChunkKey(chunkX, chunkZ);
            if (game.world.chunks[key]) return;

            // console.log(`Generating chunk ${key}`);
            const cs = config.chunkSize;
            const res = config.chunkResolution;

            const terrainMeshData = createTerrainMesh(chunkX, chunkZ, cs, res);
            const waterMeshData = createWaterMesh(chunkX, chunkZ, cs, res);

            createMeshBuffers(gl, terrainMeshData);
            createMeshBuffers(gl, waterMeshData);

            const chunk = {
                x: chunkX, z: chunkZ, terrainMesh: terrainMeshData, waterMesh: waterMeshData,
                entities: [], // Store chunk-local entities like trees/rocks here
                needsRenderUpdate: true
            };

            const random = mulberry32(game.world.seed + chunkX * 31 + chunkZ * 17);

            for (let z = 0; z < cs; z++) {
                for (let x = 0; x < cs; x++) {
                    const worldX = chunkX * cs + x + random() * 0.8 - 0.4;
                    const worldZ = chunkZ * cs + z + random() * 0.8 - 0.4;
                    const height = getTerrainHeight(worldX, worldZ); // Base terrain height

                    if (height < (waterMeshData?.positions[1] || 0.5) + 0.1) continue;

                    // Trees
                    if (random() < config.treeDensity) {
                         const treeType = random() > 0.3 ? 'pine' : 'birch';
                         const randomScale = 0.8 + random() * 0.4;
                         const scale = { x: randomScale, y: randomScale * (1.5 + random()*0.5) , z: randomScale };
                         const treeModelHeight = 2.5; // Hardcoded based on createCylinderMesh call
                         const placementY = height + (treeModelHeight / 2) * scale.y; // Adjusted Y

                         chunk.entities.push({
                             id: `tree_${worldX.toFixed(1)}_${worldZ.toFixed(1)}`, type: 'tree', treeType: treeType,
                             position: { x: worldX, y: placementY, z: worldZ }, // Use adjusted Y
                             rotation: { x: 0, y: random() * Math.PI * 2, z: 0 }, scale: scale,
                             health: 50, model: treeType === 'pine' ? 'cylinder_cone' : 'cylinder',
                             color: treeType === 'pine' ? [0.1, 0.4, 0.1, 1.0] : [0.7, 0.7, 0.6, 1.0], sway: 0.8
                         });
                    }
                    // Rocks
                    else if (random() < config.rockDensity) {
                        const rockType = random() > 0.5 ? 'boulder' : 'flintstone';
                         const randomScale = 0.5 + random() * 0.5;
                         const scale = { x: randomScale, y: randomScale * (0.5 + random()*0.3), z: randomScale };
                         const rockModelRadius = 0.5; // Hardcoded based on createSphereMesh default
                         const rockPlacementY = height + rockModelRadius * scale.y; // Adjusted Y

                         chunk.entities.push({
                             id: `rock_${worldX.toFixed(1)}_${worldZ.toFixed(1)}`, type: 'rock', rockType: rockType,
                             position: { x: worldX, y: rockPlacementY, z: worldZ }, // Use adjusted Y
                             rotation: { x: random() * 0.2, y: random() * Math.PI * 2, z: random() * 0.2 }, scale: scale,
                             health: rockType === 'boulder' ? 80 : 30, model: 'sphere',
                             color: rockType === 'boulder' ? [0.5, 0.5, 0.5, 1.0] : [0.6, 0.6, 0.65, 1.0], sway: 0.0
                         });
                    }
                     // Enemies (Spawn into global list)
                    else if (random() < config.enemyDensity) {
                         const enemyType = enemyTypes[Math.floor(random() * enemyTypes.length)];
                         const id = `enemy_${enemyType.id}_${worldX.toFixed(1)}_${worldZ.toFixed(1)}`;
                         const enemyScale = { x: 1, y: 1, z: 1 };

                         let enemyYOffset = 0.5; // Default half-height/radius
                         if (enemyType.model === 'sphere') enemyYOffset = 0.5 * enemyScale.y;
                         else if (enemyType.model === 'cube') enemyYOffset = 0.5 * enemyScale.y;
                         const enemyPlacementY = height + enemyYOffset; // Adjusted Y

                         if (!game.world.entities.find(e => e.id === id)) { // Check global list
                            game.world.entities.push({
                                id: id, type: 'enemy', enemyType: enemyType,
                                spawnPoint: { x: worldX, y: enemyPlacementY, z: worldZ }, // Store adjusted spawn Y
                                position: { x: worldX, y: enemyPlacementY, z: worldZ }, // Use adjusted Y
                                rotation: { x: 0, y: random() * Math.PI * 2, z: 0 }, scale: enemyScale,
                                health: enemyType.health, maxHealth: enemyType.health, speed: enemyType.speed,
                                aiState: 'idle', target: null, velocity: { x: 0, y: 0, z: 0 },
                                model: enemyType.model || 'cube', color: enemyType.color || [1.0, 0.0, 0.0, 1.0], sway: 0.0
                             });
                        }
                    }
                }
            }

            game.world.chunks[key] = chunk;
        }

        function loadRequiredChunks() {
            const { chunkSize, renderDistance } = config;
            const playerChunkX = Math.floor(game.player.position.x / chunkSize);
            const playerChunkZ = Math.floor(game.player.position.z / chunkSize);
            for (let cz = playerChunkZ - renderDistance; cz <= playerChunkZ + renderDistance; cz++) {
                for (let cx = playerChunkX - renderDistance; cx <= playerChunkX + renderDistance; cx++) {
                    generateChunk(cx, cz);
                }
            }
        }

        function unloadDistantChunks() {
            const { chunkSize, renderDistance } = config;
            const playerChunkX = Math.floor(game.player.position.x / chunkSize);
            const playerChunkZ = Math.floor(game.player.position.z / chunkSize);
            const maxDistSq = (renderDistance + 2) * (renderDistance + 2);

            for (const key in game.world.chunks) {
                const chunk = game.world.chunks[key];
                const dx = chunk.x - playerChunkX; const dz = chunk.z - playerChunkZ;
                if (dx*dx + dz*dz > maxDistSq) {
                    // console.log(`Unloading chunk ${key}`);
                    // Clean up WebGL buffers
                    [chunk.terrainMesh, chunk.waterMesh].forEach(mesh => {
                        if (mesh && mesh.buffers) {
                            gl.deleteBuffer(mesh.buffers.position);
                            if(mesh.buffers.normal) gl.deleteBuffer(mesh.buffers.normal);
                            if(mesh.buffers.texcoord) gl.deleteBuffer(mesh.buffers.texcoord);
                            if(mesh.buffers.indices) gl.deleteBuffer(mesh.buffers.indices);
                            if (mesh.buffers.vao && !mesh.buffers.vao._isFallback && gl.deleteVertexArray) {
                                gl.deleteVertexArray(mesh.buffers.vao);
                            }
                        }
                    });
                    delete game.world.chunks[key];
                }
            }
        }


        // ----------------------------------------------
        // Player, Camera and Input (Readable)
        // ----------------------------------------------

        function setupInputListeners() {
             document.addEventListener('keydown', (e) => { game.input.keys[e.code] = true; });
             document.addEventListener('keyup', (e) => { game.input.keys[e.code] = false; });

             canvas.addEventListener('mousedown', (e) => {
                 if (!game.input.pointer.locked) {
                     canvas.requestPointerLock();
                 } else if (e.button === 0) { // Left mouse button
                    game.input.mouse.down = true;
                    game.input.mouse.clicked = true; // Flag for single click events this frame
                 }
             });
             document.addEventListener('mouseup', (e) => {
                 if (e.button === 0) { // Left mouse button
                    game.input.mouse.down = false;
                 }
            });

             document.addEventListener('mousemove', (e) => {
                 game.input.mouse.x = e.clientX;
                 game.input.mouse.y = e.clientY;
                 if (game.input.pointer.locked) {
                     game.input.mouse.dx += e.movementX;
                     game.input.mouse.dy += e.movementY;
                 }
             });

             document.addEventListener('pointerlockchange', () => {
                 const previouslyLocked = game.input.pointer.locked;
                 game.input.pointer.locked = document.pointerLockElement === canvas;
                 if (!game.input.pointer.locked && previouslyLocked) {
                     // console.log("Pointer lock lost/exited.");
                     // Pause only if inventory isn't open (inventory handles its own pause)
                     if (!game.showInventory) {
                         game.paused = true;
                     }
                 } else if (game.input.pointer.locked && !previouslyLocked) {
                    // console.log("Pointer lock acquired.");
                     // Unpause only if inventory isn't open
                     if (!game.showInventory) {
                        game.paused = false;
                     }
                 }
             });

             canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent right-click menu

              document.addEventListener('keydown', (e) => {
                  // Inventory Toggle
                  if (e.code === 'Tab' && game.started && !game.isDead) {
                      e.preventDefault(); toggleInventory();
                  }
                  // Hotbar selection (only when inventory closed)
                  if (e.code.startsWith('Digit') && !e.altKey && !e.ctrlKey && !e.metaKey && !game.showInventory) {
                      const index = parseInt(e.code.substring(5)) - 1;
                      if (index >= 0 && index < game.player.hotbar.length) {
                          game.player.activeHotbarSlot = index; updateHotbarUI();
                      }
                  }
                  // Interaction (only when inventory closed)
                  if (e.code === 'KeyE' && game.started && !game.isDead && !game.showInventory) {
                        if (game.player.interactionTarget) { interactWithTarget(); }
                  }
                  // Jump (only when inventory closed, alive, not paused)
                  if (e.code === 'Space' && game.player.onGround && game.player.stamina > 10 && !game.showInventory && !game.isDead && !game.paused) {
                      game.player.velocity.y = config.jumpForce;
                      game.player.stamina -= 10;
                      game.player.onGround = false;
                      game.player.state = 'jumping';
                  }
              });
        }

        function updateInput(deltaTime) {
            // Movement/Look input only processed if pointer locked and game not paused/dead/inventory open
            if (!game.input.pointer.locked || game.paused || game.isDead || game.showInventory) {
                 game.input.mouse.dx = 0; game.input.mouse.dy = 0;
                 // Click handling is done later, even if paused (for UI)
                 return;
             }

            // Player Look
            game.player.rotation.y -= game.input.mouse.dx * config.mouseSensitivity;
            game.player.rotation.x -= game.input.mouse.dy * config.mouseSensitivity;
            game.player.rotation.x = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, game.player.rotation.x));
            game.input.mouse.dx = 0; game.input.mouse.dy = 0; // Reset delta

            // Player Movement
            const isRunning = game.input.keys['ShiftLeft'] && game.player.stamina > 0 && (game.input.keys['KeyW'] || game.input.keys['KeyS'] || game.input.keys['KeyA'] || game.input.keys['KeyD']);
            const moveSpeed = isRunning ? config.playerRunSpeed : config.playerSpeed;
            let moveDirection = { x: 0, z: 0 }; let moving = false;
            if (game.input.keys['KeyW']) { moveDirection.z -= 1; moving = true; }
            if (game.input.keys['KeyS']) { moveDirection.z += 1; moving = true; }
            if (game.input.keys['KeyA']) { moveDirection.x -= 1; moving = true; }
            if (game.input.keys['KeyD']) { moveDirection.x += 1; moving = true; }

            if (moving) {
                const len = Math.sqrt(moveDirection.x**2 + moveDirection.z**2);
                if (len > 0.01) { // Normalize
                    moveDirection.x /= len; moveDirection.z /= len;
                }
                const sinY = Math.sin(game.player.rotation.y); const cosY = Math.cos(game.player.rotation.y);
                game.player.velocity.x = (moveDirection.x * cosY - moveDirection.z * sinY) * moveSpeed;
                game.player.velocity.z = (moveDirection.x * sinY + moveDirection.z * cosY) * moveSpeed;

                if (isRunning) {
                    game.player.stamina = Math.max(0, game.player.stamina - config.staminaDrainRun * deltaTime);
                    if(game.player.state !== 'jumping' && game.player.state !== 'attacking') game.player.state = 'running';
                } else {
                    if(game.player.state !== 'jumping' && game.player.state !== 'attacking') game.player.state = 'walking';
                }
            } else { // Decelerate
                game.player.velocity.x *= 0.85; game.player.velocity.z *= 0.85;
                if (Math.abs(game.player.velocity.x) < 0.001) game.player.velocity.x = 0;
                if (Math.abs(game.player.velocity.z) < 0.001) game.player.velocity.z = 0;
                if (game.player.state === 'walking' || game.player.state === 'running') game.player.state = 'idle';
            }

             // Stamina Regen
             if (!isRunning && game.player.stamina < game.player.maxStamina) {
                 game.player.stamina = Math.min(game.player.maxStamina, game.player.stamina + config.staminaRegen * deltaTime);
             }

             // Handle Attack / Use Item (Triggered by click flag)
             if (game.input.mouse.clicked && game.player.attackCooldown <= 0) {
                 handlePlayerAction();
                 game.player.attackCooldown = 0.5; // Cooldown in seconds
             }
             game.input.mouse.clicked = false; // Consume click flag for this frame

             if (game.player.attackCooldown > 0) {
                 game.player.attackCooldown -= deltaTime;
             }
        }

        function handlePlayerAction() {
            const equipped = getEquippedItem();
            if (!equipped) { // Punch
                // console.log("Punch!");
                const target = raycastForEnemy(game.camera.position, getCameraDirection(), 3);
                if (target) dealDamage(target, 5);
                game.player.state = 'attacking';
                setTimeout(() => { if(game.player.state === 'attacking') game.player.state = 'idle'; }, 300);
                return;
            }

            const itemDef = items[equipped.id];
            if (!itemDef) return;

            if (itemDef.action === 'attack' || itemDef.action === 'chop' || itemDef.action === 'mine') {
                // console.log(`Attack/Use: ${itemDef.name}`);
                 game.player.state = 'attacking';
                 setTimeout(() => { if(game.player.state === 'attacking') game.player.state = 'idle'; }, 300);
                 const target = raycastForEntity(game.camera.position, getCameraDirection(), config.interactionDistance);
                 if (target) {
                     if (target.type === 'enemy') dealDamage(target, itemDef.damage || 0);
                     else if (target.type === 'tree' && itemDef.action === 'chop') dealDamage(target, itemDef.damage || 0);
                     else if (target.type === 'rock' && itemDef.action === 'mine') dealDamage(target, itemDef.damage || 0);
                     // TODO: Reduce durability
                 }
            } else if (itemDef.action === 'build') {
                 if (game.player.buildMode && game.player.buildTarget && game.player.buildTarget.valid) {
                     placeBuilding();
                 }
            } else if (itemDef.type === 'food') {
                 // console.log(`Consume: ${itemDef.name}`);
                 game.player.food = Math.min(game.player.maxFood, game.player.food + (itemDef.effects?.food || 0));
                 // TODO: Apply health/stamina regen buffs over time
                 removeItemFromInventorySlot(game.player.activeHotbarSlot, 1, true);
            } else if (itemDef.action === 'light') {
                 console.log("Using torch (visual only for now)");
            }
        }

        function updatePlayerPhysics(deltaTime) {
            if (game.isDead) return;

            game.player.velocity.y -= config.gravity;
            let nextPos = {
                x: game.player.position.x + game.player.velocity.x,
                y: game.player.position.y + game.player.velocity.y,
                z: game.player.position.z + game.player.velocity.z
            };
            const playerHeight = 1.8; const stepHeight = 0.5;

            const terrainHeight = getTerrainHeight(nextPos.x, nextPos.z); // Height at future horizontal pos
            const groundY = terrainHeight;

             if (nextPos.y < groundY && game.player.velocity.y <= 0) {
                 game.player.position.y = groundY; game.player.velocity.y = 0; game.player.onGround = true;
                 if (game.player.state === 'jumping') game.player.state = 'idle';
             } else {
                 game.player.position.y = nextPos.y; game.player.onGround = false;
                 if (game.player.velocity.y < -0.05 && game.player.state !== 'jumping' && game.player.state !== 'attacking') {
                     game.player.state = 'jumping';
                 }
             }

            // Horizontal Collision
             let collisionX = false; let collisionZ = false;
             const heightAtNextX = getTerrainHeight(nextPos.x, game.player.position.z);
             if (heightAtNextX > game.player.position.y + stepHeight) collisionX = true;
             const heightAtNextZ = getTerrainHeight(game.player.position.x, nextPos.z);
             if (heightAtNextZ > game.player.position.y + stepHeight) collisionZ = true;

             if (!collisionX) game.player.position.x = nextPos.x;
             else game.player.velocity.x = 0;
             if (!collisionZ) game.player.position.z = nextPos.z;
             else game.player.velocity.z = 0;

             // TODO: Collision with entities and built objects
        }

        function updateCamera() {
            game.camera.rotation.x = game.player.rotation.x; game.camera.rotation.y = game.player.rotation.y;
            const camDist = config.thirdPersonDistance; const pitch = game.camera.rotation.x; const yaw = game.camera.rotation.y;
            const playerHeadPos = { x: game.player.position.x, y: game.player.position.y + config.cameraOffset.y, z: game.player.position.z };
            const offsetX = camDist * Math.sin(yaw) * Math.cos(pitch); const offsetY = camDist * Math.sin(pitch); const offsetZ = camDist * Math.cos(yaw) * Math.cos(pitch);
            let targetCamPos = { x: playerHeadPos.x - offsetX, y: playerHeadPos.y - offsetY, z: playerHeadPos.z - offsetZ };

             const direction = subtractVectors([targetCamPos.x, targetCamPos.y, targetCamPos.z],[playerHeadPos.x, playerHeadPos.y, playerHeadPos.z]);
             const dist = length(direction);
             if (dist < 0.01) { game.camera.position = playerHeadPos; return; } // Avoid zero distance
             const normalizedDir = normalize(direction);
             const collisionPoint = raycastForTerrain(playerHeadPos, normalizedDir, dist); // TODO: Raycast against other objects too

             if (collisionPoint) {
                 const collisionDist = distance(playerHeadPos, collisionPoint); const buffer = 0.3;
                 const newDist = Math.max(0.5, collisionDist - buffer);
                 game.camera.position.x = playerHeadPos.x + normalizedDir[0] * newDist;
                 game.camera.position.y = playerHeadPos.y + normalizedDir[1] * newDist;
                 game.camera.position.z = playerHeadPos.z + normalizedDir[2] * newDist;
             } else {
                 game.camera.position = targetCamPos;
             }
        }

        function getCameraDirection() {
            const pitch = game.camera.rotation.x; const yaw = game.camera.rotation.y;
            return normalize([-Math.sin(yaw) * Math.cos(pitch), -Math.sin(pitch), -Math.cos(yaw) * Math.cos(pitch)]);
        }

        function raycastForTerrain(origin, direction, maxDistance) {
            const step = 0.5; let currentPos = { ...origin };
            for (let d = 0; d < maxDistance; d += step) {
                currentPos.x += direction[0] * step; currentPos.y += direction[1] * step; currentPos.z += direction[2] * step;
                const terrainHeight = getTerrainHeight(currentPos.x, currentPos.z);
                if (currentPos.y <= terrainHeight) { // Hit
                    const prevPos = { x: currentPos.x - direction[0] * step, y: currentPos.y - direction[1] * step, z: currentPos.z - direction[2] * step };
                    const yDiff = prevPos.y - currentPos.y;
                    if (Math.abs(yDiff) > 0.01) { // Interpolate hit point
                        const t = (prevPos.y - terrainHeight) / yDiff;
                        return { x: prevPos.x + direction[0] * step * t, y: terrainHeight, z: prevPos.z + direction[2] * step * t };
                    } else { return { x: currentPos.x, y: terrainHeight, z: currentPos.z }; } // Fallback
                }
            }
            return null; // No hit
        }

        function raycastForEntity(origin, direction, maxDistance) {
            let closestHit = null; let minDistanceSq = maxDistance * maxDistance;
            const checkEntity = (entity) => {
                if (!entity.position || !entity.model) return;
                const scale = entity.scale || { x:1, y:1, z:1 };
                const radius = Math.max(scale.x, scale.y, scale.z) * 0.5; // Approx radius
                const entityCenter = [entity.position.x, entity.position.y + scale.y * 0.5, entity.position.z]; // Approx center
                const originVec = [origin.x, origin.y, origin.z];
                const L = subtractVectors(entityCenter, originVec); const tca = dot(L, direction); const d2 = dot(L, L) - tca * tca;
                if (d2 > radius * radius) return; // Missed sphere projection
                const thc = Math.sqrt(radius * radius - d2); const t0 = tca - thc; const t1 = tca + thc;
                 if (t0 <= maxDistance && t0 > 0.01) { // Check entry point first (add small epsilon)
                    if (t0 * t0 < minDistanceSq) { minDistanceSq = t0 * t0; closestHit = entity; }
                 } else if (t1 <= maxDistance && t1 > 0.01) { // Check exit point if entry was behind/inside
                     if (t1 * t1 < minDistanceSq) { minDistanceSq = t1 * t1; closestHit = entity; }
                 }
            };
             const { chunkSize } = config; const playerChunkX = Math.floor(game.player.position.x / chunkSize); const playerChunkZ = Math.floor(game.player.position.z / chunkSize);
             for (let dz = -1; dz <= 1; dz++) { for (let dx = -1; dx <= 1; dx++) { const key = getChunkKey(playerChunkX + dx, playerChunkZ + dz); const chunk = game.world.chunks[key]; if (chunk && chunk.entities) chunk.entities.forEach(checkEntity); } } // Check local chunk entities
            game.world.entities.forEach(checkEntity); // Check global entities
            game.world.builtObjects.forEach(checkEntity); // Check built objects
            return closestHit;
        }

        function raycastForEnemy(origin, direction, maxDistance) { // Similar to raycastForEntity but filters type: 'enemy'
             let closestHit = null; let minDistanceSq = maxDistance * maxDistance;
             game.world.entities.forEach(entity => {
                if (entity.type !== 'enemy' || !entity.position || !entity.model) return;
                const scale = entity.scale || { x:1, y:1, z:1 }; const radius = Math.max(scale.x, scale.y, scale.z) * 0.7; // Slightly larger hitbox?
                const entityCenter = [entity.position.x, entity.position.y + scale.y * 0.5, entity.position.z];
                const originVec = [origin.x, origin.y, origin.z];
                const L = subtractVectors(entityCenter, originVec); const tca = dot(L, direction); const d2 = dot(L, L) - tca * tca;
                if (d2 > radius * radius) return;
                const thc = Math.sqrt(radius * radius - d2); const t0 = tca - thc; const t1 = tca + thc;
                 if (t0 <= maxDistance && t0 > 0.01) { if (t0 * t0 < minDistanceSq) { minDistanceSq = t0 * t0; closestHit = entity; } }
                 else if (t1 <= maxDistance && t1 > 0.01) { if (t1 * t1 < minDistanceSq) { minDistanceSq = t1 * t1; closestHit = entity; } }
             });
             return closestHit;
         }


        // ----------------------------------------------
        // Interaction Logic (Readable)
        // ----------------------------------------------

        function findInteractableObject() {
            const origin = game.camera.position;
            const direction = getCameraDirection();
            const hitEntity = raycastForEntity(origin, direction, config.interactionDistance);

            if (hitEntity && hitEntity.position && (hitEntity.type === 'tree' || hitEntity.type === 'rock' || hitEntity.type === 'item_drop' || hitEntity.type === 'workbench' || hitEntity.type === 'door_wood' || hitEntity.isBuilding)) {
                 if (distanceSquared(game.player.position, hitEntity.position) < config.interactionDistance**2) { // Check distance from player feet
                    return hitEntity;
                 }
            }
            return null;
        }

        function updateInteractionPrompt() {
            const target = findInteractableObject();
            game.player.interactionTarget = target;

            if (target) {
                let text = `[E] Interact`;
                 if (target.type === 'tree') text = `[E] Chop ${target.treeType || ''} (${target.health?.toFixed(0) || 'N/A'} HP)`;
                 else if (target.type === 'rock') text = `[E] Mine ${target.rockType || ''} (${target.health?.toFixed(0) || 'N/A'} HP)`;
                 else if (target.type === 'item_drop') text = `[E] Pick up ${items[target.itemId]?.name || 'Item'}`;
                 else if (target.type === 'workbench') text = `[E] Use Workbench`;
                 else if (target.type === 'door_wood') text = `[E] ${target.isOpen ? 'Close' : 'Open'} Door`;
                 else if (target.isBuilding) { text = `[E] Use ${buildings.find(b=>b.id === target.type)?.name || target.type}`; }
                interactionPrompt.textContent = text;
                interactionPrompt.style.display = 'block';
            } else {
                interactionPrompt.style.display = 'none';
            }
        }

        function interactWithTarget() {
             const target = game.player.interactionTarget;
             if (!target) return;
             // console.log("Interacting with:", target.type, target.id);

             if (target.type === 'tree' || target.type === 'rock') { /* Handled by click */ }
             else if (target.type === 'item_drop') {
                 if (addItemToInventory(target.itemId, target.count)) {
                     let removed = false;
                     const index = game.world.entities.findIndex(e => e && e.id === target.id); // Search global list
                     if (index > -1) { game.world.entities.splice(index, 1); removed = true; }
                     // Optionally check chunk entities if drops could be stored there
                     if (removed) { game.player.interactionTarget = null; updateInteractionPrompt(); }
                     else { console.warn("Could not find item drop entity to remove:", target.id); }
                 } else { console.log("Inventory full!"); /* Add UI feedback */ }
             } else if (target.type === 'workbench') {
                 openCrafting(true);
             } else if (target.type === 'door_wood') {
                 target.isOpen = !target.isOpen;
                 // console.log(`Door ${target.id} is now ${target.isOpen ? 'open' : 'closed'}`);
                 updateInteractionPrompt(); // Update prompt text
             }
        }

        // ----------------------------------------------
        // Inventory and Crafting Logic (Readable)
        // ----------------------------------------------

        function findEmptyInventorySlot() {
            return game.player.inventory.findIndex(slot => slot === null);
        }

        function findInventoryStack(itemId) {
            const itemDef = items[itemId];
            if (!itemDef || !itemDef.stackable) return -1;
            for (let i = 0; i < game.player.inventory.length; i++) {
                const slot = game.player.inventory[i];
                if (slot && slot.id === itemId && slot.count < itemDef.maxStack) return i;
            }
            return -1;
        }

        function addItemToInventory(itemId, count = 1) {
             const itemDef = items[itemId]; if (!itemDef) return false;
             let remainingCount = count;
             if (itemDef.stackable) { // Try stacking
                 while (remainingCount > 0) {
                     const stackIndex = findInventoryStack(itemId);
                     if (stackIndex !== -1) {
                         const slot = game.player.inventory[stackIndex];
                         const amountToAdd = Math.min(remainingCount, itemDef.maxStack - slot.count);
                         slot.count += amountToAdd; remainingCount -= amountToAdd;
                     } else break;
                 }
             }
             while (remainingCount > 0) { // Add to empty slots
                 const emptyIndex = findEmptyInventorySlot();
                 if (emptyIndex !== -1) {
                     const amountToAdd = itemDef.stackable ? Math.min(remainingCount, itemDef.maxStack) : 1;
                     game.player.inventory[emptyIndex] = { id: itemId, count: amountToAdd, durability: itemDef.durability };
                     remainingCount -= amountToAdd;
                     if (!itemDef.stackable && remainingCount > 0) continue; // Need more slots for non-stackables
                 } else {
                     console.warn("Inventory full, cannot add item:", itemId);
                     updateInventoryUI(); updateHotbarUI(); return false;
                 }
             }
             updateInventoryUI(); updateHotbarUI(); return true;
        }

        function removeItemFromInventorySlot(slotIndex, count = 1, isHotbarIndex = false) {
            const targetSlotIndex = isHotbarIndex ? game.player.hotbar[slotIndex] : slotIndex;
            if (targetSlotIndex === null || targetSlotIndex < 0 || targetSlotIndex >= game.player.inventory.length) return false;
            const slot = game.player.inventory[targetSlotIndex];
            if (!slot) return false;
            if (slot.count > count) slot.count -= count;
            else {
                game.player.inventory[targetSlotIndex] = null;
                updateHotbarReferences(targetSlotIndex, null); // Clear hotbar refs to this slot
            }
            updateInventoryUI(); updateHotbarUI(); return true;
        }

        function countItem(itemId) {
            return game.player.inventory.reduce((total, slot) => total + (slot && slot.id === itemId ? slot.count : 0), 0);
        }

        function hasMaterials(recipeOrBuildDef) {
            if (!recipeOrBuildDef?.materials) return true;
            return recipeOrBuildDef.materials.every(mat => countItem(mat.item) >= mat.count);
        }

        function isNearCraftingStation(stationId) {
             if (!stationId) return true; // No station needed
             const searchRadiusSq = 5 * 5;
             return game.world.builtObjects.some(obj => obj.type === stationId && distanceSquared(game.player.position, obj.position) < searchRadiusSq);
         }

        function craftItem(recipeId) {
             const recipe = recipes.find(r => r.id === recipeId); if (!recipe) return;
             if (!isNearCraftingStation(recipe.station)) { console.log(`Requires nearby ${recipe.station}`); return; }
             if (hasMaterials(recipe)) {
                 // Consume materials (assume consumeMaterials handles UI updates)
                 if (recipe.materials.every(mat => consumeMaterials(mat.item, mat.count))) {
                     if (!addItemToInventory(recipe.result, 1)) { console.log("Inventory full, cannot craft!"); /* TODO: Refund? */ }
                     else { console.log("Crafted:", recipe.name); }
                 } else { console.error("Material consumption failed unexpectedly for:", recipeId); /* TODO: Refund? */ }
             } else { console.log("Not enough materials for:", recipe.name); }
             // Update crafting UI after attempt
             updateCraftingUI(isNearCraftingStation('workbench'));
        }

        function consumeMaterials(itemId, count) { // Global version
             let remainingToRemove = count;
             for (let i = game.player.inventory.length - 1; i >= 0; i--) {
                 if (remainingToRemove <= 0) break;
                 const slot = game.player.inventory[i];
                 if (slot && slot.id === itemId) {
                     if (slot.count > remainingToRemove) { slot.count -= remainingToRemove; remainingToRemove = 0; }
                     else { remainingToRemove -= slot.count; game.player.inventory[i] = null; updateHotbarReferences(i, null); }
                 }
             }
             const success = remainingToRemove <= 0;
             if (success) { updateInventoryUI(); updateHotbarUI(); } // Update UI only on success
             return success;
         }

        function toggleInventory() {
            game.showInventory = !game.showInventory;
            inventoryUI.style.display = game.showInventory ? 'block' : 'none';
            game.showCrafting = game.showInventory; // Link crafting visibility
            craftingUI.style.display = game.showCrafting ? 'block' : 'none';
            if (game.showInventory) {
                updateInventoryUI(); updateCraftingUI(); // Update on open
                if (game.input.pointer.locked) document.exitPointerLock();
                game.paused = true; // Pause when UI open
            } else {
                game.paused = false; // Unpause when UI closed
                // Request lock only if game is running and wasn't already unlocked
                if (!game.input.pointer.locked && game.started && !game.isDead) {
                   setTimeout(() => canvas.requestPointerLock(), 50); // Small delay
                }
            }
        }

        function updateInventoryUI() {
             if (!game.showInventory) return;
             inventoryGrid.innerHTML = '';
             game.player.inventory.forEach((item, index) => {
                 const slotDiv = document.createElement('div'); slotDiv.classList.add('inventory-slot'); slotDiv.dataset.index = index;
                 if (item) {
                     const itemDef = items[item.id]; slotDiv.textContent = itemDef?.icon || '?';
                     slotDiv.title = `${itemDef?.name || 'Unknown'}${item.count>1?' x'+item.count:''} ${item.durability!==undefined?'\nDur: '+item.durability:''}`;
                     if (item.count > 1) { const c = document.createElement('span'); c.classList.add('count'); c.textContent = item.count; slotDiv.appendChild(c); }
                     slotDiv.draggable = true; slotDiv.addEventListener('dragstart', handleDragStart); slotDiv.addEventListener('dragend', handleDragEnd);
                 } else slotDiv.draggable = false;
                 slotDiv.addEventListener('dragover', handleDragOver); slotDiv.addEventListener('drop', handleDrop);
                 slotDiv.addEventListener('dragenter', handleDragEnter); slotDiv.addEventListener('dragleave', handleDragLeave);
                 inventoryGrid.appendChild(slotDiv);
             });
        }

        let draggedItemIndex = null; let draggedItemSource = null;

        function handleDragStart(e) {
             const slot = e.target.closest('.inventory-slot, .hotbar-slot'); if (!slot) return;
             const index = parseInt(slot.dataset.index);
             let itemExists = false;
             if (slot.classList.contains('inventory-slot')) {
                 if (game.player.inventory[index]) { draggedItemIndex = index; draggedItemSource = 'inventory'; itemExists = true; }
             } else if (slot.classList.contains('hotbar-slot')) {
                 const invIndex = game.player.hotbar[index];
                 if (invIndex !== null && game.player.inventory[invIndex]) { draggedItemIndex = index; draggedItemSource = 'hotbar'; itemExists = true; }
             }
             if (itemExists) { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', index); slot.style.opacity = '0.5'; }
             else e.preventDefault();
        }
        function handleDragEnter(e) { const slot = e.target.closest('.inventory-slot, .hotbar-slot'); if (slot) slot.classList.add('drag-over'); }
        function handleDragLeave(e) { const slot = e.target.closest('.inventory-slot, .hotbar-slot'); if (slot) slot.classList.remove('drag-over'); }
        function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }

        function handleDrop(e) {
             e.preventDefault();
             const targetSlot = e.target.closest('.inventory-slot, .hotbar-slot');
             if (targetSlot) targetSlot.classList.remove('drag-over');
             if (!targetSlot || draggedItemIndex === null || draggedItemSource === null) return;
             const targetIndex = parseInt(targetSlot.dataset.index);
             const targetType = targetSlot.classList.contains('inventory-slot') ? 'inventory' : 'hotbar';
             // console.log(`Drop: ${draggedItemSource}[${draggedItemIndex}] -> ${targetType}[${targetIndex}]`);

             if (draggedItemSource === 'inventory' && targetType === 'inventory') { // Inv -> Inv
                 if (draggedItemIndex === targetIndex) return;
                 const sourceItem = game.player.inventory[draggedItemIndex]; const targetItem = game.player.inventory[targetIndex];
                 if (!sourceItem) return;
                 const sourceDef = items[sourceItem.id];
                 if (targetItem && targetItem.id === sourceItem.id && sourceDef.stackable && targetItem.count < sourceDef.maxStack) { // Stack
                     const amountToAdd = Math.min(sourceItem.count, sourceDef.maxStack - targetItem.count);
                     targetItem.count += amountToAdd; sourceItem.count -= amountToAdd;
                     if (sourceItem.count <= 0) { game.player.inventory[draggedItemIndex] = null; updateHotbarReferences(draggedItemIndex, null); }
                 } else { // Swap
                     game.player.inventory[targetIndex] = sourceItem; game.player.inventory[draggedItemIndex] = targetItem;
                     updateHotbarReferences(draggedItemIndex, targetIndex, true); // Swap refs
                 }
             } else if (draggedItemSource === 'inventory' && targetType === 'hotbar') { // Inv -> Hotbar
                 if (game.player.inventory[draggedItemIndex]) { // Ensure item still exists
                    const oldHotbarIndex = game.player.hotbar.indexOf(draggedItemIndex); // Find if already on hotbar
                    if (oldHotbarIndex !== -1) game.player.hotbar[oldHotbarIndex] = null; // Clear old ref if exists
                    game.player.hotbar[targetIndex] = draggedItemIndex; // Assign new ref
                 }
             } else if (draggedItemSource === 'hotbar' && targetType === 'inventory') { // Hotbar -> Inv
                 const invIndex = game.player.hotbar[draggedItemIndex];
                 if (invIndex === targetIndex) game.player.hotbar[draggedItemIndex] = null; // Clear if dropped on own slot
             } else if (draggedItemSource === 'hotbar' && targetType === 'hotbar') { // Hotbar -> Hotbar
                 if (draggedItemIndex === targetIndex) return;
                 const sourceRef = game.player.hotbar[draggedItemIndex]; const targetRef = game.player.hotbar[targetIndex];
                 game.player.hotbar[targetIndex] = sourceRef; game.player.hotbar[draggedItemIndex] = targetRef; // Swap refs
             }
             updateInventoryUI(); updateHotbarUI();
        }

        function handleDragEnd(e) { // Clean up styling and state
             const sourceSlotSelector = draggedItemSource === 'inventory' ? `.inventory-slot[data-index="${draggedItemIndex}"]` : `.hotbar-slot[data-index="${draggedItemIndex}"]`;
             const sourceSlot = draggedItemSource ? (draggedItemSource === 'inventory' ? inventoryGrid : hotbarUI).querySelector(sourceSlotSelector) : null;
             if (sourceSlot) sourceSlot.style.opacity = '1.0';
             document.querySelectorAll('.inventory-slot, .hotbar-slot').forEach(s => s.classList.remove('drag-over')); // Clear all highlights
             draggedItemIndex = null; draggedItemSource = null;
         }

        function updateHotbarReferences(invIndexOld, invIndexNew, swap = false) {
            for (let i = 0; i < game.player.hotbar.length; i++) {
                if (game.player.hotbar[i] === invIndexOld) game.player.hotbar[i] = invIndexNew;
                else if (swap && game.player.hotbar[i] === invIndexNew) game.player.hotbar[i] = invIndexOld; // Handle swap case
            }
        }

        function updateHotbarUI() {
            hotbarUI.innerHTML = '';
            game.player.hotbar.forEach((inventoryIndex, index) => {
                const slotDiv = document.createElement('div'); slotDiv.classList.add('hotbar-slot'); slotDiv.dataset.index = index;
                slotDiv.addEventListener('dragover', handleDragOver); slotDiv.addEventListener('drop', handleDrop);
                slotDiv.addEventListener('dragenter', handleDragEnter); slotDiv.addEventListener('dragleave', handleDragLeave);
                const indexSpan = document.createElement('span'); indexSpan.classList.add('index'); indexSpan.textContent = index + 1; slotDiv.appendChild(indexSpan);
                if (inventoryIndex !== null && game.player.inventory[inventoryIndex]) {
                    const item = game.player.inventory[inventoryIndex]; const itemDef = items[item.id];
                    const iconSpan = document.createElement('span'); iconSpan.textContent = itemDef?.icon || '?'; slotDiv.appendChild(iconSpan);
                    slotDiv.title = `${itemDef?.name || 'Unknown'}${item.count>1?' x'+item.count:''}`;
                    if (item.count > 1) { const c = document.createElement('span'); c.classList.add('count'); c.textContent = item.count; slotDiv.appendChild(c); }
                    slotDiv.draggable = true; slotDiv.addEventListener('dragstart', handleDragStart); slotDiv.addEventListener('dragend', handleDragEnd);
                } else {
                     slotDiv.draggable = false;
                     if (inventoryIndex !== null) game.player.hotbar[index] = null; // Correct invalid reference
                }
                if (index === game.player.activeHotbarSlot) slotDiv.classList.add('active');
                hotbarUI.appendChild(slotDiv);
            });
        }

        function openCrafting(nearWorkbench = false) {
            if (!game.showInventory) { game.showInventory = true; inventoryUI.style.display = 'block'; }
            if (!game.showCrafting) { game.showCrafting = true; craftingUI.style.display = 'block'; }
            if (game.input.pointer.locked) document.exitPointerLock();
            if (!game.paused) game.paused = true;
            updateCraftingUI(nearWorkbench); updateInventoryUI();
        }

        function updateCraftingUI(nearWorkbench = false) {
            if (!game.showCrafting) return;
            craftingList.innerHTML = '';
            const actuallyNearWorkbench = nearWorkbench || isNearCraftingStation('workbench');
            recipes.forEach(recipe => {
                 if (recipe.station === 'workbench' && !actuallyNearWorkbench) return; // Filter workbench
                 const canCraft = hasMaterials(recipe);
                 const itemDiv = document.createElement('div'); itemDiv.classList.add('crafting-item');
                 if (canCraft) itemDiv.classList.add('can-craft');
                 itemDiv.dataset.recipeId = recipe.id;
                 const resultItemDef = items[recipe.result];
                 const stationNeeded = recipe.station;
                 const stationAvailable = !stationNeeded || isNearCraftingStation(stationNeeded);
                 itemDiv.innerHTML = `<span>${resultItemDef?.icon || ''} ${recipe.name}</span>
                     <div class="materials">
                         ${recipe.materials.map(mat => `<span style="color:${countItem(mat.item) >= mat.count ? '#8f8':'#f88'}">${mat.count} ${items[mat.item]?.name || mat.item}</span>`).join(', ')}
                         ${stationNeeded ? `<span style="color:${stationAvailable ? '#aaa':'#f88'};">(${stationNeeded}${!stationAvailable ? ' required':' Nearby'})</span>` : ''}
                     </div>`;
                 if (canCraft && stationAvailable) { itemDiv.onclick = () => craftItem(recipe.id); }
                 else { itemDiv.style.cursor = 'not-allowed'; itemDiv.style.opacity = '0.6'; }
                 craftingList.appendChild(itemDiv);
            });
        }

        function getEquippedItem() {
             const hotbarIndex = game.player.activeHotbarSlot; if (hotbarIndex < 0 || hotbarIndex >= game.player.hotbar.length) return null;
             const inventoryIndex = game.player.hotbar[hotbarIndex];
             return (inventoryIndex !== null && game.player.inventory[inventoryIndex]) ? game.player.inventory[inventoryIndex] : null;
        }


        // ----------------------------------------------
        // Combat and Health (Readable)
        // ----------------------------------------------

         function dealDamage(target, amount) {
             if (!target || typeof target.health !== 'number') return;
             target.health -= amount;
             // console.log(`${target.id || target.type} took ${amount} damage, health: ${target.health.toFixed(1)}`);
             if (target.health <= 0) handleDeath(target);
             else if (target.type === 'enemy' && target.aiState !== 'attacking') {
                 target.aiState = 'chasing'; target.target = game.player;
             }
         }

         function handleDeath(entity) {
             // console.log(`${entity.id || entity.type} died.`);
             if (entity === game.player) {
                 game.isDead = true; deathScreen.style.display = 'flex';
                 if (game.input.pointer.locked) document.exitPointerLock();
                 game.paused = true;
             } else { // NPC/Enemy/Object death
                 const drops = entity.enemyType?.drops
                             || (entity.type === 'tree' ? [{item:'wood', chance: 1.0, min:3, max:5},{item:'resin', chance:0.3, min:0, max:1}] : [])
                             || (entity.type === 'rock' ? [{item:'stone', chance: 1.0, min:2, max:4}, {item:'flint', chance:0.2, min:0, max:1}] : []);
                 drops.forEach(drop => {
                     if (Math.random() < drop.chance) {
                         const count = drop.min + Math.floor(Math.random() * (drop.max - drop.min + 1));
                         if (count > 0) spawnItemDrop(entity.position, drop.item, count);
                     }
                 });

                 // Remove entity from world
                 let removed = false;
                 // Check chunk entities first (trees/rocks are stored here)
                 const chunkX = Math.floor(entity.position.x / config.chunkSize);
                 const chunkZ = Math.floor(entity.position.z / config.chunkSize);
                 const key = getChunkKey(chunkX, chunkZ);
                 const chunk = game.world.chunks[key];
                 if (chunk && chunk.entities) {
                     const index = chunk.entities.findIndex(e => e && e.id === entity.id);
                     if (index > -1) { chunk.entities.splice(index, 1); removed = true; }
                 }
                 // If not found in chunk, check global list (enemies/drops are here)
                 if (!removed) {
                     const index = game.world.entities.findIndex(e => e && e.id === entity.id);
                     if (index > -1) { game.world.entities.splice(index, 1); removed = true; }
                 }
                 // If still not found, check built objects
                  if (!removed) {
                     const index = game.world.builtObjects.findIndex(e => e && e.id === entity.id);
                     if (index > -1) { game.world.builtObjects.splice(index, 1); removed = true; }
                 }
                 // if (!removed) console.warn("Could not find entity to remove after death:", entity.id || entity.type);
             }
         }

         function respawnPlayer() {
             game.isDead = false; deathScreen.style.display = 'none'; game.paused = false;
             game.player.health = game.player.maxHealth * 0.5; game.player.stamina = game.player.maxStamina; game.player.food = 50;
             game.player.position = { x: config.chunkSize / 2, y: 50, z: config.chunkSize / 2 }; // TODO: Respawn at bed/origin
             game.player.velocity = { x: 0, y: 0, z: 0 };
             if (!game.input.pointer.locked) canvas.requestPointerLock();
         }

         function spawnItemDrop(position, itemId, count) {
             const itemDef = items[itemId]; if (!itemDef || count <= 0) return;
             const dropEntity = {
                 id: `drop_${itemId}_${Date.now()}_${Math.random().toString(16).slice(2)}`, type: 'item_drop', itemId: itemId, count: count,
                 position: { x: position.x, y: position.y + 0.2, z: position.z }, velocity: {x:0, y:0.05, z:0},
                 rotation: { x: 0, y: 0, z: 0 }, scale: { x: 0.3, y: 0.3, z: 0.3 },
                 model: 'cube', color: [0.9, 0.9, 0.1, 1.0],
                 creationTime: game.currentTime, despawnTime: 300 // 5 minutes
             };
             game.world.entities.push(dropEntity); // Add to global list
             // console.log(`Spawned item drop: ${count}x ${itemDef.name}`);
         }


        // ----------------------------------------------
        // Enemy AI (Readable)
        // ----------------------------------------------

        function updateEnemyAI(enemy, deltaTime) {
             if (!enemy?.position) return;
             const playerPos = game.player.position; const enemyPos = enemy.position;
             const distSq = distanceSquared(playerPos, enemyPos);
             const detectionRadiusSq = 20*20; const attackRadiusSq = 2*2;
             const wanderRadius = 15; const loseAggroDistSq = detectionRadiusSq * 2.25;

             enemy.aiState = enemy.aiState || 'idle'; enemy.velocity = enemy.velocity || { x: 0, y: 0, z: 0 };

             // State Transitions
             if (!game.isDead) { // Only aggro if player is alive
                 if (enemy.aiState !== 'chasing' && enemy.aiState !== 'attacking' && distSq < detectionRadiusSq) {
                     enemy.aiState = 'chasing'; enemy.target = game.player;
                 } else if ((enemy.aiState === 'chasing' || enemy.aiState === 'attacking') && distSq > loseAggroDistSq) {
                     enemy.aiState = 'idle'; enemy.target = null; // Lose target
                 } else if ((enemy.aiState === 'chasing' || enemy.aiState === 'attacking') && (!enemy.target || game.isDead)) {
                     enemy.aiState = 'idle'; enemy.target = null; // Target invalid
                 }
             } else if (enemy.aiState === 'chasing' || enemy.aiState === 'attacking') {
                 enemy.aiState = 'idle'; enemy.target = null; // De-aggro if player dead
             }

             // State Actions & Physics
             switch (enemy.aiState) {
                 case 'idle':
                     if (enemy.idleTimer === undefined) enemy.idleTimer = Math.random() * 5 + 2;
                     enemy.idleTimer -= deltaTime;
                     if (enemy.idleTimer <= 0) { enemy.aiState = 'wandering'; enemy.wanderTarget = null; enemy.idleTimer = undefined; }
                     enemy.velocity.x = 0; enemy.velocity.z = 0; // Stop horizontal movement
                     break;
                 case 'wandering':
                     if (!enemy.wanderTarget || distanceSquared(enemy.position, enemy.wanderTarget) < 1.0) { // Find new target
                         const wanderDist = Math.random() * wanderRadius; const wanderAngle = Math.random() * Math.PI * 2;
                         const origin = enemy.spawnPoint || enemy.position;
                         enemy.wanderTarget = { x: origin.x + Math.cos(wanderAngle) * wanderDist, y: 0, z: origin.z + Math.sin(wanderAngle) * wanderDist };
                         enemy.wanderTarget.y = getTerrainHeight(enemy.wanderTarget.x, enemy.wanderTarget.z); // Estimate Y
                     }
                     const dirToWander = subtractVectors([enemy.wanderTarget.x, 0, enemy.wanderTarget.z], [enemyPos.x, 0, enemyPos.z]);
                     const distToWander = length(dirToWander);
                     if (distToWander > 0.5) { // Move towards target
                        const normDirWander = scaleVector(dirToWander, 1.0 / distToWander);
                        enemy.velocity.x = normDirWander[0] * enemy.speed * 0.5; enemy.velocity.z = normDirWander[2] * enemy.speed * 0.5;
                        enemy.rotation.y = Math.atan2(normDirWander[0], normDirWander[2]);
                     } else { // Reached target
                         enemy.velocity.x = 0; enemy.velocity.z = 0; enemy.aiState = 'idle'; enemy.wanderTarget = null; enemy.idleTimer = undefined;
                     }
                     break;
                 case 'chasing':
                     if (!enemy.target) { enemy.aiState = 'idle'; break; }
                     if (distSq < attackRadiusSq) { // Attack range
                         enemy.aiState = 'attacking'; enemy.attackTimer = 1.5; enemy.velocity.x = 0; enemy.velocity.z = 0;
                         // console.log(`${enemy.id || enemy.type} attacks player!`);
                         dealDamage(game.player, enemy.enemyType.damage);
                         const dirToPlayerAttack = subtractVectors([playerPos.x, 0, playerPos.z], [enemyPos.x, 0, enemyPos.z]);
                         enemy.rotation.y = Math.atan2(dirToPlayerAttack[0], dirToPlayerAttack[2]);
                     } else { // Move towards player
                         const dirToPlayer = subtractVectors([playerPos.x, 0, playerPos.z], [enemyPos.x, 0, enemyPos.z]);
                         const normDir = normalize(dirToPlayer);
                         enemy.velocity.x = normDir[0] * enemy.speed; enemy.velocity.z = normDir[2] * enemy.speed;
                         enemy.rotation.y = Math.atan2(normDir[0], normDir[2]);
                     }
                     break;
                 case 'attacking':
                     if (enemy.attackTimer === undefined) enemy.attackTimer = 0;
                     enemy.attackTimer -= deltaTime;
                     if (enemy.attackTimer <= 0) { enemy.aiState = 'chasing'; enemy.attackTimer = undefined; }
                     if (enemy.target) { // Keep facing player
                        const dirToPlayerAttackPersist = subtractVectors([playerPos.x, 0, playerPos.z], [enemyPos.x, 0, enemyPos.z]);
                        enemy.rotation.y = Math.atan2(dirToPlayerAttackPersist[0], dirToPlayerAttackPersist[2]);
                     }
                     enemy.velocity.x = 0; enemy.velocity.z = 0; // Ensure no movement
                     break;
             }

            // Physics Update
             enemy.velocity.y -= config.gravity; // Apply gravity
             let nextPos = { // Calculate next position based on velocity
                 x: enemyPos.x + enemy.velocity.x * deltaTime,
                 y: enemyPos.y + enemy.velocity.y * deltaTime,
                 z: enemyPos.z + enemy.velocity.z * deltaTime
             };
             const terrainHeight = getTerrainHeight(nextPos.x, nextPos.z); // Check terrain at next XZ
             const groundY = terrainHeight; // Assume feet at ground
             if (nextPos.y < groundY && enemy.velocity.y <= 0) { // Vertical collision
                 enemy.position.y = groundY; enemy.velocity.y = 0;
             } else { enemy.position.y = nextPos.y; }

             // Horizontal collision (simple step check)
             const forwardCheckDist = 0.5; const stepHeight = 0.5;
             let moveDir = [enemy.velocity.x, 0, enemy.velocity.z]; const moveLen = length(moveDir);
             let collisionDetected = false;
             if (moveLen > 0.01) {
                 moveDir = scaleVector(moveDir, 1.0 / moveLen); // Normalize
                 const heightAhead = getTerrainHeight(enemyPos.x + moveDir[0] * forwardCheckDist, enemyPos.z + moveDir[2] * forwardCheckDist);
                 if (heightAhead > enemy.position.y + stepHeight) { // Check against current Y + step
                     enemy.velocity.x = 0; enemy.velocity.z = 0; collisionDetected = true;
                 }
             }
             if (!collisionDetected) { // Apply horizontal movement if no collision
                 enemy.position.x = nextPos.x; enemy.position.z = nextPos.z;
             }
        }

        // ----------------------------------------------
        // Building System (Readable)
        // ----------------------------------------------

        function updateBuildMode() {
            const equipped = getEquippedItem();
            if (!equipped || items[equipped.id]?.action !== 'build') {
                if (game.player.buildMode) { game.player.buildMode = false; game.player.buildTarget = null; }
                return;
            }
            game.player.buildMode = true;
            if (!game.player.buildPiece) game.player.buildPiece = buildings[1]?.id || buildings[0]?.id; // Default piece
            if (!game.player.buildPiece) return; // No build pieces defined?

             const range = 8; const origin = game.camera.position; const direction = getCameraDirection();
             let placementPos = null; let placementNormal = [0,1,0]; let hit = false;
             let currentPos = {...origin};
             for(let d = 0; d < range; d += 0.2) { // Raycast step
                 currentPos.x += direction[0] * 0.2; currentPos.y += direction[1] * 0.2; currentPos.z += direction[2] * 0.2;
                 const terrainHeight = getTerrainHeight(currentPos.x, currentPos.z);
                 if (currentPos.y <= terrainHeight + 0.1) { // Hit ground
                      placementPos = {x: currentPos.x, y: terrainHeight, z: currentPos.z};
                      const sd = 0.1; // Normal sample distance
                      const nx = getTerrainHeight(currentPos.x + sd, currentPos.z) - getTerrainHeight(currentPos.x - sd, currentPos.z);
                      const nz = getTerrainHeight(currentPos.x, currentPos.z + sd) - getTerrainHeight(currentPos.x, currentPos.z - sd);
                      placementNormal = normalize([-nx, sd * 2, -nz]);
                      hit = true; break;
                 }
                 // TODO: Raycast against existing buildings/entities
             }

             if (hit) {
                 const snapGrid = 1.0; const heightSnap = 0.25; const rotationSnap = Math.PI / 4; // 45 deg
                 const snappedPos = { x: Math.round(placementPos.x / snapGrid) * snapGrid, y: Math.round(placementPos.y / heightSnap) * heightSnap, z: Math.round(placementPos.z / snapGrid) * snapGrid };
                 const snappedRotation = { x: 0, y: Math.round(game.player.rotation.y / rotationSnap) * rotationSnap, z: 0 }; // TODO: Align with normal?
                 const buildDef = buildings.find(b => b.id === game.player.buildPiece);
                 if (!buildDef) { game.player.buildTarget = null; return; }
                 const matsAvailable = hasMaterials(buildDef);
                 const nearStation = !buildDef.requireWorkbench || isNearCraftingStation('workbench');
                 const isValid = matsAvailable && nearStation; // TODO: Add collision check
                 game.player.buildTarget = { position: snappedPos, rotation: snappedRotation, normal: placementNormal, pieceId: game.player.buildPiece, valid: isValid };
             } else game.player.buildTarget = null;
        }

        function placeBuilding() {
             if (!game.player.buildMode || !game.player.buildTarget?.valid) return;
             const target = game.player.buildTarget; const buildDef = buildings.find(b => b.id === target.pieceId);
             if (!buildDef) return;
             if (hasMaterials(buildDef)) {
                 if (consumeBuildingMaterials(buildDef.materials)) { // Use global helper
                    const newBuilding = {
                         id: `build_${target.pieceId}_${Date.now()}_${Math.random().toString(16).slice(2)}`, type: target.pieceId,
                         model: buildDef.model || 'cube', color: buildDef.color || [0.6, 0.4, 0.2, 1.0],
                         position: { ...target.position }, rotation: { ...target.rotation }, scale: { x: 1, y: 1, z: 1 },
                         health: 100, isBuilding: true,
                         isOpen: buildDef.id === 'door_wood' ? false : undefined,
                     };
                     game.world.builtObjects.push(newBuilding);
                     // console.log("Placed building:", target.pieceId);
                     // TODO: Sound/Visual effects
                 } else console.error("Failed to consume building materials.");
             } else console.log("Not enough materials (final check).");
        }

        function consumeBuildingMaterials(materials) { // Global helper
             if (!materials) return true;
             // Check *all* materials first before consuming any
             if (!hasMaterials({ materials: materials })) return false;
             // Now consume them (assuming check passed)
             return materials.every(mat => consumeMaterials(mat.item, mat.count)); // Use the inventory consume helper
        }

        // ----------------------------------------------
        // Rendering (Readable)
        // ----------------------------------------------

         function renderWorld(projectionMatrix, viewMatrix) {
             const { chunkSize, renderDistance } = config;
             const playerChunkX = Math.floor(game.player.position.x / chunkSize);
             const playerChunkZ = Math.floor(game.player.position.z / chunkSize);
             const chunksToRender = [];
             for (let cz = playerChunkZ - renderDistance; cz <= playerChunkZ + renderDistance; cz++) {
                 for (let cx = playerChunkX - renderDistance; cx <= playerChunkX + renderDistance; cx++) {
                     const chunk = game.world.chunks[getChunkKey(cx, cz)]; if (chunk) chunksToRender.push(chunk);
                 }
             }

             // 1. Terrain
             const terrainProg = game.webgl.programs.terrain; gl.useProgram(terrainProg.program);
             gl.uniformMatrix4fv(terrainProg.locations.uniforms.u_projectionMatrix, false, projectionMatrix);
             gl.uniformMatrix4fv(terrainProg.locations.uniforms.u_viewMatrix, false, viewMatrix);
             setCommonUniforms(terrainProg.locations.uniforms);
             chunksToRender.forEach(chunk => {
                 if (chunk.terrainMesh?.buffers) {
                      const modelMatrix = mat4.translation(chunk.x * chunkSize, 0, chunk.z * chunkSize);
                      gl.uniformMatrix4fv(terrainProg.locations.uniforms.u_modelMatrix, false, modelMatrix);
                      bindVertexArrayObject(gl, chunk.terrainMesh.buffers.vao);
                      setupAttributes(gl, terrainProg.locations, chunk.terrainMesh.buffers);
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.terrainMesh.buffers.indices); // Bind indices
                      gl.drawElements(gl.TRIANGLES, chunk.terrainMesh.numElements, gl.UNSIGNED_SHORT, 0);
                 }
             });
             bindVertexArrayObject(gl, null);

             // 2. Entities & Built Objects
             const entityProg = game.webgl.programs.basic; gl.useProgram(entityProg.program);
             gl.uniformMatrix4fv(entityProg.locations.uniforms.u_projectionMatrix, false, projectionMatrix);
             gl.uniformMatrix4fv(entityProg.locations.uniforms.u_viewMatrix, false, viewMatrix);
             setCommonUniforms(entityProg.locations.uniforms); // Set common uniforms for this program
             const entitiesToRender = [];
             chunksToRender.forEach(chunk => { if(chunk.entities) entitiesToRender.push(...chunk.entities); }); // Chunk local (trees, rocks)
             const maxDistRenderSq = (renderDistance * chunkSize + chunkSize) ** 2;
             game.world.entities.forEach(e => { if (e?.position && distanceSquared(game.player.position, e.position) < maxDistRenderSq) entitiesToRender.push(e); }); // Global (enemies, drops)
             game.world.builtObjects.forEach(b => { if (b?.position && distanceSquared(game.player.position, b.position) < maxDistRenderSq) entitiesToRender.push(b); }); // Built objects

             entitiesToRender.forEach(entity => {
                 if (!entity?.model || !entity.position || !entity.rotation || !entity.scale) return;
                 let meshData = game.webgl.meshes[entity.model] || game.webgl.meshes.cube; // Use defined model or fallback
                 if (!meshData?.buffers) return; // Skip if mesh/buffers failed
                 let rotY = entity.rotation.y;
                 if (entity.type === 'door_wood' && entity.isOpen) rotY += Math.PI / 2; // Simple door open rotation
                 const modelMatrix = mat4.transform(entity.position.x, entity.position.y, entity.position.z, entity.rotation.x, rotY, entity.rotation.z, entity.scale.x, entity.scale.y, entity.scale.z);
                 gl.uniformMatrix4fv(entityProg.locations.uniforms.u_modelMatrix, false, modelMatrix);
                 gl.uniform4fv(entityProg.locations.uniforms.u_color, entity.color || [1.0, 0.0, 1.0, 1.0]);
                 gl.uniform1f(entityProg.locations.uniforms.u_swayFactor, entity.sway || 0.0);
                 bindVertexArrayObject(gl, meshData.buffers.vao);
                 setupAttributes(gl, entityProg.locations, meshData.buffers);
                 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshData.buffers.indices); // Bind indices
                 gl.drawElements(gl.TRIANGLES, meshData.numElements, gl.UNSIGNED_SHORT, 0);
             });
             bindVertexArrayObject(gl, null);

             // 3. Build Preview (Transparent)
             if (game.player.buildMode && game.player.buildTarget) {
                 const target = game.player.buildTarget; const buildDef = buildings.find(b => b.id === target.pieceId);
                 if (buildDef) {
                      let meshData = game.webgl.meshes[buildDef.model || 'cube'];
                      if (meshData?.buffers) {
                            gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.depthMask(false); // Enable transparency
                            gl.useProgram(entityProg.program); // Ensure basic program is active
                            const modelMatrix = mat4.transform(target.position.x, target.position.y, target.position.z, target.rotation.x, target.rotation.y, target.rotation.z, 1, 1, 1);
                             const color = target.valid ? [0.0, 1.0, 0.0, 0.5] : [1.0, 0.0, 0.0, 0.5];
                             gl.uniformMatrix4fv(entityProg.locations.uniforms.u_modelMatrix, false, modelMatrix);
                             gl.uniform4fv(entityProg.locations.uniforms.u_color, color);
                             gl.uniform1f(entityProg.locations.uniforms.u_swayFactor, 0.0); // No sway
                             bindVertexArrayObject(gl, meshData.buffers.vao);
                             setupAttributes(gl, entityProg.locations, meshData.buffers);
                             gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshData.buffers.indices); // Bind indices
                             gl.drawElements(gl.TRIANGLES, meshData.numElements, gl.UNSIGNED_SHORT, 0);
                             gl.depthMask(true); gl.disable(gl.BLEND); // Restore defaults
                             bindVertexArrayObject(gl, null);
                      }
                 }
             }

             // 4. Water (Transparent)
             const waterProg = game.webgl.programs.water; gl.useProgram(waterProg.program);
             gl.uniformMatrix4fv(waterProg.locations.uniforms.u_projectionMatrix, false, projectionMatrix);
             gl.uniformMatrix4fv(waterProg.locations.uniforms.u_viewMatrix, false, viewMatrix);
             setCommonUniforms(waterProg.locations.uniforms); // Set common uniforms for this program
             gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.depthMask(false); // Enable transparency
             chunksToRender.forEach(chunk => {
                 if (chunk.waterMesh?.buffers) {
                     const modelMatrix = mat4.translation(chunk.x * chunkSize, 0, chunk.z * chunkSize);
                     gl.uniformMatrix4fv(waterProg.locations.uniforms.u_modelMatrix, false, modelMatrix);
                     bindVertexArrayObject(gl, chunk.waterMesh.buffers.vao);
                     setupAttributes(gl, waterProg.locations, chunk.waterMesh.buffers);
                     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.waterMesh.buffers.indices); // Bind indices
                     gl.drawElements(gl.TRIANGLES, chunk.waterMesh.numElements, gl.UNSIGNED_SHORT, 0);
                 }
             });
             gl.depthMask(true); gl.disable(gl.BLEND); // Restore defaults
             bindVertexArrayObject(gl, null);
         }

         function renderSkybox(projectionMatrix, viewMatrix) {
            const skyProg = game.webgl.programs.skybox; const skyMesh = game.webgl.meshes.cube;
             if (!skyProg || !skyMesh?.buffers) return;
             gl.useProgram(skyProg.program);
             const viewRotationMatrix = mat4.identity(); // Remove translation
             viewRotationMatrix[0]=viewMatrix[0]; viewRotationMatrix[1]=viewMatrix[1]; viewRotationMatrix[2]=viewMatrix[2];
             viewRotationMatrix[4]=viewMatrix[4]; viewRotationMatrix[5]=viewMatrix[5]; viewRotationMatrix[6]=viewMatrix[6];
             viewRotationMatrix[8]=viewMatrix[8]; viewRotationMatrix[9]=viewMatrix[9]; viewRotationMatrix[10]=viewMatrix[10];
             gl.uniformMatrix4fv(skyProg.locations.uniforms.u_viewMatrix, false, viewRotationMatrix);
             gl.uniformMatrix4fv(skyProg.locations.uniforms.u_projectionMatrix, false, projectionMatrix);
             gl.uniform1f(skyProg.locations.uniforms.u_time, game.currentTime);
             gl.uniform1f(skyProg.locations.uniforms.u_dayTime, game.dayTime);
             gl.depthFunc(gl.LEQUAL); gl.disable(gl.CULL_FACE); // Draw behind, disable culling
             bindVertexArrayObject(gl, skyMesh.buffers.vao);
             setupAttributes(gl, skyProg.locations, skyMesh.buffers);
             gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, skyMesh.buffers.indices); // Bind indices
             gl.drawElements(gl.TRIANGLES, skyMesh.numElements, gl.UNSIGNED_SHORT, 0);
             gl.enable(gl.CULL_FACE); gl.depthFunc(gl.LESS); // Restore defaults
             bindVertexArrayObject(gl, null);
         }

         function renderMinimap() {
            const mapSize = minimapCanvas.width; const mapHeight = minimapCanvas.height;
            const scale = 0.5; const playerX = game.player.position.x; const playerZ = game.player.position.z;
            minimapCtx.fillStyle = '#1a2a1a'; minimapCtx.fillRect(0, 0, mapSize, mapHeight);
            minimapCtx.save();
            minimapCtx.translate(mapSize / 2, mapHeight / 2); minimapCtx.rotate(-game.player.rotation.y); minimapCtx.translate(-playerX * scale, -playerZ * scale); // Center and rotate
            const renderDistUnits = 75; const step = 4; // Draw terrain
            for(let z = playerZ - renderDistUnits; z < playerZ + renderDistUnits; z+= step) {
                for(let x = playerX - renderDistUnits; x < playerX + renderDistUnits; x+= step) {
                    const height = getTerrainHeight(x, z); let color = '#3a5a3a';
                    if (height < 1.0) color = '#5a7a9a'; else if (height > 15) color = '#aaaaaa';
                    minimapCtx.fillStyle = color; minimapCtx.fillRect(x * scale, z * scale, step * scale, step * scale);
                }
             }
             const checkDistSq = renderDistUnits**2; // Draw entities
             const entitiesNearby = [];
             game.world.entities.forEach(e => { if(e?.position && distanceSquared(e.position, game.player.position) < checkDistSq) entitiesNearby.push(e); });
             game.world.builtObjects.forEach(b => { if(b?.position && distanceSquared(b.position, game.player.position) < checkDistSq) entitiesNearby.push(b); });
             // Add chunk entities (trees/rocks) if desired
             entitiesNearby.forEach(e => {
                 if (!e?.position) return; let color = '#ffffff'; let size = 2;
                 if (e.type === 'enemy') { color = '#ff4444'; size = 3; }
                 else if (e.type === 'item_drop') { color = '#ffff88'; size = 2; }
                 else if (e.isBuilding) { color = '#cc8844'; size = 2; }
                 minimapCtx.fillStyle = color; minimapCtx.fillRect(e.position.x * scale - size / 2, e.position.z * scale - size / 2, size, size);
             });
             minimapCtx.restore(); // Restore transform for player icon/north
            minimapCtx.fillStyle = '#ffffff'; minimapCtx.beginPath(); // Player icon
            minimapCtx.moveTo(mapSize / 2, mapHeight / 2 - 5); minimapCtx.lineTo(mapSize / 2 - 4, mapHeight / 2 + 4); minimapCtx.lineTo(mapSize / 2 + 4, mapHeight / 2 + 4);
            minimapCtx.closePath(); minimapCtx.fill();
            minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)'; minimapCtx.lineWidth = 1; // North indicator
            minimapCtx.beginPath(); minimapCtx.moveTo(mapSize - 10, 10); minimapCtx.lineTo(mapSize - 10, 20); minimapCtx.stroke();
            minimapCtx.fillStyle = 'rgba(255,255,255,0.7)'; minimapCtx.font = '10px Arial'; minimapCtx.fillText('N', mapSize - 13, 8);
         }

         function setCommonUniforms(uniformLocations) {
             const { u_viewPosition, u_lightDirection, u_time, u_fogColor, u_fogDistance, u_ambientLight } = uniformLocations;
             if (u_viewPosition) gl.uniform3fv(u_viewPosition, [game.camera.position.x, game.camera.position.y, game.camera.position.z]);
             const dayPhase = game.dayTime * Math.PI * 2; const lightDir = normalize([ Math.sin(dayPhase), Math.cos(dayPhase) * 0.8 + 0.2, 0.3 ]);
             if (u_lightDirection) gl.uniform3fv(u_lightDirection, lightDir);
             const sunElevation = Math.max(0, lightDir[1]); const ambient = 0.15 + sunElevation * 0.35;
             if (u_ambientLight) gl.uniform1f(u_ambientLight, ambient);
             const fogColor = mixColors([0.05, 0.05, 0.1], [0.5, 0.6, 0.7], ambient / 0.5);
             if (u_fogColor) gl.uniform3fv(u_fogColor, fogColor);
             if (u_time) gl.uniform1f(u_time, game.currentTime);
             if (u_fogDistance) gl.uniform1f(u_fogDistance, config.fogDistance);
         }

                  function mixColors(colorA, colorB, t) {
            t = Math.max(0, Math.min(1, t)); // Clamp t between 0 and 1
            return [
                colorA[0] * (1 - t) + colorB[0] * t, // FIX: Use colorB
                colorA[1] * (1 - t) + colorB[1] * t, // FIX: Use colorB
                colorA[2] * (1 - t) + colorB[2] * t  // FIX: Use colorB
            ];
          }

         function resizeCanvas() {
            const width = window.innerWidth; const height = window.innerHeight;
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width; canvas.height = height; gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                // console.log(`Resized canvas to ${width}x${height}`);
            }
            const mapSize = Math.min(150, width * 0.15, height * 0.15);
             if (minimapCanvas.width !== mapSize || minimapCanvas.height !== mapSize) {
                minimapCanvas.width = mapSize; minimapCanvas.height = mapSize;
                document.getElementById('minimap').style.width = `${mapSize}px`; document.getElementById('minimap').style.height = `${mapSize}px`;
             }
        }

         function render() {
            if (!game.started || !gl || gl.isContextLost()) return;
            resizeCanvas();
            gl.enable(gl.DEPTH_TEST); gl.enable(gl.CULL_FACE); gl.cullFace(gl.BACK);
            gl.clearColor(0.1, 0.1, 0.15, 1.0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
             const aspect = canvas.clientWidth / canvas.clientHeight;
             const projectionMatrix = mat4.perspective(game.camera.fov, aspect, 0.1, config.fogDistance * 1.5);
             const viewMatrix = mat4.cameraView(game.camera.position, game.camera.rotation.x, game.camera.rotation.y);
             renderSkybox(projectionMatrix, viewMatrix);
             renderWorld(projectionMatrix, viewMatrix);
             renderMinimap();
         }


        // ----------------------------------------------
        // UI Updates (Readable)
        // ----------------------------------------------
        function updateUI(deltaTime) {
             healthBarFill.style.width = `${Math.max(0, game.player.health / game.player.maxHealth) * 100}%`;
             staminaBarFill.style.width = `${Math.max(0, game.player.stamina / game.player.maxStamina) * 100}%`;
             foodBarFill.style.width = `${Math.max(0, game.player.food / game.player.maxFood) * 100}%`;
             debugInfo.textContent = `
Pos: ${game.player.position.x.toFixed(1)}, ${game.player.position.y.toFixed(1)}, ${game.player.position.z.toFixed(1)} Rot: ${game.player.rotation.y.toFixed(2)}, ${game.player.rotation.x.toFixed(2)}
Vel: ${game.player.velocity.x.toFixed(2)}, ${game.player.velocity.y.toFixed(2)}, ${game.player.velocity.z.toFixed(2)} State: ${game.player.state} ${game.player.onGround?'G':'A'} ${game.paused?'PAUSED':''} ${game.isDead?'DEAD':''}
Time: ${game.dayTime.toFixed(2)} (${(game.dayTime * 24).toFixed(1)}h) Ent: ${game.world.entities.length + game.world.builtObjects.length} Chk: ${Object.keys(game.world.chunks).length} FPS: ${(1 / deltaTime).toFixed(0)}
Intr: ${game.player.interactionTarget?.id || game.player.interactionTarget?.type || 'N/A'} Build: ${game.player.buildMode?'On':'Off'} Targ: ${game.player.buildTarget?.valid?'V':'Inv'}
`.trim();
             if (!game.showInventory && !game.paused && !game.isDead) updateInteractionPrompt();
             else { interactionPrompt.style.display = 'none'; game.player.interactionTarget = null; }
        }

        // ----------------------------------------------
        // Game Loop and Initialization (Readable)
        // ----------------------------------------------

        function update(deltaTime) {
             if (game.isDead) { updateUI(deltaTime); return; }
             if (game.paused) { updateUI(deltaTime); return; } // Only UI updates when paused

             game.currentTime += deltaTime; game.dayTime = (game.currentTime / config.dayNightCycle) % 1.0;
             updateInput(deltaTime); // Handle movement/look/action input
             loadRequiredChunks(); unloadDistantChunks(); // Manage world chunks

             // Update global entities (enemies, drops)
             game.world.entities.forEach((entity, index) => { // Use index for potential removal
                 if (!entity) return; // Skip if already removed
                 if (entity.type === 'enemy') updateEnemyAI(entity, deltaTime);
                 else if (entity.type === 'item_drop') {
                    entity.velocity = entity.velocity || {x:0, y:0, z:0}; entity.velocity.y -= config.gravity * 0.5;
                    const nextY = entity.position.y + entity.velocity.y * deltaTime;
                    const groundY = getTerrainHeight(entity.position.x, entity.position.z) + 0.1;
                     if (nextY <= groundY && entity.velocity.y <=0) { entity.position.y = groundY; entity.velocity.y = 0; entity.velocity.x *= 0.8; entity.velocity.z *= 0.8; }
                     else { entity.position.y = nextY; }
                    entity.position.x += entity.velocity.x * deltaTime; entity.position.z += entity.velocity.z * deltaTime;
                    if (game.currentTime > (entity.creationTime + entity.despawnTime)) game.world.entities.splice(index, 1); // Despawn
                }
             });
             // Filter out null entries from splicing during iteration (less efficient but safer)
             game.world.entities = game.world.entities.filter(e => e !== null);


             // Update chunk-local entities (trees, rocks) - TODO (e.g., check health for destruction)

             // Update built objects - TODO (e.g., decay, fire spread?)

             updatePlayerPhysics(deltaTime); // Update player movement/collision
             updateBuildMode(); // Update build preview state
             updateCamera(); // Update camera position/collision
             updateUI(deltaTime); // Update HUD, debug info etc.
        }

        function gameLoop(timestamp) {
            if (!game.started || !gl || gl.isContextLost()) {
                 console.error("Game loop stopped.", { started: game.started, gl: !!gl, contextLost: gl?.isContextLost() });
                 return;
            }
            game.deltaTime = Math.min(0.1, Math.max(0.001, (timestamp - game.lastFrameTime) / 1000));
            game.lastFrameTime = timestamp;
            try {
                update(game.deltaTime);
                render();
            } catch (error) {
                 console.error("Error in game loop:", error); game.started = false;
                 alert("A critical error occurred. Check console.\n" + error.message); return;
            }
            requestAnimationFrame(gameLoop);
        }

        function mulberry32(a) { // Simple seeded PRNG
             return function() { a |= 0; a = a + 0x6D2B79F5 | 0; var t = Math.imul(a ^ a >>> 15, 1 | a); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; }
         }

        function initWebGL() {
            console.log("Initializing WebGL...");
            const progs = game.webgl.programs; const meshes = game.webgl.meshes;
            progs.basic = { program: createShaderProgram(gl, vertexShaderSource, basicFragmentShaderSource), locations: null };
            progs.terrain = { program: createShaderProgram(gl, vertexShaderSource, terrainFragmentShaderSource), locations: null };
            progs.water = { program: createShaderProgram(gl, vertexShaderSource, waterFragmentShaderSource), locations: null };
            progs.skybox = { program: createShaderProgram(gl, skyboxVertexShaderSource, skyboxFragmentShaderSource), locations: null };
            if (!progs.basic?.program || !progs.terrain?.program || !progs.water?.program || !progs.skybox?.program) throw new Error("Failed to create shader programs.");

            progs.basic.locations = getAttribUniformLocations(gl, progs.basic.program, ['a_position', 'a_normal', 'a_texcoord'], ['u_modelMatrix', 'u_viewMatrix', 'u_projectionMatrix', 'u_color', 'u_viewPosition', 'u_lightDirection', 'u_time', 'u_fogColor', 'u_fogDistance', 'u_ambientLight', 'u_swayFactor']);
            progs.terrain.locations = getAttribUniformLocations(gl, progs.terrain.program, ['a_position', 'a_normal', 'a_texcoord'], ['u_modelMatrix', 'u_viewMatrix', 'u_projectionMatrix', 'u_viewPosition', 'u_lightDirection', 'u_time', 'u_fogColor', 'u_fogDistance', 'u_ambientLight']);
            progs.water.locations = getAttribUniformLocations(gl, progs.water.program, ['a_position', 'a_normal', 'a_texcoord'], ['u_modelMatrix', 'u_viewMatrix', 'u_projectionMatrix', 'u_viewPosition', 'u_lightDirection', 'u_time', 'u_fogColor', 'u_fogDistance', 'u_ambientLight']);
            progs.skybox.locations = getAttribUniformLocations(gl, progs.skybox.program, ['a_position'], ['u_viewMatrix', 'u_projectionMatrix', 'u_time', 'u_dayTime']);

            meshes.cube = createUnitCubeMesh(gl); meshes.sphere = createSphereMesh(gl); meshes.cylinder = createCylinderMesh(gl, 0.3, 0.3, 1, 12); meshes.tree = createCylinderMesh(gl, 0.0, 0.6, 2.5, 8); // Cone
            createMeshBuffers(gl, meshes.cube); createMeshBuffers(gl, meshes.sphere); createMeshBuffers(gl, meshes.cylinder); createMeshBuffers(gl, meshes.tree);
            // TODO: Create/load specific building meshes
            console.log("WebGL Initialized.");
        }

         function startGame() {
             console.log("Starting game...");
             menuScreen.style.display = 'none'; loadingScreen.style.display = 'flex';
             let progress = 0;
             const loadingInterval = setInterval(() => {
                 progress += 10; loadingProgress.style.width = `${progress}%`;
                 if (progress >= 100) {
                     clearInterval(loadingInterval);
                     try {
                         initWebGL(); setupInputListeners();
                         console.log("Generating initial chunks..."); loadRequiredChunks(); console.log("Initial chunks generated.");
                         addItemToInventory('axe_stone', 1); addItemToInventory('hammer', 1); addItemToInventory('berries', 5);
                         game.player.hotbar[0] = 0; game.player.hotbar[1] = 1; updateHotbarUI(); // Assign starting items to hotbar
                         loadingScreen.style.display = 'none'; canvas.style.display = 'block';
                         game.started = true; game.paused = false; game.isDead = false; game.lastFrameTime = performance.now();
                         canvas.requestPointerLock();
                         console.log("Starting game loop..."); requestAnimationFrame(gameLoop);
                     } catch (error) {
                         console.error("Error during game initialization:", error);
                         loadingScreen.innerHTML = `<h2>Initialization Error</h2><p>${error.message}. Check console.</p>`;
                     }
                 }
             }, 150);
         }


        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);
        document.getElementById('start-game').addEventListener('click', startGame);
        document.getElementById('respawn').addEventListener('click', respawnPlayer);

        // --- Initial Setup ---
        resizeCanvas();
        loadingScreen.style.display = 'none';
        menuScreen.style.display = 'flex';

    </script>
</body>
</html>