<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valheim Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #loading img {
            width: 200px;
            margin-bottom: 20px;
        }
        .progress-bar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #5d8834;
            width: 0%;
            transition: width 0.5s;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            pointer-events: none;
        }
        #health-bar, #stamina-bar, #food-bar {
            height: 20px;
            margin-right: 10px;
            border-radius: 5px;
            overflow: hidden;
            flex: 1;
        }
        #health-bar .fill {
            background: #c93636;
            height: 100%;
            width: 100%;
        }
        #stamina-bar .fill {
            background: #3665c9;
            height: 100%;
            width: 100%;
        }
        #food-bar .fill {
            background: #c9a336;
            height: 100%;
            width: 100%;
        }
        #inventory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 400px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #5d8834;
            color: #fff;
            padding: 20px;
            display: none;
            pointer-events: auto;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .inventory-slot {
            width: 60px;
            height: 60px;
            background: #333;
            border: 1px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            position: relative;
            cursor: pointer;
        }
        .inventory-slot img {
            max-width: 80%;
            max-height: 80%;
        }
        .inventory-slot .count {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 3px;
        }
        #hotbar {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            pointer-events: none;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, a0, 0, 0.5);
            border: 1px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hotbar-slot.active {
            border: 2px solid #fff;
        }
        #crafting {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
            pointer-events: auto;
        }
        .crafting-item {
            margin: 10px 0;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
        }
        .crafting-item:hover {
            background: #333;
        }
        #interaction {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 16px;
            text-shadow: 1px 1px 2px #000;
            display: none;
        }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            pointer-events: none;
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #5d8834;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }
        .crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        .crosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.9)), url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAASElEQVQoU2NkIBIwEqmOgSEDvvbNm/8NEf7///+PRSEjVBF2k9DV/f//H6gBbjJU4X+8ChkZGbGbDHT9f2ZmJoKK0BVitw4ArNcfGx5yiRsAAAAASUVORK5CYII=') repeat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 1000;
        }
        #menu h1 {
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #5d8834;
            letter-spacing: 4px;
        }
        .menu-button {
            background: rgba(93, 136, 52, 0.7);
            border: none;
            color: #fff;
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            width: 200px;
            text-align: center;
        }
        .menu-button:hover {
            background: rgba(93, 136, 52, 1);
            transform: scale(1.05);
        }
        #death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #c93636;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
        #death-screen h2 {
            font-size: 72px;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h1>VALHEIM CLONE</h1>
        <p>Loading world...</p>
        <div class="progress-bar">
            <div class="progress-fill" id="loading-progress"></div>
        </div>
    </div>
    
    <div id="menu">
        <h1>VALHEIM CLONE</h1>
        <button class="menu-button" id="start-game">Start Game</button>
        <button class="menu-button" id="options">Options</button>
        <p style="margin-top: 50px; font-size: 12px; opacity: 0.7;">HTML5 Adaptation - Use WASD to move, E to interact, TAB for inventory</p>
    </div>
    
    <div id="death-screen">
        <h2>YOU DIED</h2>
        <p>Odin is disappointed</p>
        <button class="menu-button" id="respawn">Respawn</button>
    </div>
    
    <canvas id="game-canvas"></canvas>
    
    <div id="ui">
        <div id="health-bar"><div class="fill"></div></div>
        <div id="stamina-bar"><div class="fill"></div></div>
        <div id="food-bar"><div class="fill"></div></div>
    </div>
    
    <div id="hotbar">
        <div class="hotbar-slot active"></div>
        <div class="hotbar-slot"></div>
        <div class="hotbar-slot"></div>
        <div class="hotbar-slot"></div>
        <div class="hotbar-slot"></div>
        <div class="hotbar-slot"></div>
        <div class="hotbar-slot"></div>
        <div class="hotbar-slot"></div>
    </div>
    
    <div id="interaction">Press E to interact</div>
    
    <div id="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <div class="crosshair"></div>
    
    <div id="debug"></div>
    
    <div id="inventory">
        <h3>Inventory</h3>
        <div class="inventory-grid">
            <!-- Inventory slots will be generated by JS -->
        </div>
    </div>
    
    <div id="crafting">
        <h3>Crafting</h3>
        <div class="crafting-list">
            <!-- Crafting items will be generated by JS -->
        </div>
    </div>
    
    <script>
        // Game Configuration
        const config = {
            worldSize: 1000,
            chunkSize: 16,
            renderDistance: 4,
            treeDensity: 0.01,
            rockDensity: 0.008,
            enemyDensity: 0.002,
            gravity: 0.01,
            dayNightCycle: 1200, // seconds per day
            playerSpeed: 0.1,
            playerRunSpeed: 0.2,
            jumpForce: 0.2,
            collisionPrecision: 0.1,
            interactionDistance: 3
        };
        
        // Game state
        const game = {
            started: false,
            paused: false,
            currentTime: 0,
            dayTime: 0,
            weather: 'clear',
            player: {
                position: { x: 0, y: 2, z: 0 },
                rotation: { x: 0, y: 0 },
                velocity: { x: 0, y: 0, z: 0 },
                onGround: false,
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                food: 100,
                maxFood: 100,
                inventory: [],
                equippedItem: null,
                state: 'idle', // idle, walking, running, attacking
                hotbar: Array(8).fill(null)
            },
            world: {
                seed: Math.floor(Math.random() * 1000000),
                chunks: {},
                entities: [],
                interactable: []
            },
            camera: {
                position: { x: 0, y: 0, z: 0 },
                rotation: { x: 0, y: 0 },
                fov: 75
            },
            input: {
                keys: {},
                mouse: { x: 0, y: 0, down: false },
                pointer: { locked: false }
            },
            lastFrameTime: 0,
            deltaTime: 0
        };
        
        // Item definitions
        const items = {
            wood: { name: "Wood", type: "resource", icon: "🪵", stackable: true, maxStack: 50 },
            stone: { name: "Stone", type: "resource", icon: "🪨", stackable: true, maxStack: 50 },
            flint: { name: "Flint", type: "resource", icon: "💎", stackable: true, maxStack: 30 },
            leather: { name: "Leather", type: "resource", icon: "🧶", stackable: true, maxStack: 20 },
            meat: { name: "Meat", type: "food", icon: "🥩", stackable: true, maxStack: 10, food: 20, health: 5 },
            berries: { name: "Berries", type: "food", icon: "🍇", stackable: true, maxStack: 20, food: 10, health: 2 },
            hammer: { name: "Hammer", type: "tool", icon: "🔨", stackable: false, durability: 100 },
            axe: { name: "Stone Axe", type: "weapon", icon: "🪓", stackable: false, damage: 15, durability: 100 },
            club: { name: "Wooden Club", type: "weapon", icon: "🏑", stackable: false, damage: 8, durability: 50 },
            shield: { name: "Wooden Shield", type: "shield", icon: "🛡️", stackable: false, block: 10, durability: 75 }
        };
        
        // Crafting recipes
        const recipes = [
            { id: "axe", name: "Stone Axe", materials: [{ item: "wood", count: 5 }, { item: "stone", count: 3 }], result: "axe" },
            { id: "club", name: "Wooden Club", materials: [{ item: "wood", count: 3 }], result: "club" },
            { id: "hammer", name: "Hammer", materials: [{ item: "wood", count: 3 }, { item: "stone", count: 2 }], result: "hammer" },
            { id: "shield", name: "Wooden Shield", materials: [{ item: "wood", count: 8 }], result: "shield" }
        ];
        
        // Building pieces
        const buildings = [
            { id: "floor", name: "Wooden Floor", materials: [{ item: "wood", count: 2 }], requireWorkbench: false },
            { id: "wall", name: "Wooden Wall", materials: [{ item: "wood", count: 3 }], requireWorkbench: false },
            { id: "roof", name: "Wooden Roof", materials: [{ item: "wood", count: 2 }], requireWorkbench: false },
            { id: "door", name: "Wooden Door", materials: [{ item: "wood", count: 4 }], requireWorkbench: true },
            { id: "workbench", name: "Workbench", materials: [{ item: "wood", count: 10 }], requireWorkbench: false }
        ];
        
        // Enemy types
        const enemyTypes = [
            { id: "greydwarf", name: "Greydwarf", health: 30, damage: 8, speed: 0.05, model: "greydwarf" },
            { id: "skeleton", name: "Skeleton", health: 40, damage: 12, speed: 0.04, model: "skeleton" },
            { id: "troll", name: "Troll", health: 200, damage: 25, speed: 0.03, model: "troll" }
        ];
        
        // Initialize canvas and WebGL context
        const canvas = document.getElementById('game-canvas');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const gl = canvas.getContext('webgl');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        if (!gl) {
            alert('WebGL not supported by your browser!');
            throw new Error('WebGL not supported');
        }
        
        // Resize canvas to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ----------------------------------------------
        // Shader code for our 3D rendering
        // ----------------------------------------------
        
        // Basic vertex shader for 3D rendering
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_normal;
            attribute vec2 a_texcoord;
            
            uniform mat4 u_modelMatrix;
            uniform mat4 u_viewMatrix;
            uniform mat4 u_projectionMatrix;
            
            varying vec3 v_normal;
            varying vec2 v_texcoord;
            varying vec3 v_position;
            
            void main() {
                v_normal = (u_modelMatrix * vec4(a_normal, 0.0)).xyz;
                v_texcoord = a_texcoord;
                v_position = (u_modelMatrix * vec4(a_position, 1.0)).xyz;
                
                gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * vec4(a_position, 1.0);
            }
        `;
        
        // Basic fragment shader for 3D rendering
        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec3 v_normal;
            varying vec2 v_texcoord;
            varying vec3 v_position;
            
            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            uniform vec4 u_color;
            uniform float u_time;
            uniform float u_fogDistance;
            uniform vec3 u_fogColor;
            
            void main() {
                vec3 normal = normalize(v_normal);
                vec3 lightDir = normalize(u_lightDirection);
                float diff = max(dot(normal, lightDir), 0.2);
                
                // Simple ambient + diffuse lighting
                vec3 ambient = 0.3 * u_color.rgb;
                vec3 diffuse = diff * u_color.rgb;
                vec3 color = ambient + diffuse;
                
                // Apply fog
                float fogFactor = clamp(1.0 - length(v_position - u_viewPosition) / u_fogDistance, 0.0, 1.0);
                color = mix(u_fogColor, color, fogFactor);
                
                gl_FragColor = vec4(color, u_color.a);
            }
        `;
        
        // Helper function for creating shader programs
        function createShaderProgram(vertexSource, fragmentSource) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('Vertex shader compilation error:', gl.getShaderInfoLog(vertexShader));
                gl.deleteShader(vertexShader);
                return null;
            }
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('Fragment shader compilation error:', gl.getShaderInfoLog(fragmentShader));
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                return null;
            }
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);
                return null;
            }
            
            return program;
        }
        
        // Create shader programs
        const mainShaderProgram = createShaderProgram(vertexShaderSource, fragmentShaderSource);
        const terrainShaderProgram = createShaderProgram(vertexShaderSource, terrainFragmentShaderSource);
        const waterShaderProgram = createShaderProgram(vertexShaderSource, waterFragmentShaderSource);
        const skyboxShaderProgram = createShaderProgram(vertexShaderSource, skyboxFragmentShaderSource);
        const entityShaderProgram = createShaderProgram(vertexShaderSource, entityFragmentShaderSource);
        
        // ----------------------------------------------
        // 3D Math Helper Functions
        // ----------------------------------------------
        
        // Matrix operations
        const mat4 = {
            identity: function() {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            },
            perspective: function(fovRadians, aspect, near, far) {
                const f = 1.0 / Math.tan(fovRadians / 2);
                const rangeInv = 1 / (near - far);
                
                return [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ];
            },
            translation: function(tx, ty, tz) {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    tx, ty, tz, 1
                ];
            },
            xRotation: function(angleInRadians) {
                const c = Math.cos(angleInRadians);
                const s = Math.sin(angleInRadians);
                
                return [
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ];
            },
            yRotation: function(angleInRadians) {
                const c = Math.cos(angleInRadians);
                const s = Math.sin(angleInRadians);
                
                return [
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ];
            },
            zRotation: function(angleInRadians) {
                const c = Math.cos(angleInRadians);
                const s = Math.sin(angleInRadians);
                
                return [
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            },
            scaling: function(sx, sy, sz) {
                return [
                    sx, 0, 0, 0,
                    0, sy, 0, 0,
                    0, 0, sz, 0,
                    0, 0, 0, 1
                ];
            },
            multiply: function(a, b) {
                const a00 = a[0];
                const a01 = a[1];
                const a02 = a[2];
                const a03 = a[3];
                const a10 = a[4];
                const a11 = a[5];
                const a12 = a[6];
                const a13 = a[7];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];
                const a30 = a[12];
                const a31 = a[13];
                const a32 = a[14];
                const a33 = a[15];
                const b00 = b[0];
                const b01 = b[1];
                const b02 = b[2];
                const b03 = b[3];
                const b10 = b[4];
                const b11 = b[5];
                const b12 = b[6];
                const b13 = b[7];
                const b20 = b[8];
                const b21 = b[9];
                const b22 = b[10];
                const b23 = b[11];
                const b30 = b[12];
                const b31 = b[13];
                const b32 = b[14];
                const b33 = b[15];
                
                return [
                    a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30,
                    a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31,
                    a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32,
                    a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33,
                    a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30,
                    a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31,
                    a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32,
                    a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33,
                    a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30,
                    a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31,
                    a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32,
                    a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33,
                    a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30,
                    a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31,
                    a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32,
                    a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33
                ];
            },
            inverse: function(m) {
                const m00 = m[0];
                const m01 = m[1];
                const m02 = m[2];
                const m03 = m[3];
                const m10 = m[4];
                const m11 = m[5];
                const m12 = m[6];
                const m13 = m[7];
                const m20 = m[8];
                const m21 = m[9];
                const m22 = m[10];
                const m23 = m[11];
                const m30 = m[12];
                const m31 = m[13];
                const m32 = m[14];
                const m33 = m[15];
                
                const tmp_0 = m22 * m33;
                const tmp_1 = m32 * m23;
                const tmp_2 = m12 * m33;
                const tmp_3 = m32 * m13;
                const tmp_4 = m12 * m23;
                const tmp_5 = m22 * m13;
                const tmp_6 = m02 * m33;
                const tmp_7 = m32 * m03;
                const tmp_8 = m02 * m23;
                const tmp_9 = m22 * m03;
                const tmp_10 = m02 * m13;
                const tmp_11 = m12 * m03;
                const tmp_12 = m20 * m31;
                const tmp_13 = m30 * m21;
                const tmp_14 = m10 * m31;
                const tmp_15 = m30 * m11;
                const tmp_16 = m10 * m21;
                const tmp_17 = m20 * m11;
                const tmp_18 = m00 * m31;
                const tmp_19 = m30 * m01;
                const tmp_20 = m00 * m21;
                const tmp_21 = m20 * m01;
                const tmp_22 = m00 * m11;
                const tmp_23 = m10 * m01;
                
                const t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
                          (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
                const t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
                          (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
                const t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
                          (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
                const t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
                          (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
                
                const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
                
                return [
                    d * t0,
                    d * t1,
                    d * t2,
                    d * t3,
                    d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -
                         (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),
                    d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -
                         (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),
                    d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -
                         (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),
                    d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -
                         (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),
                    d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -
                         (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),
                    d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -
                         (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),
                    d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -
                         (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),
                    d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -
                         (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),
                    d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -
                         (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),
                    d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -
                         (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),
                    d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -
                         (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),
                    d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -
                         (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))
                ];
            },
            lookAt: function(eye, target, up) {
                const zAxis = normalize(subtractVectors(eye, target));
                const xAxis = normalize(cross(up, zAxis));
                const yAxis = normalize(cross(zAxis, xAxis));
                
                return [
                    xAxis[0], xAxis[1], xAxis[2], 0,
                    yAxis[0], yAxis[1], yAxis[2], 0,
                    zAxis[0], zAxis[1], zAxis[2], 0,
                    eye[0], eye[1], eye[2], 1
                ];
            }
        };
        
        // Vector operations
        function normalize(v) {
            const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            if (length > 0.00001) {
                return [v[0] / length, v[1] / length, v[2] / length];
            }
            return [0, 0, 0];
        }
        
        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }
        
        function subtractVectors(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        }
        
        function addVectors(a, b) {
            return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
        }
        
        function scaleVector(v, s) {
            return [v[0] * s, v[1] * s, v[2] * s];
        }
        
        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        
        function length(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        }
        
        function distanceSquared(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dz = a.z - b.z;
            return dx * dx + dy * dy + dz * dz;
        }
        
        function distance(a, b) {
            return Math.sqrt(distanceSquared(a, b));
        }
        
        // ----------------------------------------------
        // Game Mesh Generation Functions
        // ----------------------------------------------
        
        // Create a simple cube mesh
        function createCubeMesh() {
            // Define the vertices for a cube
            const positions = [
                // Front face
                -1, -1, 1,  1, -1, 1,  1, 1, 1, -1, 1, 1,
                // Back face
                -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1,
                // Top face
                -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,
                // Bottom face
                -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
                // Right face
                1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1,
                // Left face
                -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1
            ];
            
            // Define normals
            const normals = [
                // Front face
                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
                // Back face
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
                // Top face
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
                // Bottom face
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
                // Right face
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
                // Left face
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0
            ];
            
            // Define texture coordinates
            const texcoords = [
                // Front face
                0, 0, 1, 0, 1, 1, 0, 1,
                // Back face
                1, 0, 1, 1, 0, 1, 0, 0,
                // Top face
                0, 1, 0, 0, 1, 0, 1, 1,
                // Bottom face
                1, 1, 0, 1, 0, 0, 1, 0,
                // Right face
                1, 0, 1, 1, 0, 1, 0, 0,
                // Left face
                0, 0, 1, 0, 1, 1, 0, 1
            ];
            
            // Define indices
            const indices = [
                0, 1, 2, 0, 2, 3,       // Front face
                4, 5, 6, 4, 6, 7,       // Back face
                8, 9, 10, 8, 10, 11,    // Top face
                12, 13, 14, 12, 14, 15, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 21, 22, 20, 22, 23  // Left face
            ];
            
            return {
                positions: positions,
                normals: normals,
                texcoords: texcoords,
                indices: indices
            };
        }
        
        // Create a simple cylinder/cone mesh (for trees)
        function createCylinderMesh(radiusTop = 1, radiusBottom = 1, height = 2, segments = 8) {
            const positions = [];
            const normals = [];
            const texcoords = [];
            const indices = [];
            
            const halfHeight = height / 2;
            
            // Create the vertices for the cylinder
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                // Texture coordinates
                const u = i / segments;
                
                // Top vertex
                positions.push(radiusTop * cosTheta, halfHeight, radiusTop * sinTheta);
                normals.push(cosTheta, 0, sinTheta);
                texcoords.push(u, 1);
                
                // Bottom vertex
                positions.push(radiusBottom * cosTheta, -halfHeight, radiusBottom * sinTheta);
                normals.push(cosTheta, 0, sinTheta);
                texcoords.push(u, 0);
            }
            
            // Create the indices for the sides
            for (let i = 0; i < segments; i++) {
                const p1 = i * 2;
                const p2 = p1 + 1;
                const p3 = p1 + 2;
                const p4 = p1 + 3;
                
                // Each segment is 2 triangles
                indices.push(p1, p2, p3);
                indices.push(p2, p4, p3);
            }
            
            return {
                positions: positions,
                normals: normals,
                texcoords: texcoords,
                indices: indices
            };
        }
        
        // Create a simple sphere mesh
        function createSphereMesh(radius = 1, latBands = 16, longBands = 16) {
            const positions = [];
            const normals = [];
            const texcoords = [];
            const indices = [];
            
            // Create the vertices
            for (let lat = 0; lat <= latBands; lat++) {
                const theta = lat * Math.PI / latBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let lon = 0; lon <= longBands; lon++) {
                    const phi = lon * 2 * Math.PI / longBands;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;
                    const u = 1 - (lon / longBands);
                    const v = 1 - (lat / latBands);
                    
                    positions.push(radius * x, radius * y, radius * z);
                    normals.push(x, y, z);
                    texcoords.push(u, v);
                }
            }
            
            // Create the indices
            for (let lat = 0; lat < latBands; lat++) {
                for (let lon = 0; lon < longBands; lon++) {
                    const first = (lat * (longBands + 1)) + lon;
                    const second = first + longBands + 1;
                    
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            
            return {
                positions: positions,
                normals: normals,
                texcoords: texcoords,
                indices: indices
            };
        }
        
        // Create a terrain mesh based on height map
        function createTerrainMesh(chunkX, chunkZ, size, resolution) {
            const positions = [];
            const normals = [];
            const texcoords = [];
            const indices = [];
            
            const halfSize = size / 2;
            const segmentSize = size / (resolution - 1);
            
            // Create vertices
            for (let z = 0; z < resolution; z++) {
                for (let x = 0; x < resolution; x++) {
                    const worldX = chunkX * size + x * segmentSize - halfSize;
                    const worldZ = chunkZ * size + z * segmentSize - halfSize;
                    const height = getTerrainHeight(worldX, worldZ);
                    
                    positions.push(worldX, height, worldZ);
                    texcoords.push(x / (resolution - 1), z / (resolution - 1));
                }
            }
            
            // Create indices
            for (let z = 0; z < resolution - 1; z++) {
                for (let x = 0; x < resolution - 1; x++) {
                    const topLeft = z * resolution + x;
                    const topRight = topLeft + 1;
                    const bottomLeft = (z + 1) * resolution + x;
                    const bottomRight = bottomLeft + 1;
                    
                    indices.push(topLeft, bottomLeft, topRight);
                    indices.push(topRight, bottomLeft, bottomRight);
                }
            }
            
            // Calculate normals
            for (let i = 0; i < positions.length / 3; i++) {
                normals.push(0, 1, 0); // Initialize with up vector
            }
            
            // Average normals from surrounding faces
            for (let i = 0; i < indices.length; i += 3) {
                const idx1 = indices[i] * 3;
                const idx2 = indices[i + 1] * 3;
                const idx3 = indices[i + 2] * 3;
                
                const v1 = [positions[idx1], positions[idx1 + 1], positions[idx1 + 2]];
                const v2 = [positions[idx2], positions[idx2 + 1], positions[idx2 + 2]];
                const v3 = [positions[idx3], positions[idx3 + 1], positions[idx3 + 2]];
                
                const edge1 = subtractVectors(v2, v1);
                const edge2 = subtractVectors(v3, v1);
                const normal = cross(edge1, edge2);
                
                // Add to each vertex normal
                normals[indices[i] * 3 + 0] += normal[0];
                normals[indices[i] * 3 + 1] += normal[1];
                normals[indices[i] * 3 + 2] += normal[2];
                
                normals[indices[i + 1] * 3 + 0] += normal[0];
                normals[indices[i + 1] * 3 + 1] += normal[1];
                normals[indices[i + 1] * 3 + 2] += normal[2];
                
                normals[indices[i + 2] * 3 + 0] += normal[0];
                normals[indices[i + 2] * 3 + 1] += normal[1];
                normals[indices[i + 2] * 3 + 2] += normal[2];
            }
            
            // Normalize all normals
            for (let i = 0; i < normals.length; i += 3) {
                const nx = normals[i];
                const ny = normals[i + 1];
                const nz = normals[i + 2];
                
                const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                if (len > 0) {
                    normals[i] = nx / len;
                    normals[i + 1] = ny / len;
                    normals[i + 2] = nz / len;
                }
            }
            
            return {
                positions: positions,
                normals: normals,
                texcoords: texcoords,
                indices: indices
            };
        }
        
        // Create a water plane mesh
        function createWaterMesh(chunkX, chunkZ, size, resolution) {
            const positions = [];
            const normals = [];
            const texcoords = [];
            const indices = [];
            
            const halfSize = size / 2;
            const segmentSize = size / (resolution - 1);
            const waterHeight = 0; // Water level
            
            // Create vertices
            for (let z = 0; z < resolution; z++) {
                for (let x = 0; x < resolution; x++) {
                    const worldX = chunkX * size + x * segmentSize - halfSize;
                    const worldZ = chunkZ * size + z * segmentSize - halfSize;
                    
                    positions.push(worldX, waterHeight, worldZ);
                    normals.push(0, 1, 0); // Water normals always point up
                    texcoords.push(x / (resolution - 1), z / (resolution - 1));
                }
            }
            
            // Create indices
            for (let z = 0; z < resolution - 1; z++) {
                for (let x = 0; x < resolution - 1; x++) {
                    
                vec3 ambient = 0.3 * u_color.rgb;
                vec3 diffuse = diff * u_color.rgb;
                vec3 color = ambient + diffuse;
                
                // Apply fog
                float fogFactor = clamp(1.0 - length(v_position - u_viewPosition) / u_fogDistance, 0.0, 1.0);
                color = mix(u_fogColor, color, fogFactor);
                
                gl_FragColor = vec4(color, u_color.a);
            }
        `;
        
        // Terrain shader
        const terrainFragmentShaderSource = `
            precision mediump float;
            
            varying vec3 v_normal;
            varying vec2 v_texcoord;
            varying vec3 v_position;
            
            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            uniform float u_time;
            uniform float u_fogDistance;
            uniform vec3 u_fogColor;
            
            // Terrain types
            const vec3 GRASS_COLOR = vec3(0.2, 0.5, 0.1);
            const vec3 DIRT_COLOR = vec3(0.5, 0.3, 0.1);
            const vec3 ROCK_COLOR = vec3(0.5, 0.5, 0.5);
            const vec3 SAND_COLOR = vec3(0.8, 0.7, 0.4);
            const vec3 SNOW_COLOR = vec3(0.9, 0.9, 0.95);
            
            void main() {
                vec3 normal = normalize(v_normal);
                vec3 lightDir = normalize(u_lightDirection);
                float diff = max(dot(normal, lightDir), 0.2);
                
                // Determine terrain type based on height and slope
                float height = v_position.y;
                float slope = 1.0 - normal.y;
                
                vec3 baseColor;
                
                // Snow on peaks
                if (height > 15.0) {
                    baseColor = mix(ROCK_COLOR, SNOW_COLOR, min((height - 15.0) / 5.0, 1.0));
                }
                // Rock on slopes
                else if (slope > 0.3) {
                    baseColor = mix(DIRT_COLOR, ROCK_COLOR, min(slope * 2.0, 1.0));
                }
                // Sand near water
                else if (height < 1.0 && height > 0.0) {
                    baseColor = mix(GRASS_COLOR, SAND_COLOR, 1.0 - height);
                }
                // Underwater sand/dirt
                else if (height <= 0.0) {
                    baseColor = mix(SAND_COLOR, vec3(0.2, 0.3, 0.4), min(-height / 5.0, 1.0));
                }
                // Grass everywhere else
                else {
                    baseColor = mix(GRASS_COLOR, DIRT_COLOR, slope * 2.0);
                    
                    // Add some variation to grass
                    float noise = fract(sin(dot(v_texcoord, vec2(12.9898, 78.233)) * 43758.5453));
                    baseColor *= 0.9 + 0.2 * noise;
                }
                
                // Simple ambient + diffuse lighting
                vec3 ambient = 0.3 * baseColor;
                vec3 diffuse = diff * baseColor;
                vec3 color = ambient + diffuse;
                
                // Apply fog
                float fogFactor = clamp(1.0 - length(v_position - u_viewPosition) / u_fogDistance, 0.0, 1.0);
                color = mix(u_fogColor, color, fogFactor);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // Water shader
        const waterFragmentShaderSource = `
            precision mediump float;
            
            varying vec3 v_normal;
            varying vec2 v_texcoord;
            varying vec3 v_position;
            
            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            uniform float u_time;
            uniform float u_fogDistance;
            uniform vec3 u_fogColor;
            
            void main() {
                vec3 normal = normalize(v_normal);
                
                // Animate waves
                float wave1 = sin(v_texcoord.x * 10.0 + u_time * 0.5) * 0.05;
                float wave2 = sin(v_texcoord.y * 8.0 + u_time * 0.4) * 0.05;
                normal.xz += vec2(wave1, wave2);
                normal = normalize(normal);
                
                vec3 lightDir = normalize(u_lightDirection);
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Fake reflections
                vec3 viewDir = normalize(u_viewPosition - v_position);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                
                // Deep water color
                vec3 waterColor = vec3(0.1, 0.3, 0.5);
                
                // Calculate water depth effect
                float depth = 0.0 - v_position.y;
                waterColor = mix(vec3(0.4, 0.6, 0.8), waterColor, min(depth / 10.0, 1.0));
                
                // Apply lighting
                vec3 ambient = 0.3 * waterColor;
                vec3 diffuse = diff * waterColor;
                vec3 specular = spec * vec3(1.0);
                vec3 color = ambient + diffuse + specular;
                
                // Apply fog
                float fogFactor = clamp(1.0 - length(v_position - u_viewPosition) / u_fogDistance, 0.0, 1.0);
                color = mix(u_fogColor, color, fogFactor);
                
                gl_FragColor = vec4(color, 0.8);
            }
        `;
        
        // Sky shader
        const skyboxFragmentShaderSource = `
            precision mediump float;
            
            varying vec3 v_position;
            
            uniform float u_time;
            uniform float u_dayTime; // 0-1 for day/night cycle
            
            void main() {
                vec3 direction = normalize(v_position);
                
                // Sky gradient
                float y = direction.y * 0.5 + 0.5;
                
                // Day colors
                vec3 dayBottom = vec3(0.5, 0.7, 1.0);
                vec3 dayTop = vec3(0.2, 0.4, 0.8);
                vec3 dayColor = mix(dayBottom, dayTop, y);
                
                // Night colors
                vec3 nightBottom = vec3(0.05, 0.05, 0.1);
                vec3 nightTop = vec3(0.0, 0.0, 0.15);
                vec3 nightColor = mix(nightBottom, nightTop, y);
                
                // Sunrise/sunset colors
                vec3 sunriseBottom = vec3(0.8, 0.3, 0.1);
                vec3 sunriseTop = vec3(0.1, 0.1, 0.5);
                vec3 sunriseColor = mix(sunriseBottom, sunriseTop, y);
                
                vec3 color;
                
                // Day/night cycle transitions
                if (u_dayTime < 0.25) { // Night to sunrise
                    float t = u_dayTime / 0.25;
                    color = mix(nightColor, sunriseColor, smoothstep(0.0, 1.0, t));
                } else if (u_dayTime < 0.3) { // Sunrise to day
                    float t = (u_dayTime - 0.25) / 0.05;
                    color = mix(sunriseColor, dayColor, smoothstep(0.0, 1.0, t));
                } else if (u_dayTime < 0.7) { // Full day
                    color = dayColor;
                } else if (u_dayTime < 0.75) { // Day to sunset
                    float t = (u_dayTime - 0.7) / 0.05;
                    color = mix(dayColor, sunriseColor, smoothstep(0.0, 1.0, t));
                } else if (u_dayTime < 0.8) { // Sunset to night
                    float t = (u_dayTime - 0.75) / 0.05;
                    color = mix(sunriseColor, nightColor, smoothstep(0.0, 1.0, t));
                } else { // Full night
                    color = nightColor;
                }
                
                // Add stars at night
                if (u_dayTime > 0.75 || u_dayTime < 0.25) {
                    // Simple star pattern
                    vec3 p = direction * 100.0;
                    vec3 stars = vec3(0.0);
                    
                    // Random star pattern
                    for (int i = 0; i < 3; i++) {
                        vec3 fp = fract(p + float(i) * 13.37);
                        float n = dot(fp, vec3(127.1, 311.7, 74.7));
                        float star = step(0.995, fract(sin(n) * 43758.5453));
                        stars += star * vec3(1.0, 1.0, 1.0) * (0.5 + 0.5 * sin(u_time * 0.5 + float(i)));
                    }
                    
                    color += stars;
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // Shader for simple mesh entities (trees, rocks, etc.)
        const entityFragmentShaderSource = `
            precision mediump float;
            
            varying vec3 v_normal;
            varying vec2 v_texcoord;
            varying vec3 v_position;
            
            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            uniform vec4 u_color;
            uniform float u_time;
            uniform float u_fogDistance;
            uniform vec3 u_fogColor;
            uniform float u_swayFactor;
            
            void main() {
                vec3 normal = normalize(v_normal);
                vec3 lightDir = normalize(u_lightDirection);
                float diff = max(dot(normal, lightDir), 0.2);
                
                // Simple ambient + diffuse lighting
