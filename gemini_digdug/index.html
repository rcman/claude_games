<!DOCTYPE html>
<html>
<head>
<title>HTML5 Dig Dug Clone</title>
<meta charset="utf-8"/>
<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background-color: #111;
        font-family: 'Arial', sans-serif;
        color: white;
    }
    canvas {
        border: 2px solid #555;
        background-color: #000;
    }
    #info {
        margin-top: 10px;
        font-size: 1.2em;
        min-width: 600px; /* Match canvas width */
        display: flex;
        justify-content: space-between;
    }
    #controls {
        margin-top: 15px;
        font-size: 0.9em;
        color: #aaa;
    }
    #message {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2em;
        color: yellow;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        display: none; /* Hidden initially */
        z-index: 10;
    }
</style>
</head>
<body>

<div id="info">
    <span id="score">Score: 0</span>
    <span id="level">Level: 1</span>
    <span id="lives">Lives: 3</span>
</div>

<canvas id="gameCanvas" width="600" height="640"></canvas>

<div id="controls">
    Use Arrow Keys to Move/Dig | Use Spacebar to Pump
</div>

<div id="message">
    Game Over! <br> Press Enter to Restart
</div>

<script>
// --- Core Game Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const levelDisplay = document.getElementById('level');
const livesDisplay = document.getElementById('lives');
const messageDisplay = document.getElementById('message');

// --- Game Constants ---
const TILE_SIZE = 40;
const GRID_COLS = canvas.width / TILE_SIZE; // 15
const GRID_ROWS = canvas.height / TILE_SIZE; // 16

const COLORS = {
    BACKGROUND: '#000',
    DIRT_LAYER_1: '#BF6A30', // Brownish
    DIRT_LAYER_2: '#D9A648', // Lighter Brown
    DIRT_LAYER_3: '#F0D06C', // Yellowish
    DIRT_LAYER_4: '#FFEC8B', // Pale Yellow
    TUNNEL: '#000',
    PLAYER: '#FFF',
    PUMP_HOSE: '#DDD',
    POOKA: '#E04040', // Red
    POOKA_EYES: '#FFF',
    FYGAR: '#40A040', // Green
    FYGAR_EYES: '#FFF',
    FYGAR_FIRE: '#FFA500', // Orange
    ROCK: '#808080', // Grey
    ROCK_SHAKE: '#A0A0A0',
    ENEMY_GHOST: 'rgba(255, 255, 255, 0.5)',
    INFLATE_1: '#FF8080', // Pooka Inflate 1 (lighter red)
    INFLATE_2: '#FFB0B0', // Pooka Inflate 2
    INFLATE_3: '#FFE0E0', // Pooka Inflate 3
    FINFLATE_1: '#80C080', // Fygar Inflate 1 (lighter green)
    FINFLATE_2: '#B0D0B0', // Fygar Inflate 2
    FINFLATE_3: '#E0F0E0', // Fygar Inflate 3
};

const DIRT_COLORS = [
    COLORS.DIRT_LAYER_1,
    COLORS.DIRT_LAYER_1,
    COLORS.DIRT_LAYER_1,
    COLORS.DIRT_LAYER_1,
    COLORS.DIRT_LAYER_2,
    COLORS.DIRT_LAYER_2,
    COLORS.DIRT_LAYER_2,
    COLORS.DIRT_LAYER_2,
    COLORS.DIRT_LAYER_3,
    COLORS.DIRT_LAYER_3,
    COLORS.DIRT_LAYER_3,
    COLORS.DIRT_LAYER_3,
    COLORS.DIRT_LAYER_4,
    COLORS.DIRT_LAYER_4,
    COLORS.DIRT_LAYER_4,
    COLORS.DIRT_LAYER_4,
];

const GAME_STATE = {
    MENU: 'MENU',
    PLAYING: 'PLAYING',
    PLAYER_DIED: 'PLAYER_DIED',
    LEVEL_CLEAR: 'LEVEL_CLEAR',
    GAME_OVER: 'GAME_OVER'
};

const ENEMY_STATE = {
    ROAMING: 'ROAMING',
    GHOSTING: 'GHOSTING',
    INFLATING: 'INFLATING',
    STUNNED: 'STUNNED', // After being partially inflated or hit by rock stun
    FIRING: 'FIRING'    // Fygar specific
};

const ROCK_STATE = {
    STABLE: 'STABLE',
    SHAKING: 'SHAKING',
    FALLING: 'FALLING'
};

const PLAYER_SPEED = 2; // Pixels per frame (adjust for desired speed)
const ENEMY_SPEED = 1.5;
const ENEMY_GHOST_SPEED = 1;
const ROCK_FALL_SPEED = 5;
const PUMP_LENGTH = 3 * TILE_SIZE; // Max length of the pump
const PUMP_INFLATE_TICKS = 10; // Ticks needed per inflation stage
const PUMP_MAX_INFLATION = 4; // Stages before pop
const ROCK_SHAKE_DURATION = 60; // Frames
const ENEMY_GHOST_DURATION = 120; // Frames
const ENEMY_GHOST_COOLDOWN = 300; // Frames
const FYGAR_FIRE_DURATION = 40; // Frames
const FYGAR_FIRE_COOLDOWN = 180; // Frames
const FYGAR_FIRE_RANGE = 4; // Tiles

// --- Game Variables ---
let grid = [];
let player;
let enemies = [];
let rocks = [];
let pump = null; // {x, y, dx, dy, length, targetEnemy, inflationTicks}
let score = 0;
let lives = 3;
let level = 1;
let gameState = GAME_STATE.PLAYING; // Start directly in playing state for simplicity
let frameCount = 0; // Simple timer

// --- Input Handling ---
let keys = {};
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    // Prevent default scrolling behavior for arrow keys and space
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
        e.preventDefault();
    }
    // Restart game
    if (gameState === GAME_STATE.GAME_OVER && e.code === 'Enter') {
        resetGame();
    }
});
window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

// --- Helper Functions ---
function getGridCoords(x, y) {
    return {
        col: Math.floor(x / TILE_SIZE),
        row: Math.floor(y / TILE_SIZE)
    };
}

function getPixelCoords(col, row) {
    return {
        x: col * TILE_SIZE,
        y: row * TILE_SIZE
    };
}

function isDirt(col, row) {
    if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) return false;
    return grid[row][col] === 1;
}

function isTunnel(col, row) {
    if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) return true; // Outside grid is like a tunnel
    return grid[row][col] === 0;
}

function digTunnel(col, row) {
    if (col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS) {
        if (grid[row][col] === 1) {
            grid[row][col] = 0; // Change dirt to tunnel
            checkRocksAbove(col, row); // Check if digging triggers rock fall
            // Simple digging score (like original) - more points deeper
            // score += Math.max(1, Math.floor(row / 4)) * 10; // Example scoring
            return true; // Dug successfully
        }
    }
    return false; // Did not dig (already tunnel or out of bounds)
}

function checkRocksAbove(col, row) {
    // Check the tile directly above the dug one
    if (row > 0) {
        rocks.forEach(rock => {
            if (rock.state === ROCK_STATE.STABLE && rock.col === col && rock.row === row - 1) {
                // Check if the space below the rock is now empty
                if (isTunnel(rock.col, rock.row + 1)) {
                    rock.startShaking();
                }
            }
        });
    }
}

function checkRockFallTrigger(rock) {
     // A rock falls if the tile directly beneath it is a tunnel
     if (rock.row + 1 < GRID_ROWS) {
         return isTunnel(rock.col, rock.row + 1);
     }
     return false; // Rock at bottom row cannot fall
}

function checkCollision(obj1, obj2) {
    // Simple AABB collision detection
    return obj1.x < obj2.x + obj2.width &&
           obj1.x + obj1.width > obj2.x &&
           obj1.y < obj2.y + obj2.height &&
           obj1.y + obj1.height > obj2.y;
}

function getCenter(obj) {
    return {
        x: obj.x + obj.width / 2,
        y: obj.y + obj.height / 2
    }
}

// --- Game Object Classes ---

class Player {
    constructor(col, row) {
        this.width = TILE_SIZE * 0.8;
        this.height = TILE_SIZE * 0.8;
        this.x = col * TILE_SIZE + (TILE_SIZE - this.width) / 2;
        this.y = row * TILE_SIZE + (TILE_SIZE - this.height) / 2;
        this.speed = PLAYER_SPEED;
        this.dx = 0; // Direction x (-1, 0, 1)
        this.dy = 0; // Direction y (-1, 0, 1)
        this.lastNonZeroDx = 1; // Facing right initially
        this.lastNonZeroDy = 0;
        this.isMoving = false;
        this.isDigging = false;
        this.isPumping = false;
        this.canMove = true;
    }

    update() {
        if (!this.canMove) return;

        this.isMoving = false;
        this.isDigging = false;
        let nextX = this.x;
        let nextY = this.y;
        let targetDx = 0;
        let targetDy = 0;

        // --- Input Handling ---
        if (!this.isPumping) { // Cannot move while actively pumping
            if (keys['ArrowLeft']) targetDx = -1;
            else if (keys['ArrowRight']) targetDx = 1;
            else if (keys['ArrowUp']) targetDy = -1;
            else if (keys['ArrowDown']) targetDy = 1;

            // Prioritize changing direction only when aligned with grid
            const currentTileX = Math.round(this.x / TILE_SIZE);
            const currentTileY = Math.round(this.y / TILE_SIZE);
            const isOnGridX = Math.abs(this.x - currentTileX * TILE_SIZE) < this.speed;
            const isOnGridY = Math.abs(this.y - currentTileY * TILE_SIZE) < this.speed;


            if (targetDx !== 0 && isOnGridY) { // Trying to move horizontally
                 this.dx = targetDx;
                 this.dy = 0;
                 this.y = currentTileY * TILE_SIZE + (TILE_SIZE - this.height) / 2; // Snap to Y grid line
            } else if (targetDy !== 0 && isOnGridX) { // Trying to move vertically
                this.dy = targetDy;
                this.dx = 0;
                this.x = currentTileX * TILE_SIZE + (TILE_SIZE - this.width) / 2; // Snap to X grid line
            } else if (targetDx === 0 && targetDy === 0) {
                // No input, attempt to snap to grid if moving
                if(this.dx !== 0 && isOnGridX){ /* No snap needed if already moving*/ }
                else if (this.dy !== 0 && isOnGridY){ /* No snap needed if already moving*/ }
                else {
                    // If not perfectly aligned and not moving, stop trying to move
                    if (!isOnGridX && this.dx !== 0) this.dx = 0;
                    if (!isOnGridY && this.dy !== 0) this.dy = 0;
                }
            }

             // Update last facing direction
            if (this.dx !== 0) { this.lastNonZeroDx = this.dx; this.lastNonZeroDy = 0;}
            if (this.dy !== 0) { this.lastNonZeroDy = this.dy; this.lastNonZeroDx = 0;}

            // Calculate next position
            nextX += this.dx * this.speed;
            nextY += this.dy * this.speed;

            // --- Collision & Digging ---
            if (this.dx !== 0 || this.dy !== 0) {
                this.isMoving = true;

                // Calculate target grid cell based on movement direction
                const targetCol = Math.floor((getCenter(this).x + this.dx * TILE_SIZE / 2) / TILE_SIZE);
                const targetRow = Math.floor((getCenter(this).y + this.dy * TILE_SIZE / 2) / TILE_SIZE);

                if (isDirt(targetCol, targetRow)) {
                    this.isDigging = true;
                    digTunnel(targetCol, targetRow);
                    // Slight speed reduction while digging? Original game might have done this.
                }

                 // Boundary checks
                if (nextX < 0) nextX = 0;
                if (nextX + this.width > canvas.width) nextX = canvas.width - this.width;
                if (nextY < 0) nextY = 0;
                if (nextY + this.height > canvas.height) nextY = canvas.height - this.height;

                // Rock collision check (can't move into a rock) - Check target TILE
                let movingIntoRock = false;
                 const nextCol = Math.floor((getCenter({x: nextX, y: nextY, width: this.width, height: this.height}).x) / TILE_SIZE);
                 const nextRow = Math.floor((getCenter({x: nextX, y: nextY, width: this.width, height: this.height}).y) / TILE_SIZE);

                rocks.forEach(rock => {
                    // Need to check the tile the player is trying to ENTER
                    let checkCol = currentTileX + this.dx;
                    let checkRow = currentTileY + this.dy;
                     if(rock.col === checkCol && rock.row === checkRow && rock.state !== ROCK_STATE.FALLING){ // Can be crushed by falling rock, but cannot move into stable/shaking rock
                         movingIntoRock = true;
                         // Snap back to edge of current tile
                         if(this.dx > 0) this.x = checkCol * TILE_SIZE - this.width - 1 + (TILE_SIZE - this.width) / 2;
                         else if (this.dx < 0) this.x = (checkCol + 1) * TILE_SIZE + (TILE_SIZE - this.width) / 2;
                         else if (this.dy > 0) this.y = checkRow * TILE_SIZE - this.height - 1 + (TILE_SIZE - this.height) / 2;
                         else if (this.dy < 0) this.y = (checkRow + 1) * TILE_SIZE + (TILE_SIZE - this.height) / 2;
                     }
                 });


                if (!movingIntoRock) {
                    this.x = nextX;
                    this.y = nextY;
                } else {
                    this.isMoving = false; // Stop if blocked by rock
                    this.dx = 0;
                    this.dy = 0;
                }
            }

             // --- Pumping ---
             if (keys['Space'] && !pump) {
                 this.startPump();
             }
        } // end if !isPumping

        // Update active pump
        if (pump) {
            this.updatePump();
        }
        if (!keys['Space'] && pump) { // Release space stops pumping
             this.stopPump();
        }

    }

    startPump() {
        if (this.isPumping) return; // Already pumping
        this.isPumping = true;
        this.dx = 0; // Stop player movement
        this.dy = 0;
        pump = {
            x: getCenter(this).x,
            y: getCenter(this).y,
            dx: this.lastNonZeroDx,
            dy: this.lastNonZeroDy,
            length: TILE_SIZE * 0.5, // Initial small length
            maxLength: PUMP_LENGTH,
            targetEnemy: null,
            inflationTicks: 0,
            active: true
        };
    }

     updatePump() {
        if (!pump || !pump.active) return;

        pump.length += 5; // Extend pump hose
        if (pump.length > pump.maxLength) {
            pump.length = pump.maxLength;
            // If max length reached and no target, stop the pump
            if (!pump.targetEnemy) {
                 this.stopPump();
                 return;
            }
        }

        // Check for collision with enemies along the pump line
        const pumpEndX = pump.x + pump.dx * pump.length;
        const pumpEndY = pump.y + pump.dy * pump.length;

        if (!pump.targetEnemy) { // Only find a new target if not already inflating one
            for (let enemy of enemies) {
                if (enemy.state !== ENEMY_STATE.INFLATING && enemy.state !== ENEMY_STATE.STUNNED) { // Can't pump stunned/already inflating enemies
                    const enemyCenterX = enemy.x + enemy.width / 2;
                    const enemyCenterY = enemy.y + enemy.height / 2;

                    // Check if enemy center is roughly along the pump line
                    let hit = false;
                    if (pump.dx !== 0) { // Horizontal pump
                        if (Math.abs(enemyCenterY - pump.y) < enemy.height / 2 &&
                            ((pump.dx > 0 && enemyCenterX > pump.x && enemyCenterX < pumpEndX) ||
                             (pump.dx < 0 && enemyCenterX < pump.x && enemyCenterX > pumpEndX))) {
                            hit = true;
                        }
                    } else { // Vertical pump
                         if (Math.abs(enemyCenterX - pump.x) < enemy.width / 2 &&
                            ((pump.dy > 0 && enemyCenterY > pump.y && enemyCenterY < pumpEndY) ||
                             (pump.dy < 0 && enemyCenterY < pump.y && enemyCenterY > pumpEndY))) {
                            hit = true;
                        }
                    }

                    if (hit) {
                        pump.targetEnemy = enemy;
                        enemy.startInflation();
                        pump.inflationTicks = 0;
                        break; // Pump attaches to the first enemy hit
                    }
                }
            }
        }

        // If pump is attached, increment inflation
        if (pump.targetEnemy) {
            // Ensure pump stays visually connected
             const enemyCenterX = pump.targetEnemy.x + pump.targetEnemy.width / 2;
             const enemyCenterY = pump.targetEnemy.y + pump.targetEnemy.height / 2;
             pump.length = Math.sqrt(Math.pow(enemyCenterX - pump.x, 2) + Math.pow(enemyCenterY - pump.y, 2));


            pump.inflationTicks++;
            if (pump.inflationTicks >= PUMP_INFLATE_TICKS) {
                pump.inflationTicks = 0;
                const popped = pump.targetEnemy.inflate();
                if (popped) {
                     this.stopPump(); // Stop pumping once enemy pops
                }
            }
        }
    }


    stopPump() {
         this.isPumping = false;
         if (pump && pump.targetEnemy && pump.targetEnemy.state === ENEMY_STATE.INFLATING) {
             // If pump released before popping, enemy deflates and gets stunned briefly
             pump.targetEnemy.deflate();
         }
         pump = null;
    }

    draw() {
        // Simple player representation
        ctx.fillStyle = COLORS.PLAYER;
        ctx.fillRect(this.x, this.y, this.width, this.height);

        // Draw pump hose if active
        if (pump && pump.active) {
            ctx.strokeStyle = COLORS.PUMP_HOSE;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(pump.x, pump.y);
            const endX = pump.x + pump.dx * pump.length;
            const endY = pump.y + pump.dy * pump.length;
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.lineWidth = 1; // Reset line width
        }
    }

    die() {
        lives--;
        livesDisplay.textContent = `Lives: ${lives}`;
        gameState = GAME_STATE.PLAYER_DIED;
        this.canMove = false; // Prevent movement after death
        // Add a small delay before respawn or game over
        setTimeout(() => {
            if (lives <= 0) {
                gameState = GAME_STATE.GAME_OVER;
                messageDisplay.style.display = 'block';
            } else {
                // Respawn logic
                resetLevelState(); // Reset positions but keep grid/score
                gameState = GAME_STATE.PLAYING;
            }
        }, 1500); // 1.5 second delay
    }
}

class Enemy {
    constructor(col, row, type) {
        this.type = type; // 'POOKA' or 'FYGAR'
        this.width = TILE_SIZE * 0.8;
        this.height = TILE_SIZE * 0.8;
        this.spawnCol = col;
        this.spawnRow = row;
        this.x = col * TILE_SIZE + (TILE_SIZE - this.width) / 2;
        this.y = row * TILE_SIZE + (TILE_SIZE - this.height) / 2;
        this.speed = ENEMY_SPEED;
        this.dx = 0;
        this.dy = 0;
        this.state = ENEMY_STATE.ROAMING;
        this.inflationLevel = 0; // 0 to PUMP_MAX_INFLATION
        this.ghostTimer = 0;
        this.ghostCooldown = Math.random() * 100 + ENEMY_GHOST_COOLDOWN; // Randomize initial cooldown
        this.stunTimer = 0;
        this.targetCol = col;
        this.targetRow = row; // Target tile for movement
        this.lastMoveDecision = 0; // Frame count of last turn decision
    }

    update() {
        frameCount++; // Assuming frameCount is global or accessible

        if (this.state === ENEMY_STATE.INFLATING) {
            // Stay still while inflating
            return;
        }
        if (this.state === ENEMY_STATE.STUNNED) {
            this.stunTimer--;
            if (this.stunTimer <= 0) {
                this.state = ENEMY_STATE.ROAMING;
            }
            return; // Stay still while stunned
        }

         // --- Ghosting Logic ---
        this.ghostCooldown--;
        if (this.state === ENEMY_STATE.ROAMING && this.ghostCooldown <= 0) {
            this.startGhosting();
        }

        if (this.state === ENEMY_STATE.GHOSTING) {
            this.ghostTimer--;
            this.speed = ENEMY_GHOST_SPEED;
            if (this.ghostTimer <= 0) {
                this.stopGhosting();
            }
        } else {
             this.speed = ENEMY_SPEED + level * 0.1; // Increase speed slightly per level
        }

        // --- Movement AI ---
        const currentTileCol = Math.round(this.x / TILE_SIZE);
        const currentTileRow = Math.round(this.y / TILE_SIZE);
        const isOnGridX = Math.abs(this.x - currentTileCol * TILE_SIZE) < this.speed * 1.5;
        const isOnGridY = Math.abs(this.y - currentTileRow * TILE_SIZE) < this.speed * 1.5;
        const isOnJunction = isOnGridX && isOnGridY;

        // Decide on a new direction at junctions or randomly sometimes
        if (isOnJunction && (frameCount - this.lastMoveDecision > 30 || (this.dx === 0 && this.dy === 0))) {
             this.makeMoveDecision(currentTileCol, currentTileRow);
             this.lastMoveDecision = frameCount;
        }


        // Move towards the target direction
        let nextX = this.x + this.dx * this.speed;
        let nextY = this.y + this.dy * this.speed;

        // Collision with walls/dirt (unless ghosting)
        if (this.state !== ENEMY_STATE.GHOSTING) {
            const targetCol = Math.floor((getCenter(this).x + this.dx * TILE_SIZE / 2) / TILE_SIZE);
            const targetRow = Math.floor((getCenter(this).y + this.dy * TILE_SIZE / 2) / TILE_SIZE);

            if (isDirt(targetCol, targetRow)) {
                // Hit dirt, stop or find new path if at junction
                 if(isOnJunction) {
                    this.makeMoveDecision(currentTileCol, currentTileRow); // Try turning
                     nextX = this.x + this.dx * this.speed; // Recalculate next pos based on potential new direction
                     nextY = this.y + this.dy * this.speed;
                     // If still blocked after turning, stop
                     const newTargetCol = Math.floor((getCenter(this).x + this.dx * TILE_SIZE / 2) / TILE_SIZE);
                     const newTargetRow = Math.floor((getCenter(this).y + this.dy * TILE_SIZE / 2) / TILE_SIZE);
                     if(isDirt(newTargetCol, newTargetRow)){
                        nextX = this.x;
                        nextY = this.y;
                        this.dx = 0;
                        this.dy = 0;
                     }

                 } else {
                     // Not at junction but hit dirt, just stop moving in that direction
                     nextX = this.x;
                     nextY = this.y;
                     this.dx = 0; // Force stop might be too abrupt, maybe snap?
                     this.dy = 0;
                     // Snap to grid position to allow turning later
                     this.x = currentTileCol * TILE_SIZE + (TILE_SIZE - this.width) / 2;
                     this.y = currentTileRow * TILE_SIZE + (TILE_SIZE - this.height) / 2;
                 }

            }
        }

        // Rock collision check (can't move into rocks unless falling onto them)
        rocks.forEach(rock => {
            if (rock.state !== ROCK_STATE.FALLING) {
                 const rockTileX = rock.col * TILE_SIZE;
                 const rockTileY = rock.row * TILE_SIZE;
                 const rockCollider = { x: rockTileX, y: rockTileY, width: TILE_SIZE, height: TILE_SIZE };
                 const nextPosCollider = { x: nextX, y: nextY, width: this.width, height: this.height };

                 if(checkCollision(nextPosCollider, rockCollider)){
                      nextX = this.x; // Stop movement
                      nextY = this.y;
                      this.dx = 0;
                      this.dy = 0;
                       // Snap to grid position
                       this.x = currentTileCol * TILE_SIZE + (TILE_SIZE - this.width) / 2;
                       this.y = currentTileRow * TILE_SIZE + (TILE_SIZE - this.height) / 2;
                 }
            }
        });


        // Boundary checks
        if (nextX < 0) { nextX = 0; this.dx = 0; }
        if (nextX + this.width > canvas.width) { nextX = canvas.width - this.width; this.dx = 0;}
        if (nextY < 0) { nextY = 0; this.dy = 0;}
        if (nextY + this.height > canvas.height) { nextY = canvas.height - this.height; this.dy = 0;}


        this.x = nextX;
        this.y = nextY;

         // --- Player Collision ---
        const playerCollider = {x: player.x, y: player.y, width: player.width, height: player.height};
        const enemyCollider = {x: this.x, y: this.y, width: this.width, height: this.height};
        if (gameState === GAME_STATE.PLAYING && checkCollision(playerCollider, enemyCollider)) {
            player.die();
        }
    }

     makeMoveDecision(col, row) {
         let possibleMoves = [];
         // Check potential moves (Up, Down, Left, Right)
         // Don't move into dirt unless ghosting
         // Don't move into rocks
         // Avoid reversing direction immediately unless no other choice

         const canMove = (dCol, dRow) => {
             const nextCol = col + dCol;
             const nextRow = row + dRow;
             if (nextCol < 0 || nextCol >= GRID_COLS || nextRow < 0 || nextRow >= GRID_ROWS) return false; // Bounds check

             // Check for rocks
             for (let rock of rocks) {
                 if (rock.col === nextCol && rock.row === nextRow && rock.state !== ROCK_STATE.FALLING) return false;
             }

             // Check for dirt (allow if ghosting)
             if (isDirt(nextCol, nextRow) && this.state !== ENEMY_STATE.GHOSTING) return false;

             return true;
         };

         // Check possible moves: [dx, dy]
         const moves = [[0, -1], [0, 1], [-1, 0], [1, 0]];
         moves.forEach(([dCol, dRow]) => {
              // Avoid immediate reversal if possible
             if (dCol === -this.dx && dRow === -this.dy && possibleMoves.length > 0) {
                 // Don't add reversal if other options exist
             } else if (canMove(dCol, dRow)) {
                 possibleMoves.push({ dx: dCol, dy: dRow });
             }
         });

         // If only reversal is possible, add it back
         if (possibleMoves.length === 0 && canMove(-this.dx, -this.dy)) {
             possibleMoves.push({ dx: -this.dx, dy: -this.dy });
         }


         if (possibleMoves.length > 0) {
             // Simple random choice for now
             // TODO: Add smarter pathfinding towards player?
             const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
             this.dx = move.dx;
             this.dy = move.dy;

             // Snap to grid when changing direction
             this.x = col * TILE_SIZE + (TILE_SIZE - this.width) / 2;
             this.y = row * TILE_SIZE + (TILE_SIZE - this.height) / 2;
         } else {
             // No valid moves, stop
             this.dx = 0;
             this.dy = 0;
         }
     }


    startGhosting() {
        if (this.state === ENEMY_STATE.ROAMING) {
            this.state = ENEMY_STATE.GHOSTING;
            this.ghostTimer = ENEMY_GHOST_DURATION;
            // Try to move towards player when ghosting? Simplified: just random move allowed through dirt
            const currentTileCol = Math.round(this.x / TILE_SIZE);
            const currentTileRow = Math.round(this.y / TILE_SIZE);
             this.makeMoveDecision(currentTileCol, currentTileRow); // Recalculate moves allowing dirt
        }
    }

    stopGhosting() {
        this.state = ENEMY_STATE.ROAMING;
        this.ghostCooldown = ENEMY_GHOST_COOLDOWN + Math.random() * 50; // Reset cooldown
        this.speed = ENEMY_SPEED + level * 0.1;

        // Important: If ghosting ends inside dirt, the enemy should die or pop out.
        // Simplification: Force into nearest tunnel if possible, otherwise might get stuck/die.
        const currentCol = Math.floor(getCenter(this).x / TILE_SIZE);
        const currentRow = Math.floor(getCenter(this).y / TILE_SIZE);

        if (isDirt(currentCol, currentRow)) {
             // Find nearest tunnel - simple adjacent check
             const neighbors = [[0,0], [0, -1], [0, 1], [-1, 0], [1, 0]]; // Check current first
             let foundTunnel = false;
             for(let [dc, dr] of neighbors) {
                 const nc = currentCol + dc;
                 const nr = currentRow + dr;
                 if(isTunnel(nc, nr)) {
                     this.x = nc * TILE_SIZE + (TILE_SIZE - this.width) / 2;
                     this.y = nr * TILE_SIZE + (TILE_SIZE - this.height) / 2;
                     this.dx = 0; // Stop briefly after emerging
                     this.dy = 0;
                     foundTunnel = true;
                     break;
                 }
             }
             // If no adjacent tunnel, the enemy might be trapped. In real game, they might force-dig?
             // Simplification: If trapped, maybe just remove the enemy? Or let it try ghosting again soon.
             if (!foundTunnel) {
                 console.warn("Enemy emerged from ghosting into solid dirt and couldn't find tunnel!");
                 this.ghostCooldown = 10; // Try ghosting again quickly if stuck
             }
        }
         // Recalculate valid moves for tunnel-only movement
         this.makeMoveDecision(Math.round(this.x/TILE_SIZE), Math.round(this.y/TILE_SIZE));

    }

    startInflation() {
        if (this.state !== ENEMY_STATE.INFLATING) {
            this.state = ENEMY_STATE.INFLATING;
            this.inflationLevel = 1; // Start at first stage
            this.dx = 0; // Stop moving
            this.dy = 0;
        }
    }

    inflate() {
        if (this.state === ENEMY_STATE.INFLATING) {
            this.inflationLevel++;
            if (this.inflationLevel >= PUMP_MAX_INFLATION) {
                this.pop();
                return true; // Popped
            }
        }
        return false; // Not popped
    }

    deflate() {
        // Called when player stops pumping before pop
        if (this.state === ENEMY_STATE.INFLATING) {
            this.state = ENEMY_STATE.STUNNED;
            this.inflationLevel = 0;
            this.stunTimer = 120; // Stunned for 2 seconds (60fps)
        }
    }

    pop() {
        // Award score based on type and depth?
        score += (this.type === 'POOKA' ? 200 : 400) * level; // Basic score
        scoreDisplay.textContent = `Score: ${score}`;
        // Remove enemy from game
        const index = enemies.indexOf(this);
        if (index > -1) {
            enemies.splice(index, 1);
        }
        // Check for level clear
        if (enemies.length === 0) {
            gameState = GAME_STATE.LEVEL_CLEAR;
            // Add delay before next level starts
             setTimeout(nextLevel, 1500);
        }
    }

    crush() {
         // Award score (usually higher for rock kills)
         score += (this.type === 'POOKA' ? 500 : 800) * level;
         scoreDisplay.textContent = `Score: ${score}`;
         // Remove enemy
         const index = enemies.indexOf(this);
         if (index > -1) {
             enemies.splice(index, 1);
         }
          // Check for level clear
         if (enemies.length === 0) {
             gameState = GAME_STATE.LEVEL_CLEAR;
              setTimeout(nextLevel, 1500);
         }
    }

    draw() {
        let color = this.type === 'POOKA' ? COLORS.POOKA : COLORS.FYGAR;
        let eyeColor = COLORS.POOKA_EYES; // Same for both for simplicity
        let sizeFactor = 1.0;

        if (this.state === ENEMY_STATE.GHOSTING) {
            color = COLORS.ENEMY_GHOST;
            eyeColor = 'rgba(0,0,0,0.5)';
        } else if (this.state === ENEMY_STATE.INFLATING) {
            const inflateColorsPooka = [COLORS.POOKA, COLORS.INFLATE_1, COLORS.INFLATE_2, COLORS.INFLATE_3];
            const inflateColorsFygar = [COLORS.FYGAR, COLORS.FINFLATE_1, COLORS.FINFLATE_2, COLORS.FINFLATE_3];
            color = this.type === 'POOKA' ? inflateColorsPooka[this.inflationLevel] : inflateColorsFygar[this.inflationLevel];
            sizeFactor = 1.0 + this.inflationLevel * 0.15; // Grow slightly when inflated
        } else if (this.state === ENEMY_STATE.STUNNED) {
             // Maybe flash? Simple: slightly transparent
             ctx.globalAlpha = 0.7 + Math.sin(frameCount * 0.2) * 0.3;
        }

        const drawWidth = this.width * sizeFactor;
        const drawHeight = this.height * sizeFactor;
        const drawX = this.x - (drawWidth - this.width) / 2;
        const drawY = this.y - (drawHeight - this.height) / 2;


        ctx.fillStyle = color;
        // Pooka = Circle, Fygar = Rounded Rectangle?
        if (this.type === 'POOKA') {
            ctx.beginPath();
            ctx.arc(drawX + drawWidth / 2, drawY + drawHeight / 2, drawWidth / 2, 0, Math.PI * 2);
            ctx.fill();
             // Simple eyes
             ctx.fillStyle = eyeColor;
             ctx.fillRect(drawX + drawWidth * 0.3, drawY + drawHeight * 0.3, drawWidth * 0.15, drawHeight * 0.2);
             ctx.fillRect(drawX + drawWidth * 0.55, drawY + drawHeight * 0.3, drawWidth * 0.15, drawHeight * 0.2);
        } else { // Fygar = more rectangular
            ctx.fillRect(drawX, drawY, drawWidth, drawHeight);
             // Simple eyes
             ctx.fillStyle = eyeColor;
             ctx.fillRect(drawX + drawWidth * 0.3, drawY + drawHeight * 0.2, drawWidth * 0.15, drawHeight * 0.2);
             ctx.fillRect(drawX + drawWidth * 0.55, drawY + drawHeight * 0.2, drawWidth * 0.15, drawHeight * 0.2);
             // Fygar specific behavior would go here (like breathing fire)
        }

         ctx.globalAlpha = 1.0; // Reset alpha if changed
    }
}

// Fygar could be a subclass, but keeping it simple here. Add Fygar specific logic in Enemy class checks.
// Example: Add fire breathing logic within Enemy.update() if this.type === 'FYGAR'

class Rock {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * TILE_SIZE;
        this.y = row * TILE_SIZE;
        this.width = TILE_SIZE;
        this.height = TILE_SIZE;
        this.state = ROCK_STATE.STABLE;
        this.shakeTimer = 0;
        this.fallDistance = 0; // Pixels fallen
    }

    startShaking() {
        if (this.state === ROCK_STATE.STABLE) {
            this.state = ROCK_STATE.SHAKING;
            this.shakeTimer = ROCK_SHAKE_DURATION;
        }
    }

    update() {
        if (this.state === ROCK_STATE.SHAKING) {
            this.shakeTimer--;
            if (this.shakeTimer <= 0) {
                // Check again if ground below is clear before falling
                if (checkRockFallTrigger(this)) {
                     this.state = ROCK_STATE.FALLING;
                     this.y += 1; // Start moving down immediately
                     // Clear the rock's original grid space - crucial!
                     // grid[this.row][this.col] = 0; // NO! Rocks don't occupy grid space in this model, they sit on top
                } else {
                    this.state = ROCK_STATE.STABLE; // Condition changed, stop shaking
                }
            }
        } else if (this.state === ROCK_STATE.FALLING) {
            const fallAmount = ROCK_FALL_SPEED;
            this.y += fallAmount;
            this.fallDistance += fallAmount;

            const currentRockBottom = this.y + this.height;

            // Check collision with player while falling
            const playerCollider = {x: player.x, y: player.y, width: player.width, height: player.height};
            const rockCollider = {x: this.x, y: this.y, width: this.width, height: this.height};
            if (gameState === GAME_STATE.PLAYING && checkCollision(playerCollider, rockCollider)) {
                 player.die();
                 // Rock might continue falling or break - simplification: rock breaks on player hit?
                 // this.destroy(); return; // Stop further updates/drawing
            }

             // Check collision with enemies while falling
             let crushedEnemies = 0;
             enemies.slice().forEach(enemy => { // Use slice to iterate over a copy if crushing modifies the array
                 if (enemy.state !== ENEMY_STATE.INFLATING) { // Inflating enemies might be immune or pop?
                     const enemyCollider = {x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height};
                     if (checkCollision(enemyCollider, rockCollider)) {
                         enemy.crush();
                         crushedEnemies++;
                     }
                 }
             });

             // Scoring bonus for multiple enemies crushed? (Add later if needed)


            // Check if hit the ground (dirt or another rock)
             // Calculate the grid row the bottom of the rock is currently in or approaching
             const targetRow = Math.floor(currentRockBottom / TILE_SIZE);

             if (targetRow >= GRID_ROWS) { // Hit bottom of screen
                  this.destroy();
             } else if (isDirt(this.col, targetRow)) { // Hit dirt
                  this.destroy();
             } else {
                  // Check if landing on another rock
                  rocks.forEach(otherRock => {
                      if (otherRock !== this && otherRock.col === this.col && otherRock.row === targetRow) {
                           this.destroy(); // Hit another rock
                      }
                  });
             }
        } else if (this.state === ROCK_STATE.STABLE) {
             // Periodically check if it should start shaking (e.g., player digs nearby again)
             // This check is primarily done in digTunnel, but could add a redundant check here
             if(frameCount % 30 == 0){ // Check every half second
                 if(checkRockFallTrigger(this)){
                     this.startShaking();
                 }
             }
        }
    }

    draw() {
        let rockColor = COLORS.ROCK;
        let drawX = this.x;
        let drawY = this.y;

        if (this.state === ROCK_STATE.SHAKING) {
            rockColor = COLORS.ROCK_SHAKE;
            // Add slight visual shake
            drawX += Math.sin(frameCount * 0.5) * 2;
            drawY += Math.cos(frameCount * 0.7) * 1;
        } else if (this.state === ROCK_STATE.FALLING) {
            // Drawing handled by the updated this.y
        }

        ctx.fillStyle = rockColor;
        ctx.fillRect(drawX, drawY, this.width, this.height);
         // Add a simple border or detail
         ctx.strokeStyle = '#555';
         ctx.strokeRect(drawX, drawY, this.width, this.height);
    }

    destroy() {
         // Remove rock from the game after falling and hitting something
         const index = rocks.indexOf(this);
         if (index > -1) {
             rocks.splice(index, 1);
         }
         // Optionally leave rubble? (Simplification: just remove)
         // Add sound effect here if implementing audio
    }
}


// --- Game Initialization ---
function initGrid() {
    grid = [];
    for (let r = 0; r < GRID_ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < GRID_COLS; c++) {
            // Basic pattern: Mostly dirt, empty space near top center for player
             if (r < 2 || (r < 4 && c > GRID_COLS/2 - 3 && c < GRID_COLS/2 + 3) ) {
                 grid[r][c] = 0; // Tunnel at top
             } else {
                 grid[r][c] = 1; // Dirt
             }
        }
    }
}

function spawnPlayer() {
     player = new Player(Math.floor(GRID_COLS / 2), 1); // Start near top center
     player.canMove = true;
}

function spawnEnemies(numPooka, numFygar) {
    enemies = [];
    const enemyPositions = [ // Predefined potential start positions in tunnels
        {col: 2, row: 5}, {col: GRID_COLS - 3, row: 5},
        {col: 5, row: 8}, {col: GRID_COLS - 6, row: 8},
        {col: 3, row: 11}, {col: GRID_COLS - 4, row: 11},
    ];

    // Shuffle positions for variety
     enemyPositions.sort(() => Math.random() - 0.5);

     let spawnedCount = 0;
     for(let i=0; i<numPooka && spawnedCount < enemyPositions.length; i++){
         const pos = enemyPositions[spawnedCount];
         enemies.push(new Enemy(pos.col, pos.row, 'POOKA'));
         grid[pos.row][pos.col] = 0; // Ensure spawn point is a tunnel
          grid[pos.row+1][pos.col] = 0; // Dig below spawn point
           grid[pos.row][pos.col+1] = 0; // Dig right spawn point
            grid[pos.row][pos.col-1] = 0; // Dig left spawn point
         spawnedCount++;
     }
     for(let i=0; i<numFygar && spawnedCount < enemyPositions.length; i++){
         const pos = enemyPositions[spawnedCount];
         enemies.push(new Enemy(pos.col, pos.row, 'FYGAR'));
          grid[pos.row][pos.col] = 0; // Ensure spawn point is a tunnel
           grid[pos.row+1][pos.col] = 0; // Dig below spawn point
            grid[pos.row][pos.col+1] = 0; // Dig right spawn point
            grid[pos.row][pos.col-1] = 0; // Dig left spawn point
         spawnedCount++;
     }
}

function spawnRocks(numRocks) {
    rocks = [];
    let attempts = 0;
    const maxAttempts = numRocks * 10; // Prevent infinite loop

    while (rocks.length < numRocks && attempts < maxAttempts) {
        attempts++;
         // Try placing rocks deeper down, not too close to edges or player start
        const r = Math.floor(Math.random() * (GRID_ROWS - 6)) + 5; // Avoid top rows
        const c = Math.floor(Math.random() * (GRID_COLS - 4)) + 2; // Avoid side edges

        // Check if the position and the one below are dirt
        if (isDirt(c, r) && isDirt(c, r + 1)) {
             // Check if rock already exists there
             let collision = false;
             for(let rock of rocks){ if(rock.col === c && rock.row === r) { collision = true; break; }}
             // Check if it's near player start (crude check)
             if(r < 6 && c > GRID_COLS/2 - 4 && c < GRID_COLS/2 + 4) collision = true;

             if (!collision) {
                 rocks.push(new Rock(c, r));
                 // Don't convert grid space - rocks sit 'on top' of dirt conceptually
             }
        }
    }
    if(rocks.length < numRocks){ console.warn(`Could only place ${rocks.length} rocks`);}
}

function resetLevelState() {
     // Called when player dies but game continues
     spawnPlayer();
     // Reset enemy positions to initial spawn points (or near them)
     enemies.forEach(enemy => {
         enemy.x = enemy.spawnCol * TILE_SIZE + (TILE_SIZE - enemy.width) / 2;
         enemy.y = enemy.spawnRow * TILE_SIZE + (TILE_SIZE - enemy.height) / 2;
         enemy.state = ENEMY_STATE.ROAMING;
         enemy.inflationLevel = 0;
         enemy.dx = 0;
         enemy.dy = 0;
         enemy.ghostTimer = 0;
         enemy.ghostCooldown = Math.random() * 100 + ENEMY_GHOST_COOLDOWN;
         enemy.stunTimer = 0;
     });
     // Reset rocks that were falling? Or just let them finish? Let them finish.
     pump = null; // Ensure pump is reset
     messageDisplay.style.display = 'none';
}


function setupLevel(lvl) {
    frameCount = 0;
    initGrid(); // Create the dirt grid

    // Determine number of enemies based on level
    let numPooka = 2 + Math.floor(lvl / 2);
    let numFygar = 1 + Math.floor((lvl-1) / 2);
    let numRocks = 3 + Math.floor(lvl / 3);

    spawnRocks(numRocks); // Place rocks first
    spawnEnemies(numPooka, numFygar); // Place enemies in pre-defined tunnels
    spawnPlayer(); // Place player last

    // Update UI
    levelDisplay.textContent = `Level: ${lvl}`;
    livesDisplay.textContent = `Lives: ${lives}`;
    scoreDisplay.textContent = `Score: ${score}`;
    messageDisplay.style.display = 'none';

    gameState = GAME_STATE.PLAYING;
}

function nextLevel() {
    level++;
    // score += 1000; // Level completion bonus?
    setupLevel(level);
}

function resetGame() {
    score = 0;
    lives = 3;
    level = 1;
    setupLevel(level);
}


// --- Drawing Functions ---
function drawGrid() {
    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            if (grid[r][c] === 1) { // Dirt
                ctx.fillStyle = DIRT_COLORS[r] || COLORS.DIRT_LAYER_1; // Use depth color
                ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            } else { // Tunnel
                ctx.fillStyle = COLORS.TUNNEL;
                ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
}

function drawRocks() {
    rocks.forEach(rock => rock.draw());
}

function drawEnemies() {
    enemies.forEach(enemy => enemy.draw());
}

function drawPlayer() {
    if (player && player.canMove) { // Only draw if alive/active
        player.draw();
    }
}

// --- Game Loop ---
function update() {
    if (gameState !== GAME_STATE.PLAYING) {
        // Handle non-playing states (paused, game over, etc.)
         if(gameState === GAME_STATE.GAME_OVER){
              // Potentially flash game over message or add other effects
         }
        return; // Don't update game objects if not playing
    }

    player.update();
    enemies.forEach(enemy => enemy.update());
    rocks.forEach(rock => rock.update()); // Update rocks AFTER player/enemies move

     // Check rock stability after potential digging
     // This is partially handled in digTunnel, but a redundant check might be useful
     // rocks.forEach(rock => {
     //     if (rock.state === ROCK_STATE.STABLE && checkRockFallTrigger(rock)) {
     //         rock.startShaking();
     //     }
     // });
}

function draw() {
    // Clear canvas
    ctx.fillStyle = COLORS.BACKGROUND;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw game elements
    drawGrid();
    drawRocks(); // Draw rocks on top of grid
    drawEnemies();
    drawPlayer(); // Draw player last, potentially on top of tunnels/enemies

}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// --- Start Game ---
resetGame(); // Initialize first level
gameLoop(); // Start the loop

</script>

</body>
</html>