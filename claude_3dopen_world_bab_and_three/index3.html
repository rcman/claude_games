<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Open-World Survival Game</title>
    <style>
        /* ... (keep existing CSS) ... */
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            touch-action: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #000000;
            color: white;
            font-size: 24px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #ui {
            position: absolute;
            left: 10px;
            bottom: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #notification {
            position: absolute;
            left: 50%;
            top: 20%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            transition: opacity 0.5s;
        }
        #inventory {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 200px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .resource {
            margin: 5px 0;
        }
        #craftingMenu {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .craftButton {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 3px;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        /* Progress bars for health, hunger, thirst */
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin-top: 3px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.5s;
        }

        .health-bar-fill {
            background-color: #e74c3c;
        }

        .hunger-bar-fill {
            background-color: #f39c12;
        }

        .thirst-bar-fill {
            background-color: #3498db;
        }
    </style>
    <script src="babylon.js"></script>
    <script src="babylonjs.loaders.min.js"></script>
    <script src="babylonjs-gui.min.js"></script>
    <script src="babylonjs-materials.min.js"></script>
    </head>

<body>
    <div id="loadingScreen">Loading World...</div>
    <canvas id="renderCanvas"></canvas>
    <div id="controls">
        WASD - Move | Mouse - Look | E - Interact/Harvest<br>
        I - Inventory | C - Crafting | F - Toggle Fog<br>
        Left Click - Attack/Use Tool | Q - Drink | R - Eat Meat<br>
        Right Click / ESC - Cancel Placement
    </div>
    <div id="ui">
        Health: <span id="health">100</span>
        <div class="progress-bar">
            <div id="healthBar" class="progress-bar-fill health-bar-fill" style="width: 100%"></div>
        </div>

        Hunger: <span id="hunger">100</span>
        <div class="progress-bar">
            <div id="hungerBar" class="progress-bar-fill hunger-bar-fill" style="width: 100%"></div>
        </div>

        Thirst: <span id="thirst">100</span>
        <div class="progress-bar">
            <div id="thirstBar" class="progress-bar-fill thirst-bar-fill" style="width: 100%"></div>
        </div>

        Time: <span id="gameTime">Day</span>
    </div>
    <div id="inventory"></div>
    <div id="craftingMenu">
        <h3>Crafting</h3>
        <div id="craftingItems"></div>
        <button onclick="window.toggleCrafting()">Close</button>
    </div>
    <div id="notification"></div>

    <script>
        // CHANGE: Moved game variables and functions to global scope
        // or within a structure accessible globally, avoiding definition inside DOMContentLoaded

        // Game Configuration
        const CONFIG = {
            worldSize: 1000,
            treeDensity: 0.0008,
            rockDensity: 0.0006,
            grassDensity: 0.002,
            ironOreDensity: 0.0003,
            zincOreDensity: 0.0003,
            copperOreDensity: 0.0003,
            scrapMetalDensity: 0.0004,
            chickenDensity: 0.0002,
            rabbitDensity: 0.0003,
            deerDensity: 0.0001,
            barrelDensity: 0.0002,
            waterLevel: -5,
            fogEnabled: true,
            fogDensity: 0.005,
            dayLength: 600, // in seconds
        };

        // Game state
        const gameState = {
            isLoaded: false,
            inventory: {
                wood: 0, stone: 0, grass: 0, ironOre: 0, zincOre: 0, copperOre: 0,
                scrapMetal: 0, meat: 0, fat: 0, leather: 0, feathers: 0,
                rope: 0, metalIngot: 0 // Added craftable non-placeable items
            },
            tools: {
                axe: true, pickaxe: true, knife: true, canteen: true
            },
            health: 100, hunger: 100, thirst: 100,
            gameTime: 0, isDaytime: true,
            isInventoryOpen: false, isCraftingOpen: false,
            isPlacingItem: false, // State for placement mode
            placementRecipe: null, // Store recipe during placement
            placementPreviewMesh: null, // Store preview mesh
            placementListeners: [], // Store listeners to remove later
            placementValid: false // Added state for placement validity
        };

        // Crafting recipes
        const craftingRecipes = [
            // ... (keep existing recipes) ...
             { name: "Campfire", requirements: { wood: 10, stone: 5 }, result: "campfire", placeable: true, description: "Place on the ground to cook food and stay warm"},
             { name: "Wooden Wall", requirements: { wood: 15 }, result: "woodenWall", placeable: true, description: "Basic building material for creating structures" },
             { name: "Storage Box", requirements: { wood: 8, stone: 2 }, result: "storageBox", placeable: true, description: "Store excess resources and items" },
             { name: "Rope", requirements: { grass: 5 }, result: "rope", placeable: false, description: "Crafting material for more advanced items" },
             { name: "Metal Ingot", requirements: { ironOre: 2, scrapMetal: 1 }, result: "metalIngot", placeable: false, description: "Refined metal for crafting tools and structures" }
        ];

        // Entity tracking
        let entities = {
            trees: [], rocks: [], ores: [], animals: [], barrels: [], grass: [], placedItems: []
        };

        // Cached meshes for performance
        let cachedMeshes = {};

        // BabylonJS variables (will be initialized in createGame)
        let canvas, engine, scene, camera, hemisphericLight, directionalLight;
        let currentTarget = null; // Keep track of the interacted object

        // --- Core Game Functions ---

        // Main game creation function
        const createGame = function() {
            canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            scene = new BABYLON.Scene(engine);

            // Setup camera and controls
            camera = new BABYLON.UniversalCamera("playerCamera", new BABYLON.Vector3(0, 5, -10), scene); // Start a bit higher
            camera.setTarget(new BABYLON.Vector3(0, 2, 0));
            camera.attachControl(canvas, true);
            camera.inertia = 0.3;
            camera.speed = 0.5;
            camera.angularSensibility = 1000;
            camera.applyGravity = true;
            camera.checkCollisions = true;
            camera.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5); // Adjusted ellipsoid
             camera.minZ = 0.1; // Prevent clipping through near objects

            // First-person controls setup
            camera.keysUp = [87]; // W
            camera.keysDown = [83]; // S
            camera.keysLeft = [65]; // A
            camera.keysRight = [68]; // D
            // Disable default UP/DOWN movement if needed (jump/crouch handled differently?)
            // camera.keysUpward = [32]; // Space - Maybe handle jump separately
            // camera.keysDownward = [16]; // Shift

            // Apply collisions and gravity to camera for simplicity FOR NOW
            // Ideally, use a collider mesh, but this fixes the immediate structure
            camera.position = new BABYLON.Vector3(0, 5, -10); // Initial position


            // Lighting
            hemisphericLight = new BABYLON.HemisphericLight("hemisphericLight", new BABYLON.Vector3(0, 1, 0), scene);
            hemisphericLight.intensity = 0.7;

            directionalLight = new BABYLON.DirectionalLight("directionalLight", new BABYLON.Vector3(-0.5, -1, -0.5), scene);
            directionalLight.intensity = 0.7;
             // Add shadows (optional, can impact performance)
             // const shadowGenerator = new BABYLON.ShadowGenerator(1024, directionalLight);
             // shadowGenerator.useBlurExponentialShadowMap = true;
             // directionalLight.shadowMinZ = 1;
             // directionalLight.shadowMaxZ = 200;


            // Create ground
            const ground = createTerrain(scene);
            ground.checkCollisions = true;
             // ground.receiveShadows = true; // If using shadows

            // Skybox
            const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: CONFIG.worldSize * 1.5}, scene); // Slightly larger
            const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMaterial", scene);
            skyboxMaterial.backFaceCulling = false;
            // Ensure the skybox texture path is correct or use a valid online URL
            // Example local path (make sure 'textures/skybox_nx.jpg', etc. exist)
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
             // Alternate: skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/skybox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
             skyboxMaterial.disableLighting = true; // Sky doesn't need lighting
            skybox.material = skyboxMaterial;
             skybox.infiniteDistance = true; // Keep skybox centered on camera

            // Add fog
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            scene.fogColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            scene.fogDensity = CONFIG.fogEnabled ? CONFIG.fogDensity : 0; // Initial fog state

            // Create water
            createWater(scene, CONFIG.waterLevel);

            // Populate world
            populateWorld(scene); // This function now uses cachedMeshes

            // Interaction system
            setupInteractionSystem(scene, camera); // Pass camera

            // UI Updates (Initial call)
            updateUI();

            // Hide loading screen
            document.getElementById("loadingScreen").style.display = "none";
            gameState.isLoaded = true;

            // Start the render loop
            engine.runRenderLoop(function() {
                 if (!scene) return; // Ensure scene exists
                gameLoop(); // Call main game loop function
                scene.render();
            });

            // Handle window resize
            window.addEventListener('resize', function() {
                engine.resize();
            });
        };

        // --- Game Loop (called every frame) ---
        function gameLoop() {
            if (!gameState.isLoaded) return;

             const deltaTime = engine.getDeltaTime() / 1000.0; // Time since last frame in seconds

            // Update game time
            gameState.gameTime += deltaTime;

            // Day/Night cycle
            updateDayNightCycle(deltaTime);

            // Animal movement and AI
            updateAnimals(deltaTime);

            // Update player stats
            updatePlayerStats(deltaTime);

             // Update placement preview position if active
             updatePlacementPreview();

             // Update Interaction Target Highlight
             updateInteractionHighlight();
        }


        // --- Helper Functions ---

        // Create procedural terrain
        function createTerrain(scene) {
             // Placeholder heightmap data URL - Replace with your actual heightmap if needed
             // Ensure the base64 string or URL is valid and accessible
             const heightMapURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAAAAAB5Gfe6AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfkBRYQBivbXdnMAAALh0lEQVR42u3d67KlNg4AYGJyAwLv/7InsD+mZ2p3e86O7UiyJP9fzXRlN+BLLAPhvV6v1+v1er1er9fr9Xq9Xq/X6/V6vV6v1+v1er1er9fryur96+Ud/O+tPx8v77jbv76/Px7a0ed7gHlvJyDT3i8A0I8DTH2/AAC+HWBeXwGg7wDmfQWA4/T3BbD2xoDn9PcFQG/1jwWw9gX4r1f4sBc9FUBvCbD+Nn4qAHoG0F8AVkb/UAC9OsA6/mMB0CsD/Kd/MAC9JMCBvgPsR+DBAOQVAX7TfzCA9XQA2Ol7AfYeeDYAPZwByPQfDYAq6z8aQAH6jwbQKunXARD69b8OwFLSrwMg+PN/RQAD6lcCiKlfB+BQUq8EMEj/lQCCfP6vBxBFvxLAKKb/ugBDSP+FAYK0/gsDBOnXAZDZ/y8L4KtfByBq/i8M4LH+1wYI0P9agFP9OgBR8//CAD76lQDC9L8awDn9SgBRd//LAwTofzXAYfp1AIz1Xx/gRL8WQMz8vwHAMf1KAH76Xw6wd/2fr18JIGb+3wJgX7/P9N8AYN/56KdfC0BU//UBDs+EIvVrAQTtvzcAiA5vfjL7fy0Ay/TfBWCbficAJf23ATDSrwbgr/8hANvzb5l+JQBD/bcB2E6/E4Ce/vsAGKRfDcBL/0MAdmeBmfSrAXjpfwyAvvPRAjDTfw+APf1OAK76nwOwox+CZtATAMwYPQFg3vUoAVjqvweARfq1AGz13wTASL8agJ/+pwBszwPl9OsA8Gm/O4C+8QnCTL8agLX+WwBspd8JgJ/kGgCW6VcDsNf/AIAt/U4ADvofALChH6LS7wRgof8BAEP5tAlA9G9ZAFPe/wEANv0gdpvfFcD1APvdPxOAq/77AGzodwLw0X95gC39TgBO+i8O4KtfDcBP/7UB9t5fCMBP/5UBtvU7AXjqvzDAvn4nAFf91wVw1a8G4Kv/qgCu+tUAnPVfE8BXvxaAu/5LAnhP/1oA/vovCOCsXwvAX//lANz1qwEE6L8YgLt+NYAI/ZcCCNCvBBCj/0IAEfqVAIL0XwYgRL8SQJT+iwBE6NcCCNP/NIBtfiH6tQDi9D8MwIleKd9fvxpAoP7nAGyndyMcpF8NQFf/JQD29U9cIkS/FkCo/kcA7OmHHjwHjtKvBRCr/wEAe+6njA+OlHgAoPW/GGBf/xRR+jUA4vUHO9+5/o0tPKVfA8CAfyxAODtA2vwfDnA8/SuAR4GE3P5UfhRAH/1rAJT+IQCnzaA7ALBpH2KHANJOBaQACBoeGfTp1wCI42cDnLRD4gDi0m+vXwEgnh8KcNIOjQGI1z8FIKMd4gKk8BMBWPP/aIAJ86GQXhAgjZ8GkNQOcQBSph8XAKTxUwHSrrCYACn8FACU8FMB8q6wmwCIjN8AIO8KuwOA2PgNAPKusNsASIzfCiDpCrsFgNj4jQDyrrD7AIiL3w4g7Qq7D4Co+A0B0q6wewGIid8SIO8Kuw+AiPhtAfKusNsBiIffHEBg/HYAovlNuEUA8q6wGwKI5bdxLgCQdYXdEUAkvxGzDEDOFXZPAGH8VsZlANLm/6YAVP5JANLmv0z8NgAi+Q15pQASrrBbAxDNb0IsBJBwhd0bgBK/EbAYQMAVdmcAevwWuHIAeVfYrQHo8RvQCgDkXWH3BiDGbwCrAZB0hd0bgCS/OqwIQNoVdmsAkvy6sEIAaVfYnQFQ+VVZJQGS5v+dAYjxK6JKAuRdYfcGIMSvh1oAQGD8Vga6/GqkJQAyrrB7A9DjV0KtApB3hd0YgCy/CmodAJHxm9CL8itsFnUA8q6w2wIcbMo0+c83i3oAaVfYTQF2T+Ik+Q9Wi5oAeVfYPQH2zwJl+Xc3i7oAifP/fgBH55FS/Lt7B22AtCvshgBHFyLJixC7q0V9gLwr7H4AhzdiCPJvPxjTXwdgDPMnABw7X5Lj3365acBKANz4HwBweC+K+vxvbxanvAYA3PgfAHB8M0419vf2iyYAqfP/ZgDHt2ONw3Pb/XDUagDA548AOL4fbRyfe+vFoBcPQIg/BeDkiUDWCcSbXhwAKf4jgLMnYjm3kF/08gCE+E8Bzh4JZt0Dx3p5AAL8xwCnz0SzHgK8/uXxQCCH/xjg9KFw1lMQwJPFJP5DgPN5D+MhkEGrA4AS/wHA+UIBWI0ATS8KgBT/EcD5UhF4iwAkFQGAEv8hwPlygXtZbfuuL1EaAEL85wCnSyq3JWNTLwqABP8ZwOmyGpi34MBaRQAA8lwI4HxpkUlrRbDR8sBXLf0JEMf8AlVPE5w9LrL0kMjeSnOAt+8JAEf8EnVPVOw9L7O29/3UawHwzC9S+VTN0QNDy7P97adeCwBn+FINx8CcZ6b253/XywNAnH2RA3PXh8b2Jv3Fp16eB4QY2fNfGoBzelVnpPd6fOrlYRAvj/H89wFgNIdnj3eAowXfXi8PA3L2Pe3iUwDYcL0w/aVzxyvT2z28MlqeB3HiZ08DhPP+YUoB7OkfOz3A+3y3mQKMzQHm90QfAIC8Wo7UH36TmEK9RvrdAS/lF2s7ZsL7hE9ueeh07eLzFwq5KbQ84WtAR5cQ4b8JgPwUugDgBoDCFLoA4Mpm0AUA1wBcbg5dBMDv3AoAk/YJsv+Pr2WX6yp8ePCHTKELIeQLp4pAH1/MLtjHiM9/DQSF3yvvjm1P/5UtDGC3NrE3v7sQwF5tYm9+dyWAndrEnv+Lr78cgFVtYs//xddfD8CmNpHhf+3UVwSwqE3s+b/4+qsCGNcm9vxffP11AUxr1zj+L77+wgCGtYk9/xdff2UAu9rEnv+Lr784gE1tYs//xddfH+C8NrHn/+LrbwBwWpvY83/x9bcAOKpN7Pm/+PqbABzUJvb8X3z9VQD25S2MaZzXJvb8X3z9bQB2exjOaYxqE3v+L77+PgB7bcxzGpPaxJ7/i6+/E8BeI3NKY1Cb2PN/8fW3AjhsZo9pjGoTe/4vvv5eAMc97RGNen1kz//F198M4KSxPaxR6yP2/F98/d0AzlqbIxrVwQ/5xfi/+PrbAZwP/0GNWA+x5//i6+8HcHY+OqhRrY/Y83/x9TcEOPE/qhHrI/b8X3z9HQFO/I9qhPoIAMD8PQESahOcPnDxPQEyahN7/i++vgRA0AVVKPU7ABz514/fEyDnLpAQvwEAK3534ZEAQX1ggMuvPOsxAMd9YJ74AJD9/r8VQNAA8JwPANztvzcAyA6BzxUBgPv73y0Aok7Fz5UBxsX33wIgagDO5QGCuv+uAPxuwHkyQFDz3xaA3Q04TwbYH6xfGCBsAE5+ADHz3xSAPQDnuQBRd3+XBGAPwMmrA4B7978qAH8ATlYdANztvzJAyACcvdZ2VPNfHIAxACcrAwRWvy8HwB2Ak9MFCKx+Xw6APQCnRvP/igDcATiZXYDA6vcFAfgDcJLvTT8A4Pj7bwvAH4CTWgeCOvxfOgBwbw1IKwOE1f6uBiA0AIC8/v+kpv/1ADQAALy5/gBBxb8rAkQOAAA59f+43v8lAYIHALTO/z0AwgdA5/xv9Ph/8wDhA6Bx/+Nd/b8wQMIAJM//OwAkDID/+d9I7f3fPUDKAHgPgJgdwN0BkgZAZgCI6f/vDJA0ALwAQD/9f2MAlQHg3YuILv7cFSBtAKgBx7V/9wBIGwDa+R/1xs/dAAQHAJAuP7X1/54AwgMAEADitn/3AnAZwAHQD38vrv97GwCnAQTQD3+Px//dBMBpwDfg52/Ax/3/bgHgCwCvXq/X6/V6vV6v1+v1er1er9fr9Xq9Xq/X6/V6vV6vV0X9H0MnpBqxgI9qAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIwLTA1LTIyVDE2OjA2OjQzKzAwOjAwT8LnEAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMC0wNS0yMlQxNjowNjo0MyswMDowMD6fX6wAAAAASUVORK5CYII=";

            const groundOptions = {
                width: CONFIG.worldSize,
                height: CONFIG.worldSize,
                subdivisions: 100,
                minHeight: 0,
                maxHeight: 30,
                updatable: false // Keep false unless you need to query height directly from mesh later
            };

            // Create ground mesh using the heightmap URL
            const ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
                "ground",
                heightMapURL,
                groundOptions,
                scene
            );

            // Ground material
            const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.7, 0.3);
             groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Less shiny ground
            ground.material = groundMaterial;

            return ground;
        }

        // Create water
        function createWater(scene, waterLevel) {
            const waterMesh = BABYLON.MeshBuilder.CreateGround(
                "water",
                {width: CONFIG.worldSize * 1.5, height: CONFIG.worldSize * 1.5}, // Slightly larger
                scene
            );
            waterMesh.position.y = waterLevel;

            // Water material (Consider using BABYLON.WaterMaterial for better effects)
            const waterMaterial = new BABYLON.StandardMaterial("waterMaterial", scene);
            waterMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.7);
            waterMaterial.alpha = 0.8;
             waterMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.8); // Add some specular reflection
            waterMesh.material = waterMaterial;
             waterMesh.isPickable = false; // Water shouldn't block raycasts for interaction

            return waterMesh;
        }

        // Populate world with resources (using cached meshes)
        function populateWorld(scene) {
            // Create and cache base meshes ONCE
            cachedMeshes.tree = createTreeMesh(scene);
            cachedMeshes.rock = createRockMesh(scene);
            cachedMeshes.grass = createGrassMesh(scene);
            cachedMeshes.ironOre = createOreMesh(scene, new BABYLON.Color3(0.6, 0.6, 0.6));
            cachedMeshes.zincOre = createOreMesh(scene, new BABYLON.Color3(0.8, 0.8, 0.9));
            cachedMeshes.copperOre = createOreMesh(scene, new BABYLON.Color3(0.8, 0.5, 0.2));
            cachedMeshes.scrapMetal = createScrapMesh(scene);
            cachedMeshes.chicken = createAnimalMesh(scene, 0.5, "chicken"); // Pass type
            cachedMeshes.rabbit = createAnimalMesh(scene, 0.4, "rabbit");
            cachedMeshes.deer = createAnimalMesh(scene, 0.8, "deer");
            cachedMeshes.barrel = createBarrelMesh(scene); // Barrel Mesh
            cachedMeshes.campfire = createCampfireMesh(scene);
            cachedMeshes.woodenWall = createWallMesh(scene);
            cachedMeshes.storageBox = createStorageBoxMesh(scene);

            // Hide the original cached meshes (templates)
            for (const key in cachedMeshes) {
                if (cachedMeshes[key]) {
                    cachedMeshes[key].isVisible = false;
                    cachedMeshes[key].setEnabled(false); // Also disable them fully
                    // Ensure children are also disabled initially if they exist
                    cachedMeshes[key].getChildMeshes().forEach(child => child.setEnabled(false));
                }
            }

            // Generate instances of resources
            generateResources(scene);
        }

        // --- Mesh Creation Functions --- (Minor changes for consistency/naming)
        function createTreeMesh(scene) {
             const tree = new BABYLON.Mesh("treeRoot", scene); // Use a root node

             const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", { height: 6, diameter: 1 }, scene);
             trunk.material = new BABYLON.StandardMaterial("trunkMaterial", scene);
             trunk.material.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);
             trunk.parent = tree;

             const foliage = BABYLON.MeshBuilder.CreateSphere("foliage", { segments: 8, diameter: 6 }, scene);
             foliage.position.y = 5;
             foliage.scaling.y = 1.5;
             foliage.material = new BABYLON.StandardMaterial("foliageMaterial", scene);
             foliage.material.diffuseColor = new BABYLON.Color3(0.3, 0.6, 0.3);
             foliage.parent = tree;

             tree.name = "tree"; // Name the root node
             // Combine into a single mesh AFTER creating children and parenting
             // For thin instances, we actually need the GEOMETRY on the source mesh used for thinInstanceAdd
             // Let's merge trunk and foliage into the root 'tree' mesh itself.
             const mergedTree = BABYLON.Mesh.MergeMeshes([trunk, foliage], true, true, tree, false, true);
             if (mergedTree) {
                 mergedTree.name = "tree"; // Name the merged mesh
                 return mergedTree;
             } else {
                  // Fallback if merge fails - return the root (but thin instances might not work)
                  console.warn("Could not merge tree mesh for thin instancing.");
                  return tree;
             }
        }

        function createRockMesh(scene) {
            const rock = BABYLON.MeshBuilder.CreateSphere("rock", { segments: 5, diameter: 2 }, scene);
            rock.scaling = new BABYLON.Vector3(1, 0.7, 0.8);
            const rockMaterial = new BABYLON.StandardMaterial("rockMaterial", scene);
            rockMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
            rock.material = rockMaterial;
            rock.name = "rock"; // Mesh has geometry, good for thin instances
            return rock;
        }

        function createGrassMesh(scene) {
             const plane = BABYLON.MeshBuilder.CreatePlane("grassPlane", {width: 1, height: 1}, scene);
             const grassMaterial = new BABYLON.StandardMaterial("grassMaterial", scene);
             grassMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.2);
             grassMaterial.backFaceCulling = false; // See grass from both sides
             plane.material = grassMaterial;
             plane.name = "grass"; // Mesh has geometry
             return plane;
        }

        function createOreMesh(scene, color) {
            const ore = BABYLON.MeshBuilder.CreateSphere("ore", { segments: 5, diameter: 1.5 }, scene);
            ore.scaling = new BABYLON.Vector3(1, 0.5, 0.8);
            const oreMaterial = new BABYLON.StandardMaterial(`oreMaterial_${color.toHexString()}`, scene); // Unique material name
            oreMaterial.diffuseColor = color;
            oreMaterial.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            ore.material = oreMaterial;
             ore.name = "ore"; // Mesh has geometry
             // Store type in metadata if needed later, name is generic "ore"
             ore.metadata = { oreType: color.toHexString() }; // Example
            return ore;
        }

        function createScrapMesh(scene) {
            const scrap = BABYLON.MeshBuilder.CreateBox("scrap", { width: 1.5, height: 0.5, depth: 1.5 }, scene);
            const scrapMaterial = new BABYLON.StandardMaterial("scrapMaterial", scene);
            scrapMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            scrapMaterial.specularColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            scrap.material = scrapMaterial;
            scrap.name = "scrapMetal"; // Mesh has geometry
            return scrap;
        }

        function createAnimalMesh(scene, size, type) {
             const animalRoot = new BABYLON.Mesh(`${type}Root`, scene); // Use a root node

             const body = BABYLON.MeshBuilder.CreateSphere("animalBody", { segments: 8, diameter: 1 * size }, scene);
             body.parent = animalRoot;

             const head = BABYLON.MeshBuilder.CreateSphere("animalHead", { segments: 8, diameter: 0.5 * size }, scene);
             head.position.z = 0.7 * size;
             head.position.y = 0.2 * size;
             head.parent = animalRoot;

             const animalMaterial = new BABYLON.StandardMaterial(`${type}Material`, scene);
             animalMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.5);
             // Apply material to children
             body.material = animalMaterial;
             head.material = animalMaterial;

             animalRoot.name = type; // Name the root
             // DO NOT merge here if you want to use clone() later, keep root and children separate
             return animalRoot; // Return the root node (no geometry itself)
        }

        function createBarrelMesh(scene) {
             // Barrel is a single cylinder - it has geometry, so createInstance *could* work
             // but using clone for consistency with other placeables.
             const barrelRoot = new BABYLON.Mesh("barrelRoot", scene); // Use root for consistency
             const barrel = BABYLON.MeshBuilder.CreateCylinder("barrel", { height: 1.5, diameter: 1 }, scene);
             const barrelMaterial = new BABYLON.StandardMaterial("barrelMaterial", scene);
             barrelMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
             barrel.material = barrelMaterial;
             barrel.name = "barrelMesh"; // Give child a name
             barrel.parent = barrelRoot; // Parent the geometry mesh to the root
             barrelRoot.name = "barrel"; // Name the root
             return barrelRoot; // Return the root
        }

        function createCampfireMesh(scene) {
             const campfireRoot = new BABYLON.Mesh("campfireRoot", scene); // Use a root node

             const logs = BABYLON.MeshBuilder.CreateCylinder("logs", { height: 0.3, diameter: 1.5 }, scene);
             logs.material = new BABYLON.StandardMaterial("logMaterial", scene);
             logs.material.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0.1);
             logs.parent = campfireRoot;

             const stones = [];
             const stoneMaterial = new BABYLON.StandardMaterial("stoneMaterial", scene);
             stoneMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
             for (let i = 0; i < 8; i++) {
                 const stone = BABYLON.MeshBuilder.CreateSphere(`stone${i}`, { segments: 4, diameter: 0.3 }, scene);
                 const angle = i * Math.PI / 4;
                 stone.position.x = Math.cos(angle) * 0.8;
                 stone.position.z = Math.sin(angle) * 0.8;
                 stone.position.y = -0.1;
                 stone.material = stoneMaterial;
                 stone.parent = campfireRoot;
                 stones.push(stone);
             }

             // Fire - Consider particle system for better effect
             const fire = BABYLON.MeshBuilder.CreateCylinder("fire", { height: 0.5, diameter: 0.8, diameterTop: 0 }, scene);
             fire.position.y = 0.4;
             const fireMaterial = new BABYLON.StandardMaterial("fireMaterial", scene);
             fireMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
             fireMaterial.emissiveColor = new BABYLON.Color3(1, 0.5, 0); // Make it glow
             fire.material = fireMaterial;
             fire.parent = campfireRoot;

             campfireRoot.name = "campfire";
             return campfireRoot; // Return root node
        }

        function createWallMesh(scene) {
             const wallRoot = new BABYLON.Mesh("wallRoot", scene); // Root node

             const wall = BABYLON.MeshBuilder.CreateBox("wallMesh", { width: 3, height: 2, depth: 0.2 }, scene); // Name child
             wall.parent = wallRoot;

             const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", scene);
             wallMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);

             // Simpler wood texture or use an image texture
             // Make sure 'textures/wood.jpg' exists relative to index2.html or use absolute URL
             try {
                 const woodGrainTexture = new BABYLON.Texture("textures/wood.jpg", scene, true, true, BABYLON.Texture.NEAREST_SAMPLINGMODE,
                    () => {}, // success callback
                    (message, exception) => { console.warn("Wood texture failed to load:", message); } // error callback
                 );
                 wallMaterial.diffuseTexture = woodGrainTexture;
             } catch (e) {
                  console.warn("Error creating wood texture:", e);
             }


             wall.material = wallMaterial;
             wallRoot.name = "woodenWall";
             return wallRoot; // Return root node
        }

        function createStorageBoxMesh(scene) {
             const boxRoot = new BABYLON.Mesh("storageBoxRoot", scene); // Root node

             const box = BABYLON.MeshBuilder.CreateBox("storageBoxMesh", { width: 1.5, height: 1, depth: 1.5 }, scene); // Name child
             box.parent = boxRoot;
             const lid = BABYLON.MeshBuilder.CreateBox("lid", { width: 1.6, height: 0.2, depth: 1.6 }, scene);
             lid.position.y = 0.6;
             lid.parent = boxRoot;

             const boxMaterial = new BABYLON.StandardMaterial("boxMaterial", scene);
             boxMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.35, 0.15);
             box.material = boxMaterial;
             const lidMaterial = new BABYLON.StandardMaterial("lidMaterial", scene);
             lidMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
             lid.material = lidMaterial;

             const metalMaterial = new BABYLON.StandardMaterial("metalMaterial", scene);
             metalMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
             metalMaterial.specularColor = new BABYLON.Color3(0.7, 0.7, 0.7);

             const metalHinge1 = BABYLON.MeshBuilder.CreateBox("hinge1", { width: 0.1, height: 0.1, depth: 0.3 }, scene);
             metalHinge1.position = new BABYLON.Vector3(-0.7, 0.5, 0.5);
             metalHinge1.material = metalMaterial;
             metalHinge1.parent = boxRoot;

             const metalHinge2 = BABYLON.MeshBuilder.CreateBox("hinge2", { width: 0.1, height: 0.1, depth: 0.3 }, scene);
             metalHinge2.position = new BABYLON.Vector3(-0.7, 0.5, -0.5);
             metalHinge2.material = metalMaterial;
             metalHinge2.parent = boxRoot;

             const lock = BABYLON.MeshBuilder.CreateBox("lock", { width: 0.2, height: 0.2, depth: 0.1 }, scene);
             lock.position = new BABYLON.Vector3(0.7, 0.5, 0);
             lock.material = metalMaterial;
             lock.parent = boxRoot;

             boxRoot.name = "storageBox";
             return boxRoot; // Return root node
        }


        // --- Resource Generation ---
        function generateResources(scene) {
            const worldHalfSize = CONFIG.worldSize / 2;

             // CRITICAL FIX: Function to get actual terrain height using raycasting
            function getRealTerrainHeight(x, z, defaultHeight = 0) {
                const groundMesh = scene.getMeshByName("ground");
                if (!groundMesh) return defaultHeight; // Ground not found

                // Cast ray downwards from above the expected max height
                 const ray = new BABYLON.Ray(new BABYLON.Vector3(x, 50, z), new BABYLON.Vector3(0, -1, 0));
                 const hit = scene.pickWithRay(ray, (mesh) => mesh === groundMesh); // Only pick the ground

                 if (hit && hit.pickedPoint) {
                     return hit.pickedPoint.y;
                 }
                 return defaultHeight; // Fallback if ray misses ground (e.g., outside bounds)
             }


             // Use Thin Instances for performance (Trees, Rocks, Grass, Ores)
             const treeMatrices = [];
             const rockMatrices = [];
             const grassMatrices = [];
             const ironOreMatrices = [];
             const zincOreMatrices = [];
             const copperOreMatrices = [];
             const scrapMatrices = [];

            // Place Trees
             const treeSourceMesh = cachedMeshes.tree; // Mesh MUST have geometry for thin instances
             if (treeSourceMesh && treeSourceMesh.geometry) {
                const treeCount = Math.floor(CONFIG.worldSize * CONFIG.worldSize * CONFIG.treeDensity);
                for (let i = 0; i < treeCount; i++) {
                    const x = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const z = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const y = getRealTerrainHeight(x, z); // Use real height
                    if (y > CONFIG.waterLevel + 1) {
                         const scale = 0.7 + Math.random() * 0.6;
                         const matrix = BABYLON.Matrix.Compose(
                             new BABYLON.Vector3(scale, 0.8 + Math.random() * 0.4, scale), // Scaling
                             BABYLON.Quaternion.RotationYawPitchRoll(Math.random() * Math.PI * 2, 0, 0), // Rotation
                             new BABYLON.Vector3(x, y, z) // Position (at correct terrain height)
                         );
                         treeMatrices.push(matrix);
                         entities.trees.push({
                             position: new BABYLON.Vector3(x, y, z),
                             health: 100,
                             resources: { wood: 10 + Math.floor(Math.random() * 5) },
                             matrixIndex: treeMatrices.length - 1,
                             meshCacheKey: 'tree' // Link entity data to the matrix buffer index and cache key
                         });
                    }
                }
                treeSourceMesh.thinInstanceAdd(treeMatrices); // Apply matrices
             } else {
                  console.error("Cannot place trees: Source tree mesh has no geometry or is missing.");
             }


            // Place Rocks
            const rockSourceMesh = cachedMeshes.rock;
             if (rockSourceMesh && rockSourceMesh.geometry) {
                const rockCount = Math.floor(CONFIG.worldSize * CONFIG.worldSize * CONFIG.rockDensity);
                for (let i = 0; i < rockCount; i++) {
                    const x = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const z = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const y = getRealTerrainHeight(x, z); // Use real height
                    if (y > CONFIG.waterLevel) {
                         const scaleX = 0.8 + Math.random() * 0.8;
                         const scaleY = 0.6 + Math.random() * 0.6;
                         const scaleZ = 0.8 + Math.random() * 0.7;
                         const matrix = BABYLON.Matrix.Compose(
                             new BABYLON.Vector3(scaleX, scaleY, scaleZ),
                             BABYLON.Quaternion.RotationYawPitchRoll(Math.random() * Math.PI * 2, 0, 0),
                             new BABYLON.Vector3(x, y, z) // Position at correct height
                         );
                         rockMatrices.push(matrix);
                         entities.rocks.push({
                             position: new BABYLON.Vector3(x, y, z),
                             health: 100,
                             resources: { stone: 5 + Math.floor(Math.random() * 5) },
                             matrixIndex: rockMatrices.length - 1,
                             meshCacheKey: 'rock'
                         });
                    }
                }
                 rockSourceMesh.thinInstanceAdd(rockMatrices);
             } else {
                  console.error("Cannot place rocks: Source rock mesh has no geometry or is missing.");
             }


             // Place Ores using helper function
             placeOres("ironOre", CONFIG.ironOreDensity, ironOreMatrices);
             placeOres("zincOre", CONFIG.zincOreDensity, zincOreMatrices);
             placeOres("copperOre", CONFIG.copperOreDensity, copperOreMatrices);

             if(cachedMeshes.ironOre?.geometry) cachedMeshes.ironOre.thinInstanceAdd(ironOreMatrices); else console.error("IronOre mesh missing geometry");
             if(cachedMeshes.zincOre?.geometry) cachedMeshes.zincOre.thinInstanceAdd(zincOreMatrices); else console.error("ZincOre mesh missing geometry");
             if(cachedMeshes.copperOre?.geometry) cachedMeshes.copperOre.thinInstanceAdd(copperOreMatrices); else console.error("CopperOre mesh missing geometry");


            // Place Scrap Metal
            const scrapSourceMesh = cachedMeshes.scrapMetal;
             if (scrapSourceMesh && scrapSourceMesh.geometry) {
                const scrapCount = Math.floor(CONFIG.worldSize * CONFIG.worldSize * CONFIG.scrapMetalDensity);
                for (let i = 0; i < scrapCount; i++) {
                    const x = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const z = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const y = getRealTerrainHeight(x, z); // Use real height
                     if (y > CONFIG.waterLevel) {
                         const matrix = BABYLON.Matrix.Compose(
                             new BABYLON.Vector3(1, 1, 1), // Scaling
                             BABYLON.Quaternion.RotationYawPitchRoll(Math.random() * Math.PI * 2, 0, 0), // Rotation
                             new BABYLON.Vector3(x, y, z) // Position
                         );
                         scrapMatrices.push(matrix);
                         entities.ores.push({ // Group scrap with ores for interaction logic? Or separate array?
                             type: "scrapMetal",
                             position: new BABYLON.Vector3(x, y, z),
                             health: 100,
                             resources: { scrapMetal: 3 + Math.floor(Math.random() * 3) },
                             matrixIndex: scrapMatrices.length - 1,
                             meshCacheKey: 'scrapMetal' // Store which cache key it belongs to
                         });
                     }
                }
                 scrapSourceMesh.thinInstanceAdd(scrapMatrices);
             } else {
                  console.error("Cannot place scrap: Source scrap mesh has no geometry or is missing.");
             }


             // Place Grass
             const grassSourceMesh = cachedMeshes.grass;
              if (grassSourceMesh && grassSourceMesh.geometry) {
                 const grassCount = Math.floor(CONFIG.worldSize * CONFIG.worldSize * CONFIG.grassDensity);
                 for (let i = 0; i < grassCount; i++) {
                     const x = Math.random() * CONFIG.worldSize - worldHalfSize;
                     const z = Math.random() * CONFIG.worldSize - worldHalfSize;
                     const y = getRealTerrainHeight(x, z); // Use real height
                     if (y > CONFIG.waterLevel) {
                         const matrix = BABYLON.Matrix.Compose(
                             new BABYLON.Vector3(1, 1, 1),
                             BABYLON.Quaternion.RotationYawPitchRoll(Math.random() * Math.PI * 2, 0, 0),
                             new BABYLON.Vector3(x, y + 0.5, z) // Position slightly above ground
                         );
                         grassMatrices.push(matrix);
                         entities.grass.push({
                             position: new BABYLON.Vector3(x, y + 0.5, z),
                             health: 100, // Can be harvested
                             resources: { grass: 1 + Math.floor(Math.random() * 2) },
                             matrixIndex: grassMatrices.length - 1,
                             meshCacheKey: 'grass'
                         });
                     }
                 }
                 grassSourceMesh.thinInstanceAdd(grassMatrices);
                 // Optional: Make grass billboards face the camera
                 // grassSourceMesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_Y;
             } else {
                  console.error("Cannot place grass: Source grass mesh has no geometry or is missing.");
             }



             // Place Animals (using Clones, not instances, as they need individual logic/movement and root has no geometry)
            placeAnimals("chicken", CONFIG.chickenDensity);
            placeAnimals("rabbit", CONFIG.rabbitDensity);
            placeAnimals("deer", CONFIG.deerDensity);

            // Place Barrels (using Clones for consistency)
            const barrelCount = Math.floor(CONFIG.worldSize * CONFIG.worldSize * CONFIG.barrelDensity);
            for (let i = 0; i < barrelCount; i++) {
                const x = Math.random() * CONFIG.worldSize - worldHalfSize;
                const z = Math.random() * CONFIG.worldSize - worldHalfSize;
                const y = getRealTerrainHeight(x, z); // Use real height

                if (y > CONFIG.waterLevel && cachedMeshes.barrel) {
                     // FIX: Use clone instead of createInstance for meshes without geometry on root
                    const barrel = cachedMeshes.barrel.clone(`barrel_${i}`, null); // Clone the root node

                    if (!barrel) continue; // Skip if clone creation failed

                     // Enable the clone itself and its children
                     barrel.setEnabled(true);
                     barrel.getChildMeshes().forEach(child => child.setEnabled(true)); // Make sure geometry is visible

                     barrel.isPickable = true; // Make the root pickable for interaction

                    barrel.position = new BABYLON.Vector3(x, y + 0.75, z); // Position correctly on ground


                    const loot = {};
                    if (Math.random() < 0.5) loot.wood = 1 + Math.floor(Math.random() * 3);
                    if (Math.random() < 0.3) loot.stone = 1 + Math.floor(Math.random() * 2);
                    if (Math.random() < 0.2) loot.scrapMetal = 1 + Math.floor(Math.random() * 2);
                    if (Math.random() < 0.1) loot.ironOre = 1;

                    entities.barrels.push({
                        mesh: barrel, // Direct reference to the clone root
                        type: "barrel",
                        position: barrel.position.clone(),
                        health: 100,
                        resources: loot
                    });
                }
            }

            // Helper function to place ores (populates matrix buffer and entity data)
            function placeOres(oreType, density, matrixBuffer) {
                 const oreSourceMesh = cachedMeshes[oreType];
                 if (!oreSourceMesh || !oreSourceMesh.geometry) {
                     console.error(`Cannot place ${oreType}: Source mesh missing or has no geometry.`);
                     return;
                 }
                const oreCount = Math.floor(CONFIG.worldSize * CONFIG.worldSize * density);
                for (let i = 0; i < oreCount; i++) {
                    const x = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const z = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const y = getRealTerrainHeight(x, z); // Use real height

                    if (y > CONFIG.waterLevel) {
                         const scaleX = 0.7 + Math.random() * 0.6;
                         const scaleY = 0.5 + Math.random() * 0.3;
                         const scaleZ = 0.7 + Math.random() * 0.5;
                         const matrix = BABYLON.Matrix.Compose(
                             new BABYLON.Vector3(scaleX, scaleY, scaleZ),
                             BABYLON.Quaternion.RotationYawPitchRoll(Math.random() * Math.PI * 2, 0, 0),
                             new BABYLON.Vector3(x, y, z) // Position
                         );
                         matrixBuffer.push(matrix);

                         const resources = {};
                         resources[oreType] = 3 + Math.floor(Math.random() * 4);

                         entities.ores.push({
                             type: oreType,
                             position: new BABYLON.Vector3(x, y, z),
                             health: 100,
                             resources: resources,
                             matrixIndex: matrixBuffer.length - 1,
                             meshCacheKey: oreType // Store which cache key it belongs to
                         });
                    }
                }
            }

            // Helper function to place animals (creates clones)
            function placeAnimals(animalType, density) {
                 const cacheKey = animalType; // e.g., 'chicken', 'rabbit'
                if (!cachedMeshes[cacheKey]) {
                    console.warn(`Cached mesh for ${animalType} not found.`);
                    return;
                }
                const animalCount = Math.floor(CONFIG.worldSize * CONFIG.worldSize * density);
                for (let i = 0; i < animalCount; i++) {
                    const x = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const z = Math.random() * CONFIG.worldSize - worldHalfSize;
                    const y = getRealTerrainHeight(x, z); // Use real height

                    if (y > CONFIG.waterLevel) {
                         // FIX: Use clone instead of createInstance for meshes without geometry on root
                        const animal = cachedMeshes[cacheKey].clone(`${animalType}_${i}`, null); // Clone the root

                         if (!animal) continue; // Skip if clone creation failed

                         // Enable the clone itself and its children
                         animal.setEnabled(true);
                         animal.getChildMeshes().forEach(child => child.setEnabled(true));

                         animal.isPickable = true; // Make the root interactable

                        animal.position = new BABYLON.Vector3(x, y + 0.5, z); // Adjust Y based on animal size/origin


                        const resources = { meat: 1 + Math.floor(Math.random() * 3) };
                        if (animalType === "chicken") resources.feathers = 2 + Math.floor(Math.random() * 2);
                        else if (animalType === "rabbit") resources.leather = 1;
                        else if (animalType === "deer") {
                            resources.leather = 2 + Math.floor(Math.random() * 2);
                            resources.fat = 1 + Math.floor(Math.random() * 2);
                        }

                        entities.animals.push({
                            mesh: animal, // Direct reference to the clone root
                            type: animalType,
                            position: animal.position.clone(),
                            health: 100,
                            resources: resources,
                            speed: 0.5 + Math.random() * 1.5, // Adjusted speed (units per second)
                            movementTimer: 0,
                            isMoving: false, // Add state for movement
                            movementDirection: new BABYLON.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize()
                        });
                    }
                }
            }
        }


        // --- Interaction System ---
        function setupInteractionSystem(scene, camera) {
            const INTERACTION_DISTANCE = 5;
             let lastHighlightedEntity = null; // Keep track of the last highlighted one

             // Find the actual entity data associated with a picked mesh (handles clones, instances, thin instances)
             function getEntityFromPick(pickInfo) {
                 if (!pickInfo || !pickInfo.pickedMesh) return null;

                 const pickedMesh = pickInfo.pickedMesh;

                  // --- Thin Instance Handling ---
                 // FIX: Use thinInstanceIndex if available (preferred) or calculate based on pickedPoint
                 if (pickedMesh.hasThinInstances && pickInfo.thinInstanceIndex !== undefined && pickInfo.thinInstanceIndex >= 0) {
                     const instanceId = pickInfo.thinInstanceIndex;
                     const meshCacheKey = pickedMesh.name; // Assumes source mesh name matches cache key
                     const entityArray = entities.trees.concat(entities.rocks, entities.ores, entities.grass);
                     return entityArray.find(e => e.meshCacheKey === meshCacheKey && e.matrixIndex === instanceId);
                 }
                 // Fallback for older versions or specific setups (less reliable)
                 /* else if (pickedMesh.hasThinInstances && pickInfo.faceId !== undefined) {
                      // Finding instance by faceId or pickedPoint is complex and less reliable
                      // For now, prioritize thinInstanceIndex check.
                 } */


                  // --- Regular Mesh / Clone Handling ---
                 else {
                      // Check if the picked mesh itself is a tracked entity root (clone or simple mesh)
                     const directMatch = findEntityByMesh(pickedMesh);
                     if (directMatch) return directMatch;

                      // Check if a parent of the picked mesh is a tracked entity root (for children of clones)
                     let parent = pickedMesh.parent;
                     while (parent) {
                         const parentMatch = findEntityByMesh(parent);
                         if (parentMatch) return parentMatch;
                         parent = parent.parent;
                     }
                 }

                 return null; // No matching entity found
             }

             // Helper to find entity matching a specific mesh reference
             function findEntityByMesh(meshToFind) {
                  const entityArrays = [entities.animals, entities.barrels, entities.placedItems]; // Arrays with direct mesh references
                  for (const arr of entityArrays) {
                      const entity = arr.find(e => e.mesh === meshToFind);
                      if (entity) return entity;
                  }
                  return null;
             }

             // Function to apply/remove highlight (handles standard materials)
             function setHighlight(entity, highlight) {
                  if (!entity || !entity.mesh || entity.mesh.hasThinInstances) return; // Don't highlight thin instances this way

                  const highlightColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                  const blackColor = BABYLON.Color3.Black();

                  // Function to apply highlight to a mesh's material
                  const applyHighlightToMesh = (mesh) => {
                      if (!mesh || !mesh.material) return;
                      // Ensure material is StandardMaterial and has emissiveColor
                      if (mesh.material instanceof BABYLON.StandardMaterial) {
                           // Clone material ONLY if different highlights needed simultaneously (unlikely here)
                           // mesh.material = mesh.material.clone(`${mesh.name}_highlightMat`);
                          mesh.material.emissiveColor = highlight ? highlightColor : blackColor;
                      }
                  };

                  // Apply to the root mesh
                  applyHighlightToMesh(entity.mesh);
                  // Apply to children as well (important for clones)
                  entity.mesh.getChildMeshes().forEach(child => applyHighlightToMesh(child));
             }


             // Raycast moved to main loop for highlight update
             window.updateInteractionHighlight = () => { // Make globally accessible for the loop
                 if (!camera || !scene || gameState.isPlacingItem) { // Don't highlight during placement
                      // Clear previous highlight if any
                     if (lastHighlightedEntity) {
                         setHighlight(lastHighlightedEntity, false);
                     }
                     lastHighlightedEntity = null;
                     currentTarget = null;
                     return;
                 };

                 const ray = camera.getForwardRay(INTERACTION_DISTANCE);
                 const hit = scene.pickWithRay(ray, (mesh) => {
                     // Basic check: is it pickable and enabled? Check root and children state?
                     // Pickability usually checked on the specific mesh hit.
                     return mesh.isPickable && mesh.isEnabled();
                 });

                 let newTargetEntity = getEntityFromPick(hit); // Use helper to find entity


                  // --- Update Highlighting ---
                  if (newTargetEntity !== lastHighlightedEntity) {
                      // Remove highlight from the old entity
                      if (lastHighlightedEntity) {
                           setHighlight(lastHighlightedEntity, false);
                      }

                      // Add highlight to the new entity
                      if (newTargetEntity) {
                          setHighlight(newTargetEntity, true);
                      }

                      lastHighlightedEntity = newTargetEntity;
                      currentTarget = newTargetEntity; // Update the globally tracked target
                  }
             };


            // Handle interaction (E key)
            scene.onKeyboardObservable.add((kbInfo) => {
                 if (gameState.isPlacingItem) return; // Ignore keys during placement

                if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
                    switch (kbInfo.event.key.toLowerCase()) { // Use toLowerCase for consistency
                        case 'e':
                            if (currentTarget) {
                                interactWith(currentTarget);
                            }
                            break;
                        case 'i':
                            toggleInventory();
                            break;
                        case 'c':
                            toggleCrafting();
                            break;
                        case 'f':
                            toggleFog();
                            break;
                         case 'q': // Drink
                             drinkWater();
                             break;
                         case 'r': // Eat
                             eatFood('meat');
                             break;
                    }
                }
            });

            // Mouse click for attacking/using tools or placement
            scene.onPointerObservable.add((pointerInfo) => {
                 if (gameState.isPlacingItem) { // Handle placement click
                      if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) { // Left Click
                          confirmPlacement();
                      }
                      // Right click cancel handled by ESC key now for consistency
                      return; // Don't process harvesting clicks during placement
                 }

                // Regular interaction click
                 if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) { // Left Click
                    if (currentTarget) {
                        interactWith(currentTarget);
                    }
                }
            });

             // Handle ESC key for cancelling placement / closing menus
             scene.onKeyboardObservable.add((kbInfo) => {
                 if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN && kbInfo.event.key === "Escape") {
                     if (gameState.isPlacingItem) {
                         cancelPlacement();
                     } else if (gameState.isInventoryOpen) {
                          toggleInventory();
                     } else if (gameState.isCraftingOpen) {
                          toggleCrafting();
                     } else {
                          // Optional: Add pause menu toggle or other ESC behavior here
                     }
                 }
             });


            // Central interaction function
            function interactWith(entity) {
                // Determine action based on entity type (harvest, open, etc.)
                 // For now, assume all interactions are harvesting/damaging
                harvestResource(entity);
            }

            // Function to harvest a resource
            function harvestResource(entity) {
                 if (!entity || entity.health <= 0) return; // Already destroyed or invalid

                 // Determine damage and tool needed
                 let damage = 5; // Base damage
                 let requiredTool = null;
                 let canHarvest = false;
                 // Use entity.type (set during creation/placement) or derive from meshCacheKey/name if needed
                 const entityType = entity.type || entity.meshCacheKey || entity.mesh?.name?.split('_')[0];

                 if (entityType === 'tree') {
                     requiredTool = 'axe'; damage = gameState.tools.axe ? 25 : 5; canHarvest = true;
                 } else if (entityType === 'rock' || entityType?.includes('Ore') || entityType === 'scrapMetal') {
                     requiredTool = 'pickaxe'; damage = gameState.tools.pickaxe ? 20 : 5; canHarvest = true;
                 } else if (entityType === 'chicken' || entityType === 'rabbit' || entityType === 'deer') {
                     requiredTool = 'knife'; damage = gameState.tools.knife ? 30 : 10; canHarvest = true; // Animals can be damaged without knife, but less effectively
                 } else if (entityType === 'barrel' || entityType === 'grass') {
                     canHarvest = true; // No specific tool needed, just base damage
                 } else if (entityType === 'campfire' || entityType === 'woodenWall' || entityType === 'storageBox') {
                      // Placed items might require tools to deconstruct
                      requiredTool = 'axe'; // Example: Axe for wood items
                      damage = gameState.tools.axe ? 15 : 3;
                      canHarvest = true;
                 }


                 if (canHarvest) {
                     entity.health -= damage;
                     // TODO: Add visual/audio feedback (hit effect, sound)

                     if (entity.health <= 0) {
                         // --- Resource Collection ---
                         let collected = [];
                         if (entity.resources) { // Check if resources exist
                            for (const resource in entity.resources) {
                                gameState.inventory[resource] = (gameState.inventory[resource] || 0) + entity.resources[resource];
                                collected.push(`${entity.resources[resource]} ${resource}`);
                            }
                            if(collected.length > 0) {
                                showNotification(`Collected: ${collected.join(', ')}`);
                            }
                         }


                         // --- Remove Entity ---
                          // Thin Instance Removal (use scaling to zero to avoid index issues)
                          if (entity.matrixIndex !== undefined && entity.meshCacheKey) {
                              const sourceMesh = cachedMeshes[entity.meshCacheKey];
                              if (sourceMesh && sourceMesh.thinInstanceSetMatrixAt) {
                                   const zeroMatrix = BABYLON.Matrix.Scaling(0.001, 0.001, 0.001); // Use near-zero scale
                                   sourceMesh.thinInstanceSetMatrixAt(entity.matrixIndex, zeroMatrix, true); // Refresh buffer
                                   // Note: Entity data remains, but object is effectively gone visually & for picking
                              }
                          }
                          // Regular Instance/Clone Removal:
                          else if (entity.mesh) {
                              entity.mesh.dispose(); // Dispose the mesh and its children
                          }

                         // Remove from entities tracking array
                         let found = false;
                         for (const key in entities) {
                              const arr = entities[key];
                              const index = arr.indexOf(entity); // Find direct reference
                             if (index !== -1) {
                                 arr.splice(index, 1);
                                 found = true;
                                 break;
                             }
                         }

                         // Clear target if it was the destroyed entity
                         if (currentTarget === entity) {
                              if (lastHighlightedEntity === entity) { // Also clear highlight if it was highlighted
                                  lastHighlightedEntity = null;
                              }
                             currentTarget = null;
                         }

                         updateUI(); // Update inventory display
                     } else {
                          // Optional: Show damage indicator or health reduction effect
                     }
                 } else if (requiredTool && !gameState.tools[requiredTool]) {
                     showNotification(`Requires ${requiredTool}`);
                 } else {
                      showNotification("Cannot harvest this.");
                 }
            }
        }

         // --- Day/Night Cycle ---
         function updateDayNightCycle(deltaTime) {
             const cycleProgress = (gameState.gameTime % CONFIG.dayLength) / CONFIG.dayLength; // 0 to 1

             const dayStart = 0.25; // Sunrise starts
             const dayEnd = 0.75;   // Sunset starts
             const nightIntensity = 0.1;
             const maxSunIntensity = 1.0; // Combined max intensity for Hemispheric + Directional

             let currentHemiIntensity = nightIntensity;
             let currentDirIntensity = nightIntensity * 0.5; // Directional weaker at night
             let fogColor = new BABYLON.Color3(0.05, 0.05, 0.15); // Night fog

             gameState.isDaytime = (cycleProgress > dayStart && cycleProgress < dayEnd);

             if (gameState.isDaytime) {
                 // Calculate intensity based on sun's arc (sine wave)
                 const dayProgress = (cycleProgress - dayStart) / (dayEnd - dayStart); // 0 to 1 during the day
                 const sunAngle = dayProgress * Math.PI; // 0 to PI
                 const intensityMultiplier = Math.sin(sunAngle); // 0 -> 1 -> 0

                 currentHemiIntensity = nightIntensity + (maxSunIntensity * 0.6 - nightIntensity) * intensityMultiplier; // Ambient light
                 currentDirIntensity = nightIntensity * 0.5 + (maxSunIntensity * 0.8 - nightIntensity * 0.5) * intensityMultiplier; // Direct light stronger

                 // Interpolate fog color from sunrise/sunset color to midday color
                 const middayFog = new BABYLON.Color3(0.8, 0.85, 0.9);
                 const dawnDuskFog = new BABYLON.Color3(0.9, 0.7, 0.6);
                 if (dayProgress < 0.5) { // Morning
                      fogColor = BABYLON.Color3.Lerp(dawnDuskFog, middayFog, dayProgress * 2);
                 } else { // Afternoon
                      fogColor = BABYLON.Color3.Lerp(middayFog, dawnDuskFog, (dayProgress - 0.5) * 2);
                 }

                 // Update directional light direction (sun movement)
                 const sunX = Math.cos(sunAngle + Math.PI / 2); // Move across the sky
                 const sunY = Math.sin(sunAngle);              // Rise and set
                 directionalLight.direction = new BABYLON.Vector3(sunX * 0.8, -sunY, 0.2).normalize(); // Adjust Z slightly for angle

             } else {
                  // Ensure lights are at night intensity if not daytime
                  currentHemiIntensity = nightIntensity;
                  currentDirIntensity = nightIntensity * 0.5;
                  directionalLight.direction = new BABYLON.Vector3(-0.5, -1, -0.5); // Reset night direction
             }

             hemisphericLight.intensity = currentHemiIntensity;
             directionalLight.intensity = currentDirIntensity;
             scene.fogColor = fogColor;

             // Update UI text (less frequently needed)
             if (Math.floor(gameState.gameTime) % 2 === 0) { // Update every 2 seconds approx
                  document.getElementById('gameTime').textContent = gameState.isDaytime ? 'Day' : 'Night';
             }
         }


        // --- Animal AI ---
        function updateAnimals(deltaTime) {
              // CRITICAL FIX: Function to get actual terrain height using raycasting (same as in generateResources)
              // Could be moved to a shared utility function
             function getRealTerrainHeight(x, z, defaultHeight = 0) {
                const groundMesh = scene.getMeshByName("ground");
                if (!groundMesh) return defaultHeight;
                 const ray = new BABYLON.Ray(new BABYLON.Vector3(x, 50, z), new BABYLON.Vector3(0, -1, 0));
                 const hit = scene.pickWithRay(ray, (mesh) => mesh === groundMesh);
                 return (hit && hit.pickedPoint) ? hit.pickedPoint.y : defaultHeight;
             }

             entities.animals.forEach(animal => {
                 if (!animal.mesh || !animal.mesh.isEnabled() || animal.health <= 0) return; // Skip if disposed, disabled, or dead

                 // --- Simple State Machine (Idle, Wander) ---
                 animal.movementTimer -= deltaTime;

                 if (animal.movementTimer <= 0) {
                     // Decide next action (e.g., 70% wander, 30% idle)
                     if (Math.random() < 0.7) { // Wander
                         animal.movementDirection = new BABYLON.Vector3(
                             Math.random() - 0.5, 0, Math.random() - 0.5
                         ).normalize();
                         animal.movementTimer = 2 + Math.random() * 4; // Wander for 2-6 seconds
                         animal.isMoving = true;
                     } else { // Idle
                         animal.movementTimer = 1 + Math.random() * 2; // Idle for 1-3 seconds
                         animal.isMoving = false;
                     }
                 }

                 // --- Movement ---
                 if (animal.isMoving) {
                     const moveVector = animal.movementDirection.scale(animal.speed * deltaTime);
                     const currentPos = animal.mesh.position;
                     const nextPos = currentPos.add(moveVector);

                     // Basic Collision Avoidance / Terrain Following Prep
                     const terrainHeightAtNextPos = getRealTerrainHeight(nextPos.x, nextPos.z, currentPos.y); // Get target height
                     let canMove = true;

                     // Example: Prevent moving into deep water
                     if (terrainHeightAtNextPos < CONFIG.waterLevel + 0.2) { // Check height at next position
                          canMove = false;
                          animal.movementTimer = 0; // Force direction change next frame
                     }
                     // TODO: Add checks against trees, rocks, placed items (raycast forward or sphere check)

                     if (canMove) {
                          // Adjust target Y position to follow terrain smoothly
                          const targetY = terrainHeightAtNextPos + 0.5; // Adjust offset based on animal model origin
                          const lerpedY = BABYLON.Scalar.Lerp(currentPos.y, targetY, 0.1); // Smooth Y transition
                          const finalMoveVector = new BABYLON.Vector3(moveVector.x, lerpedY - currentPos.y, moveVector.z);

                          animal.mesh.moveWithCollisions(finalMoveVector); // Use built-in collision AFTER adjusting Y
                          animal.position.copyFrom(animal.mesh.position); // Update stored position

                          // --- Rotation ---
                          // FIX: Change const to let for targetAngle
                          let targetAngle = Math.atan2(animal.movementDirection.x, animal.movementDirection.z);
                          let currentAngle = animal.mesh.rotation.y;
                          // Ensure angles are in the same range (e.g., -PI to PI)
                          while (targetAngle - currentAngle > Math.PI) targetAngle -= Math.PI * 2;
                          while (targetAngle - currentAngle < -Math.PI) targetAngle += Math.PI * 2;
                          // Lerp rotation
                          animal.mesh.rotation.y = BABYLON.Scalar.Lerp(currentAngle, targetAngle, 0.1); // Adjust lerp factor for speed
                     } else {
                          // If movement blocked, trigger direction change
                          animal.movementTimer = 0;
                          animal.isMoving = false;
                     }

                 } else {
                     // Idle behavior (e.g., play idle animation if available)
                 }

                 // Final terrain height check (snap if needed, less smooth)
                 // const finalTerrainHeight = getRealTerrainHeight(animal.mesh.position.x, animal.mesh.position.z, animal.mesh.position.y);
                 // animal.mesh.position.y = finalTerrainHeight + 0.5;
                 // animal.position.copyFrom(animal.mesh.position);

             });
         }

        // --- Player Stats ---
        function updatePlayerStats(deltaTime) {
             const hungerRate = 0.1 * deltaTime; // Hunger decreases per second
             const thirstRate = 0.15 * deltaTime; // Thirst decreases faster
             const starvingDamage = 0.5 * deltaTime; // Health lost per second when starving/dehydrated
             const lowStatThreshold = 10;

             gameState.hunger -= hungerRate;
             gameState.thirst -= thirstRate;

             let takingDamage = false;
             if (gameState.hunger <= 0) {
                 gameState.health -= starvingDamage;
                 takingDamage = true;
                 gameState.hunger = 0;
             }
             if (gameState.thirst <= 0) {
                 gameState.health -= starvingDamage; // Damage stacks if both are zero
                 takingDamage = true;
                 gameState.thirst = 0;
             }

             // Clamp values
             gameState.hunger = Math.max(0, Math.min(100, gameState.hunger));
             gameState.thirst = Math.max(0, Math.min(100, gameState.thirst));
             gameState.health = Math.max(0, Math.min(100, gameState.health));

             // TODO: Add visual feedback for taking damage (red flash?)
             if (gameState.health <= 0) {
                 // Player death logic
                 console.log("Player Died!");
                  showNotification("You have died!");
                 // Respawn? Game over screen?
                  engine.stopRenderLoop(); // Stop the game for now
             }

             // Update UI (only if values changed significantly or periodically)
             // The updateUI function itself handles the throttling now
             updateUI();
        }

        // --- UI Functions ---

        // Toggle Fog
        function toggleFog() {
            CONFIG.fogEnabled = !CONFIG.fogEnabled;
            scene.fogDensity = CONFIG.fogEnabled ? CONFIG.fogDensity : 0;
             showNotification(`Fog ${CONFIG.fogEnabled ? 'Enabled' : 'Disabled'}`);
        }

        // Toggle Inventory UI
        function toggleInventory() {
            // Close crafting if open
             if (gameState.isCraftingOpen) toggleCrafting();
             if (gameState.isPlacingItem) cancelPlacement(); // Cancel placement if inventory opened

            gameState.isInventoryOpen = !gameState.isInventoryOpen;
            document.getElementById('inventory').style.display = gameState.isInventoryOpen ? 'block' : 'none';

            if (gameState.isInventoryOpen) {
                updateInventoryUI();
                 camera.detachControl(canvas); // Prevent movement/look while UI is open
            } else {
                 camera.attachControl(canvas, true); // Re-attach control
            }
        }

        // Toggle Crafting UI
        function toggleCrafting() {
             // Close inventory if open
             if (gameState.isInventoryOpen) toggleInventory();
             if (gameState.isPlacingItem) cancelPlacement(); // Cancel placement if crafting opened again

            gameState.isCraftingOpen = !gameState.isCraftingOpen;
            document.getElementById('craftingMenu').style.display = gameState.isCraftingOpen ? 'block' : 'none';

            if (gameState.isCraftingOpen) {
                updateCraftingUI();
                 camera.detachControl(canvas); // Prevent movement/look while UI is open
            } else {
                 // Only re-attach if inventory isn't also open
                 if (!gameState.isInventoryOpen) {
                    camera.attachControl(canvas, true);
                 }
            }
        }

         // Debounce UI updates to avoid excessive DOM manipulation
         let uiUpdateTimer = null;
         const UI_UPDATE_INTERVAL = 200; // Milliseconds (5 times per second max)

        // Update all UI elements (Throttled)
        function updateUI() {
             if (uiUpdateTimer) return; // Already scheduled

             uiUpdateTimer = setTimeout(() => {
                 if (!gameState.isLoaded) {
                     uiUpdateTimer = null;
                     return;
                 }

                 // Update Text Spans
                 document.getElementById('health').textContent = Math.floor(gameState.health);
                 document.getElementById('hunger').textContent = Math.floor(gameState.hunger);
                 document.getElementById('thirst').textContent = Math.floor(gameState.thirst);

                 // Update Progress Bar Widths
                 document.getElementById('healthBar').style.width = gameState.health + '%';
                 document.getElementById('hungerBar').style.width = gameState.hunger + '%';
                 document.getElementById('thirstBar').style.width = gameState.thirst + '%';

                 // Update dynamic UIs if they are open
                 if (gameState.isInventoryOpen) {
                     updateInventoryUI();
                 }
                 if (gameState.isCraftingOpen) {
                     updateCraftingUI();
                 }

                 uiUpdateTimer = null; // Allow next update
             }, UI_UPDATE_INTERVAL);
        }


        // Update inventory UI
        function updateInventoryUI() {
            const inventoryDiv = document.getElementById('inventory');
            if (!inventoryDiv) return;
            inventoryDiv.innerHTML = '<h3>Inventory</h3>'; // Clear previous content

            // Resources
            let hasResources = false;
            for (const item in gameState.inventory) {
                if (gameState.inventory[item] > 0) {
                     hasResources = true;
                    const itemElement = document.createElement('div');
                    itemElement.className = 'resource';
                     // Capitalize first letter for display
                     const itemName = item.charAt(0).toUpperCase() + item.slice(1).replace(/([A-Z])/g, ' $1').trim();
                    itemElement.textContent = `${itemName}: ${gameState.inventory[item]}`;
                    inventoryDiv.appendChild(itemElement);
                }
            }
             if (!hasResources) inventoryDiv.appendChild(document.createTextNode("No resources."));


            // Tools
            inventoryDiv.appendChild(document.createElement('hr'));
            inventoryDiv.appendChild(document.createElement('h4')).textContent = 'Tools:';
            let hasTools = false;
            for (const tool in gameState.tools) {
                if (gameState.tools[tool]) {
                     hasTools = true;
                    const toolElement = document.createElement('div');
                    toolElement.className = 'resource';
                     const toolName = tool.charAt(0).toUpperCase() + tool.slice(1);
                    toolElement.textContent = toolName;
                    inventoryDiv.appendChild(toolElement);
                }
            }
             if (!hasTools) inventoryDiv.appendChild(document.createTextNode("No tools."));
        }

        // Update crafting UI
        function updateCraftingUI() {
            const craftingItemsDiv = document.getElementById('craftingItems');
             if (!craftingItemsDiv) return;
            craftingItemsDiv.innerHTML = ''; // Clear previous content

            for (const recipe of craftingRecipes) {
                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'recipe';
                recipeDiv.style.marginBottom = '10px';
                 recipeDiv.style.paddingBottom = '10px';
                recipeDiv.style.borderBottom = '1px solid rgba(255, 255, 255, 0.2)';

                const nameElement = document.createElement('div');
                nameElement.textContent = recipe.name;
                nameElement.style.fontWeight = 'bold';
                recipeDiv.appendChild(nameElement);

                if (recipe.description) {
                    const descElement = document.createElement('div');
                    descElement.textContent = recipe.description;
                    descElement.style.fontSize = '12px';
                    descElement.style.fontStyle = 'italic';
                    descElement.style.marginBottom = '5px';
                    recipeDiv.appendChild(descElement);
                }

                const reqElement = document.createElement('div');
                reqElement.style.fontSize = '12px';
                let reqText = 'Requires: ';
                let canCraft = true;
                for (const req in recipe.requirements) {
                    const have = gameState.inventory[req] || 0;
                    const needed = recipe.requirements[req];
                     const resourceName = req.charAt(0).toUpperCase() + req.slice(1).replace(/([A-Z])/g, ' $1').trim();
                    reqText += `${resourceName}: ${have}/${needed}, `;
                    if (have < needed) {
                        canCraft = false;
                    }
                }
                reqElement.textContent = reqText.slice(0, -2); // Remove trailing comma and space
                 if (!canCraft) {
                     reqElement.style.color = '#ff8888'; // Highlight unmet requirements
                 }
                recipeDiv.appendChild(reqElement);

                const craftButton = document.createElement('button');
                craftButton.textContent = 'Craft';
                craftButton.className = 'craftButton';
                craftButton.disabled = !canCraft;
                if (!canCraft) {
                    craftButton.style.backgroundColor = '#666';
                    craftButton.style.cursor = 'not-allowed';
                } else {
                     craftButton.onclick = function() { // Assign onclick only if craftable
                         craftItem(recipe);
                     };
                }

                recipeDiv.appendChild(craftButton);
                craftingItemsDiv.appendChild(recipeDiv);
            }
        }

         // --- Crafting & Placement ---

         // Craft an item
         function craftItem(recipe) {
             if (gameState.isPlacingItem) {
                 showNotification("Already placing an item!");
                 return;
             }

             // Double-check resources (UI might be slightly out of date)
             for (const req in recipe.requirements) {
                 if (!gameState.inventory[req] || gameState.inventory[req] < recipe.requirements[req]) {
                     showNotification("Cannot craft: Missing resources!");
                     updateCraftingUI(); // Refresh UI if state mismatch
                     return;
                 }
             }

             // Consume resources
             for (const req in recipe.requirements) {
                 gameState.inventory[req] -= recipe.requirements[req];
             }

             // Add item or start placement
             if (recipe.placeable) {
                  if (!cachedMeshes[recipe.result]) {
                      console.error(`Crafting error: Cached mesh for ${recipe.result} not found!`);
                      showNotification(`Error crafting ${recipe.name}!`);
                      // Return resources (or handle error differently)
                      for (const req in recipe.requirements) { gameState.inventory[req] += recipe.requirements[req]; }
                      updateUI();
                      return;
                  }
                 startPlacement(recipe); // Pass recipe to placement
             } else {
                 // Add non-placeable item to inventory
                 gameState.inventory[recipe.result] = (gameState.inventory[recipe.result] || 0) + 1;
                 showNotification(`Crafted ${recipe.name}`);
                 updateUI(); // Update inventory/crafting lists
                  // Re-update crafting UI specifically if it's open
                 if (gameState.isCraftingOpen) updateCraftingUI();
             }

             // Don't close crafting menu automatically here - placement handles it
         }

         // Start placement mode
         function startPlacement(recipe) {
             gameState.isPlacingItem = true;
             gameState.placementRecipe = recipe;

             // FIX: Use clone for placement preview
             gameState.placementPreviewMesh = cachedMeshes[recipe.result].clone("placementPreview", null);

             if (!gameState.placementPreviewMesh) {
                 console.error(`Failed to clone placement preview for ${recipe.result}`);
                 showNotification(`Error starting placement for ${recipe.name}!`);
                 // Return resources since placement failed
                 for (const req in recipe.requirements) { gameState.inventory[req] += recipe.requirements[req]; }
                 cleanUpPlacement(); // Clean up partial state
                 updateUI();
                 return;
             }

             gameState.placementPreviewMesh.setEnabled(true);
             gameState.placementPreviewMesh.isPickable = false; // Don't interact with preview
             // Disable children as well
             gameState.placementPreviewMesh.getChildMeshes().forEach(child => {
                  child.setEnabled(true); // Ensure they are visible for preview
                  child.isPickable = false;
             });

             // Apply semi-transparent material
             const previewMaterial = new BABYLON.StandardMaterial("previewMat", scene);
             // Try to base color on original material if possible (check child materials if root has none)
             let originalMaterial = gameState.placementPreviewMesh.material;
             if (!originalMaterial && gameState.placementPreviewMesh.getChildMeshes().length > 0) {
                 // Find first child with a standard material
                 const childWithMat = gameState.placementPreviewMesh.getChildMeshes().find(m => m.material instanceof BABYLON.StandardMaterial);
                 if (childWithMat) originalMaterial = childWithMat.material;
             }

             if (originalMaterial instanceof BABYLON.StandardMaterial && originalMaterial.diffuseColor) {
                 previewMaterial.diffuseColor = originalMaterial.diffuseColor.clone();
             } else {
                 previewMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.5); // Default preview color
             }
             previewMaterial.alpha = 0.6;

             // Apply to root and all children
             gameState.placementPreviewMesh.material = previewMaterial;
             gameState.placementPreviewMesh.getChildMeshes().forEach(child => {
                  // Create separate instances of the material for children if they need independent emissive colors
                  // (though usually setting the root's material works visually for simple previews)
                  child.material = previewMaterial.clone(`${child.name}_previewMat`);
                  child.material.alpha = 0.6; // Ensure alpha is set on cloned mats too
             });


             // Hide crafting menu during placement
             if (gameState.isCraftingOpen) {
                  document.getElementById('craftingMenu').style.display = 'none';
             }
              // Detach controls during placement as well
              camera.detachControl(canvas);
             showNotification(`Placing ${recipe.name}... (Left Click to place, ESC to cancel)`);
         }

         // Update placement preview position and validation
         function updatePlacementPreview() {
             if (!gameState.isPlacingItem || !gameState.placementPreviewMesh) return;

             const PLACEMENT_DISTANCE = 8;
             const ray = camera.getForwardRay(PLACEMENT_DISTANCE); // Use camera from global scope
             const hit = scene.pickWithRay(ray, (mesh) => mesh.isPickable && mesh !== gameState.placementPreviewMesh && !mesh.parent); // Ignore self, maybe ignore children of things? Only pick ground/rocks etc.

             let placementValid = false;
             let placementPosition = null;

             if (hit.pickedMesh && hit.pickedPoint) {
                 placementPosition = hit.pickedPoint.clone();
                 // Basic validation: Place only on ground for now
                 if (hit.pickedMesh.name === "ground") {
                     // TODO: Add more validation: Check for overlaps with other placedItems, resources etc.
                     // Use bounding box intersection checks:
                     // gameState.placementPreviewMesh.position = placementPosition; // Temporarily move for check
                     // let intersects = false;
                     // const checkEntities = [...entities.placedItems, ...entities.trees, ...entities.rocks, ...entities.ores, ...entities.animals]; // Add more if needed
                     // for (const entity of checkEntities) {
                     //    if (entity.mesh && entity.mesh !== gameState.placementPreviewMesh && gameState.placementPreviewMesh.intersectsMesh(entity.mesh, true)) {
                     //       intersects = true;
                     //       break;
                     //    }
                     // }
                     // if (!intersects) {
                     //      placementValid = true;
                     // }
                     placementValid = true; // Simplified validation for now
                 }
             }

             // Update position if a valid point was found
             if (placementPosition) {
                  gameState.placementPreviewMesh.position = placementPosition;
             }

             // Update preview material color based on validity
             const validColor = new BABYLON.Color3(0, 0.3, 0); // Green tint
             const invalidColor = new BABYLON.Color3(0.5, 0, 0); // Red tint
             const targetColor = placementValid ? validColor : invalidColor;

             // Apply emissive color to root and children materials
             const applyEmissive = (mesh) => {
                 if (mesh && mesh.material instanceof BABYLON.StandardMaterial) {
                     mesh.material.emissiveColor = targetColor;
                 }
             };
             applyEmissive(gameState.placementPreviewMesh);
             gameState.placementPreviewMesh.getChildMeshes().forEach(applyEmissive);

             gameState.placementValid = placementValid; // Store validity state
         }


         // Confirm placement action
         function confirmPlacement() {
             if (!gameState.isPlacingItem || !gameState.placementPreviewMesh || !gameState.placementValid) {
                  showNotification("Cannot place item here.");
                 return; // Not placing or position invalid
             }

             const recipe = gameState.placementRecipe;
             const position = gameState.placementPreviewMesh.position.clone();
              // TODO: Add rotation control during placement if needed
              const rotation = gameState.placementPreviewMesh.rotationQuaternion ? gameState.placementPreviewMesh.rotationQuaternion.clone() : BABYLON.Quaternion.Identity(); // Copy rotation if needed

             // FIX: Use clone to create the final placed item
             const placedItemMesh = cachedMeshes[recipe.result].clone(`${recipe.result}_placed_${entities.placedItems.length}`, null);

              if (!placedItemMesh) {
                  console.error(`Failed to clone placed item ${recipe.result}`);
                  showNotification(`Error placing ${recipe.name}!`);
                  // Return resources if final clone fails
                  for (const req in recipe.requirements) { gameState.inventory[req] += recipe.requirements[req]; }
                  cleanUpPlacement();
                  updateUI();
                  return;
              }

             placedItemMesh.position = position;
              // placedItemMesh.rotationQuaternion = rotation; // Apply rotation if preview allows it
             placedItemMesh.setEnabled(true);
             placedItemMesh.isPickable = true; // Make the final item interactable
              // Enable children and make them pickable (if needed for interaction)
              placedItemMesh.getChildMeshes().forEach(child => {
                  child.setEnabled(true);
                  child.isPickable = true; // Or false, depending on design
              });


              // Optional: Add physics impostor if needed
              // placedItemMesh.physicsImpostor = new BABYLON.PhysicsImpostor(placedItemMesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);


             // Add to placed items entity list
             entities.placedItems.push({
                 mesh: placedItemMesh, // Reference to the clone root
                 type: recipe.result,
                 position: position.clone(),
                  health: 100, // Give placed items health for deconstruction
                  // Store required resources for potential deconstruction yield (adjust yield calculation later)
                  resources: { ...recipe.requirements }
             });

             showNotification(`Placed ${recipe.name}`);

             // Clean up placement state (disposes preview mesh)
             cleanUpPlacement();

              // Re-enable controls ONLY if other menus aren't open
              if (!gameState.isCraftingOpen && !gameState.isInventoryOpen) {
                 camera.attachControl(canvas, true);
              }

              // Update crafting UI if it was the source (to reflect resource changes)
              // if (gameState.isCraftingOpen) updateCraftingUI(); // Crafting menu is closed during placement
         }

         // Cancel placement action
         function cancelPlacement() {
             if (!gameState.isPlacingItem) return;

             const recipe = gameState.placementRecipe; // Get recipe BEFORE cleanup

             // Return resources only if a valid recipe was being placed
             if (recipe && recipe.requirements) {
                 for (const req in recipe.requirements) {
                     gameState.inventory[req] = (gameState.inventory[req] || 0) + recipe.requirements[req];
                 }
                 showNotification(`Placement cancelled for ${recipe.name}. Resources returned.`);
             } else {
                  showNotification(`Placement cancelled.`);
             }


             // Clean up placement state (disposes preview mesh)
             cleanUpPlacement();
             updateUI(); // Update inventory display

              // Re-open crafting menu ONLY if it was open before placement started
             // (Need to track this state if desired, or just don't reopen)
             // if (wasCraftingOpenBeforePlacement) { // Requires tracking this state
             //    document.getElementById('craftingMenu').style.display = 'block';
             //    updateCraftingUI();
             // }

              // Re-enable controls ONLY if other menus aren't open
              if (!gameState.isCraftingOpen && !gameState.isInventoryOpen) {
                 camera.attachControl(canvas, true);
              }
         }

         // Clean up placement variables and preview mesh
         function cleanUpPlacement() {
             if (gameState.placementPreviewMesh) {
                 gameState.placementPreviewMesh.dispose(); // Dispose clone and children
                 gameState.placementPreviewMesh = null;
             }
             gameState.isPlacingItem = false;
             gameState.placementRecipe = null;
             gameState.placementValid = false;
             // Clear notification after a delay? Handled by showNotification timeout
         }


        // --- Survival Actions ---

        // Function to find the closest water source
        function findClosestWater(position) {
            // FIX: More robust water check - raycast down
             const waterCheckRay = new BABYLON.Ray(position, new BABYLON.Vector3(0, -1, 0));
             const waterCheckDistance = 2.0; // How far down to check
             const hit = scene.pickWithRay(waterCheckRay, (mesh) => mesh.name === "water", true, waterCheckDistance); // Only pick water mesh

            return hit && hit.pickedMesh; // Return true if water was hit within range
        }

        // Function to drink water
        function drinkWater() {
            if (gameState.isPlacingItem) return;

            // Use camera position slightly in front for the check
             const checkPos = camera.position.add(camera.getDirection(BABYLON.Axis.Z).scale(0.5));

            if (findClosestWater(checkPos)) {
                 if (gameState.tools.canteen) { // Assume canteen auto-refills for simplicity
                     gameState.thirst = 100;
                     showNotification("Drank water.");
                     updateUI();
                     return true;
                 } else {
                      showNotification("You need a canteen to drink safely.");
                 }
            } else {
                 showNotification("No water source nearby.");
            }
            return false;
        }

        // Function to eat food
        function eatFood(foodType) {
             if (gameState.isPlacingItem) return;

             // TODO: Implement cooking mechanic - raw meat might give less hunger or cause sickness
             const hungerGain = 30; // Cooked meat value
             const healthGain = 5; // Eating provides slight health

            if (foodType === 'meat' && gameState.inventory.meat > 0) {
                gameState.inventory.meat--;
                gameState.hunger += hungerGain;
                gameState.health += healthGain; // Eating helps health slightly
                gameState.hunger = Math.min(100, gameState.hunger);
                gameState.health = Math.min(100, gameState.health);
                showNotification("Ate some meat.");
                updateUI();
                return true;
            } else {
                 showNotification("You have no meat to eat.");
            }
            return false;
        }

         // --- Notifications ---
         let notificationTimeout = null;
         function showNotification(message, duration = 3000) {
              const notificationElement = document.getElementById('notification');
              if (!notificationElement) return;

              notificationElement.textContent = message;
              notificationElement.style.display = 'block';
              notificationElement.style.opacity = 1;

              // Clear existing timeout if any
              if (notificationTimeout) clearTimeout(notificationTimeout);

              // Set new timeout to hide
              notificationTimeout = setTimeout(() => {
                  notificationElement.style.opacity = 0;
                  // Use transition end or another timeout to set display: none
                  setTimeout(() => {
                      // Check if this is still the active timeout before hiding
                      if (notificationTimeout === timeoutId) {
                          notificationElement.style.display = 'none';
                      }
                   }, 500); // Match CSS transition duration
              }, duration);
              const timeoutId = notificationTimeout; // Store the ID for the check in the hide timeout
         }


        // --- Global Access & Initialization ---

         // Expose functions needed by HTML onclick attributes to the window scope
         window.toggleInventory = toggleInventory;
         window.toggleCrafting = toggleCrafting;
         window.toggleFog = toggleFog;


        // Wait for DOM and start the game
        document.addEventListener('DOMContentLoaded', function() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (!loadingScreen) {
                 console.error("Loading screen element not found!");
                 return;
            }
             loadingScreen.textContent = 'Loading Assets...'; // More accurate message

            // Ensure Babylon.js is loaded before starting
            if (typeof BABYLON === 'undefined') {
                 loadingScreen.textContent = 'Error: Babylon.js not loaded!';
                 console.error("Babylon.js script not found or failed to load.");
                 return;
            }

             // Call createGame only ONCE, after a delay (simulating asset loading)
             // In a real game, you'd use Babylon's AssetsManager here.
            setTimeout(function() {
                try {
                     loadingScreen.textContent = 'Initializing World...';
                    createGame(); // Start the game logic
                } catch (error) {
                    console.error("Error initializing game:", error);
                    loadingScreen.textContent = `Error: ${error.message}`;
                    loadingScreen.style.backgroundColor = 'red';
                }
            }, 100); // Reduced delay, main loading is Babylon's setup now
        });

    </script>
</body>
</html>