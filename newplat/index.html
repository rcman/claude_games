<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Scrolling Platform Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #gameOverScreen, #levelCompleteScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 32px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameUI">
        <div>Health: <span id="healthDisplay">100</span></div>
        <div>Ammo: <span id="ammoDisplay">50</span></div>
        <div>Armor: <span id="armorDisplay">0</span>/10</div>
        <div>Keys: <span id="keysDisplay">0</span></div>
        <div>Level: <span id="levelDisplay">1</span></div>
    </div>
    <div id="gameOverScreen">
        <h2>Game Over</h2>
        <p>You were defeated!</p>
        <button id="restartButton">Restart Level</button>
    </div>
    <div id="levelCompleteScreen">
        <h2>Level Complete!</h2>
        <p>Boss defeated!</p>
        <button id="nextLevelButton">Next Level</button>
    </div>

    <script>
        // Game Constants and Variables
        const CANVAS_WIDTH = 1920;
        const CANVAS_HEIGHT = 1080;
        const GRAVITY = 0.6;
        const FRICTION = 0.8;
        const PLATFORM_SPEED = 2;
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = 15;
        const BULLET_SPEED = 10;
        const ENEMY_BULLET_SPEED = 8;
        
        let canvas, ctx;
        let gameActive = true;
        let platformScroll = 0;
        let backgroundImage = new Image();
        let playerSprite = new Image();
        let enemySprite = new Image();
        let crateSprite = new Image();
        let lockerSprite = new Image();
        let doorSprite = new Image();
        let bossSprite = new Image();
        let levelConfig = {
            currentLevel: 1,
            totalLevels: 3,
        };
        
        let player = {
            x: 200,
            y: 300,
            width: 40,
            height: 80,
            velocityX: 0,
            velocityY: 0,
            isJumping: false,
            isCrouching: false,
            isShooting: false,
            direction: 1, // 1 for right, -1 for left
            health: 100,
            ammo: 50,
            armor: 0,
            keys: 0,
            isHit: false,
            hitTimer: 0,
            powerUpTimer: 0,
            powerUpActive: false
        };
        
        let bullets = [];
        let enemyBullets = [];
        let platforms = [];
        let enemies = [];
        let crates = [];
        let lockers = [];
        let doors = [];
        let boss = null;
        
        // Initialize the game
        function init() {
            canvas = document.getElementById('gameCanvas');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            ctx = canvas.getContext('2d');
            
            // Load images
            backgroundImage.src = 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js'; // Placeholder - replace with actual URL
            playerSprite.src = '/api/placeholder/40/80';
            enemySprite.src = '/api/placeholder/40/80';
            crateSprite.src = '/api/placeholder/60/60';
            lockerSprite.src = '/api/placeholder/50/80';
            doorSprite.src = '/api/placeholder/80/120';
            bossSprite.src = '/api/placeholder/80/120';
            
            // Create level
            createLevel(levelConfig.currentLevel);
            
            // Add event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            document.getElementById('restartButton').addEventListener('click', function() {
                restartGame();
            });
            
            document.getElementById('nextLevelButton').addEventListener('click', function() {
                levelConfig.currentLevel++;
                if (levelConfig.currentLevel > levelConfig.totalLevels) {
                    levelConfig.currentLevel = 1; // Restart from level 1
                }
                createLevel(levelConfig.currentLevel);
                document.getElementById('levelCompleteScreen').style.display = 'none';
                gameActive = true;
            });
            
            // Start game loop
            gameLoop();
        }
        
        function createLevel(level) {
            // Reset game state
            platformScroll = 0;
            bullets = [];
            enemyBullets = [];
            platforms = [];
            enemies = [];
            crates = [];
            lockers = [];
            doors = [];
            boss = null;
            
            player.x = 200;
            player.y = 300;
            player.velocityX = 0;
            player.velocityY = 0;
            player.isJumping = false;
            player.isCrouching = false;
            player.health = 100;
            player.ammo = 50;
            player.armor = 0;
            player.keys = 0;
            player.powerUpActive = false;
            player.powerUpTimer = 0;
            
            // Base platform (ground)
            platforms.push({
                x: 0,
                y: CANVAS_HEIGHT - 100,
                width: CANVAS_WIDTH * 3, // Make it extra wide for scrolling
                height: 100
            });
            
            // Generate platforms based on level
            const numPlatforms = 5 + level * 2;
            for (let i = 0; i < numPlatforms; i++) {
                platforms.push({
                    x: 800 + i * 600,
                    y: 300 + Math.random() * 500,
                    width: 300 + Math.random() * 200,
                    height: 40
                });
            }
            
            // Generate enemies
            const numEnemies = 3 + level * 2;
            for (let i = 0; i < numEnemies; i++) {
                const platform = platforms[1 + i % (platforms.length - 1)];
                enemies.push({
                    x: platform.x + Math.random() * (platform.width - 40),
                    y: platform.y - 80,
                    width: 40,
                    height: 80,
                    health: 30 + level * 10,
                    shootCooldown: 0,
                    shootDelay: 120 - level * 10,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    patrolPoint1: platform.x + 20,
                    patrolPoint2: platform.x + platform.width - 60,
                    speed: 1 + level * 0.2,
                    isHit: false,
                    hitTimer: 0
                });
            }
            
            // Generate crates
            const numCrates = 5 + level;
            for (let i = 0; i < numCrates; i++) {
                const platform = platforms[i % platforms.length];
                crates.push({
                    x: platform.x + Math.random() * (platform.width - 60),
                    y: platform.y - 60,
                    width: 60,
                    height: 60
                });
            }
            
            // Generate lockers
            const numLockers = 4 + level;
            for (let i = 0; i < numLockers; i++) {
                const platform = platforms[i % platforms.length];
                lockers.push({
                    x: platform.x + Math.random() * (platform.width - 50),
                    y: platform.y - 80,
                    width: 50,
                    height: 80,
                    searched: false,
                    type: Math.random() < 0.33 ? 'ammo' : (Math.random() < 0.5 ? 'armor' : 'key')
                });
            }
            
            // Add a door
            const doorPlatform = platforms[platforms.length - 2];
            doors.push({
                x: doorPlatform.x + doorPlatform.width / 2 - 40,
                y: doorPlatform.y - 120,
                width: 80,
                height: 120,
                isOpen: false,
                keysRequired: 3 + level
            });
            
            // Update UI
            updateUI();
        }
        
        function createBoss() {
            // Create boss at the end platform
            const endPlatform = platforms[platforms.length - 1];
            boss = {
                x: endPlatform.x + endPlatform.width / 2 - 40,
                y: endPlatform.y - 120,
                width: 80,
                height: 120,
                health: 100 + levelConfig.currentLevel * 50,
                maxHealth: 100 + levelConfig.currentLevel * 50,
                shootCooldown: 0,
                shootDelay: 60 - levelConfig.currentLevel * 5,
                attackPattern: 0,
                isHit: false,
                hitTimer: 0
            };
        }
        
        function gameLoop() {
            if (gameActive) {
                update();
                render();
            }
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            // Player movement
            updatePlayer();
            
            // Update bullets
            updateBullets();
            
            // Update enemies
            updateEnemies();
            
            // Update boss
            updateBoss();
            
            // Update powerup timer
            updatePowerUp();
            
            // Collision detection
            checkCollisions();
            
            // Scroll level
            scrollLevel();
            
            // Update UI
            updateUI();
        }
        
        function updatePlayer() {
            // Apply gravity
            player.velocityY += GRAVITY;
            
            // Apply friction
            player.velocityX *= FRICTION;
            
            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Constrain player to canvas
            if (player.x < 0) player.x = 0;
            if (player.x > CANVAS_WIDTH / 2) player.x = CANVAS_WIDTH / 2; // Don't let player move too far right
            
            // Handle hit animation
            if (player.isHit) {
                player.hitTimer--;
                if (player.hitTimer <= 0) {
                    player.isHit = false;
                }
            }
            
            // Check for game over
            if (player.health <= 0) {
                gameOver();
            }
        }
        
        function updateBullets() {
            // Update player bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].velocityX;
                
                // Remove bullets that are off screen
                if (bullets[i].x < 0 || bullets[i].x > CANVAS_WIDTH) {
                    bullets.splice(i, 1);
                    continue;
                }
            }
            
            // Update enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                enemyBullets[i].x += enemyBullets[i].velocityX;
                
                // Remove bullets that are off screen
                if (enemyBullets[i].x < 0 || enemyBullets[i].x > CANVAS_WIDTH) {
                    enemyBullets.splice(i, 1);
                    continue;
                }
            }
        }
        
        function updateEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // AI movement - patrol between two points
                enemy.x += enemy.speed * enemy.direction;
                
                if (enemy.x <= enemy.patrolPoint1) {
                    enemy.direction = 1;
                } else if (enemy.x >= enemy.patrolPoint2) {
                    enemy.direction = -1;
                }
                
                // Handle hit animation
                if (enemy.isHit) {
                    enemy.hitTimer--;
                    if (enemy.hitTimer <= 0) {
                        enemy.isHit = false;
                    }
                }
                
                // Enemy shooting
                enemy.shootCooldown--;
                if (enemy.shootCooldown <= 0) {
                    // Check if player is in line of sight
                    if (Math.abs(enemy.y - player.y) < 100 && 
                        ((enemy.direction === 1 && enemy.x < player.x) || 
                         (enemy.direction === -1 && enemy.x > player.x))) {
                        
                        enemyShoot(enemy);
                        enemy.shootCooldown = enemy.shootDelay;
                    }
                }
            }
        }
        
        function updateBoss() {
            if (!boss) return;
            
            // Boss shooting
            boss.shootCooldown--;
            if (boss.shootCooldown <= 0) {
                bossShooting();
                boss.shootCooldown = boss.shootDelay;
                
                // Change attack pattern occasionally
                if (Math.random() < 0.1) {
                    boss.attackPattern = Math.floor(Math.random() * 3);
                }
            }
            
            // Handle hit animation
            if (boss.isHit) {
                boss.hitTimer--;
                if (boss.hitTimer <= 0) {
                    boss.isHit = false;
                }
            }
        }
        
        function updatePowerUp() {
            if (player.powerUpActive) {
                player.powerUpTimer--;
                if (player.powerUpTimer <= 0) {
                    player.powerUpActive = false;
                }
            }
        }
        
        function bossShooting() {
            if (!boss) return;
            
            switch (boss.attackPattern) {
                case 0: // Single powerful shot
                    enemyBullets.push({
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        width: 10,
                        height: 10,
                        velocityX: -ENEMY_BULLET_SPEED * 1.5,
                        damage: 15
                    });
                    break;
                case 1: // Spread shot
                    for (let i = -2; i <= 2; i++) {
                        enemyBullets.push({
                            x: boss.x + boss.width / 2,
                            y: boss.y + boss.height / 2,
                            width: 8,
                            height: 8,
                            velocityX: -ENEMY_BULLET_SPEED * Math.cos(i * 0.2),
                            velocityY: ENEMY_BULLET_SPEED * Math.sin(i * 0.2),
                            damage: 10
                        });
                    }
                    break;
                case 2: // Rapid fire
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            if (boss && gameActive) {
                                enemyBullets.push({
                                    x: boss.x + boss.width / 2,
                                    y: boss.y + boss.height / 2,
                                    width: 6,
                                    height: 6,
                                    velocityX: -ENEMY_BULLET_SPEED,
                                    damage: 8
                                });
                            }
                        }, i * 100);
                    }
                    break;
            }
        }
        
        function playerShoot() {
            if (player.ammo <= 0) return;
            
            player.ammo--;
            player.isShooting = true;
            
            // Create bullet
            bullets.push({
                x: player.x + (player.direction > 0 ? player.width : 0),
                y: player.isCrouching ? player.y + player.height / 4 : player.y + player.height / 2,
                width: 10,
                height: 5,
                velocityX: BULLET_SPEED * player.direction,
                damage: player.powerUpActive ? 20 : 10
            });
            
            // Reset shooting animation after a short delay
            setTimeout(() => {
                player.isShooting = false;
            }, 100);
        }
        
        function enemyShoot(enemy) {
            const direction = enemy.x > player.x ? -1 : 1;
            
            enemyBullets.push({
                x: enemy.x + (direction > 0 ? enemy.width : 0),
                y: enemy.y + enemy.height / 2,
                width: 8,
                height: 4,
                velocityX: ENEMY_BULLET_SPEED * direction,
                damage: 5 + levelConfig.currentLevel * 2
            });
        }
        
        function checkCollisions() {
            // Player collision with platforms
            let onGround = false;
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                
                // Adjust platform position for scrolling
                const adjustedX = platform.x - platformScroll;
                
                // Check if player is on this platform
                if (player.x + player.width > adjustedX && 
                    player.x < adjustedX + platform.width &&
                    player.y + player.height >= platform.y &&
                    player.y + player.height <= platform.y + platform.height / 2 &&
                    player.velocityY > 0) {
                    
                    player.y = platform.y - player.height;
                    player.velocityY = 0;
                    player.isJumping = false;
                    onGround = true;
                }
            }
            
            if (!onGround) {
                player.isJumping = true;
            }
            
            // Check player collision with lockers
            for (let i = 0; i < lockers.length; i++) {
                const locker = lockers[i];
                const adjustedX = locker.x - platformScroll;
                
                if (player.x + player.width > adjustedX &&
                    player.x < adjustedX + locker.width &&
                    player.y + player.height > locker.y &&
                    player.y < locker.y + locker.height) {
                    
                    // Only search locker if not already searched
                    if (!locker.searched && (player.x + player.width/2 > adjustedX && player.x + player.width/2 < adjustedX + locker.width)) {
                        searchLocker(locker);
                    }
                }
            }
            
            // Check player collision with doors
            for (let i = 0; i < doors.length; i++) {
                const door = doors[i];
                const adjustedX = door.x - platformScroll;
                
                if (player.x + player.width > adjustedX &&
                    player.x < adjustedX + door.width &&
                    player.y + player.height > door.y &&
                    player.y < door.y + door.height) {
                    
                    // Try to open door if not already open
                    if (!door.isOpen && player.keys >= door.keysRequired && (player.x + player.width/2 > adjustedX && player.x + player.width/2 < adjustedX + door.width)) {
                        openDoor(door);
                    }
                }
            }
            
            // Check if player is hidden behind crates
            player.isHidden = false;
            if (player.isCrouching) {
                for (let i = 0; i < crates.length; i++) {
                    const crate = crates[i];
                    const adjustedX = crate.x - platformScroll;
                    
                    if (Math.abs((player.x + player.width/2) - (adjustedX + crate.width/2)) < crate.width) {
                        player.isHidden = true;
                        break;
                    }
                }
            }
            
            // Player bullet collision with enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const adjustedX = enemy.x - platformScroll;
                    
                    if (bullet.x + bullet.width > adjustedX &&
                        bullet.x < adjustedX + enemy.width &&
                        bullet.y + bullet.height > enemy.y &&
                        bullet.y < enemy.y + enemy.height) {
                        
                        // Enemy hit
                        enemy.health -= bullet.damage;
                        enemy.isHit = true;
                        enemy.hitTimer = 10;
                        
                        // Remove bullet
                        bullets.splice(i, 1);
                        
                        // Check if enemy is defeated
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                        }
                        
                        break;
                    }
                }
                
                // Check collision with boss
                if (boss && bullet) {
                    const adjustedBossX = boss.x - platformScroll;
                    
                    if (bullet.x + bullet.width > adjustedBossX &&
                        bullet.x < adjustedBossX + boss.width &&
                        bullet.y + bullet.height > boss.y &&
                        bullet.y < boss.y + boss.height) {
                        
                        // Boss hit
                        boss.health -= bullet.damage;
                        boss.isHit = true;
                        boss.hitTimer = 10;
                        
                        // Remove bullet if it still exists
                        if (i < bullets.length) {
                            bullets.splice(i, 1);
                        }
                        
                        // Check if boss is defeated
                        if (boss.health <= 0) {
                            levelComplete();
                            boss = null;
                        }
                    }
                }
            }
            
            // Enemy bullet collision with player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                if (bullet.x + bullet.width > player.x &&
                    bullet.x < player.x + player.width &&
                    bullet.y + bullet.height > player.y &&
                    bullet.y < player.y + player.height &&
                    !player.isHidden) { // Only hit player if not hidden
                    
                    // Calculate damage based on armor
                    let damage = bullet.damage;
                    if (player.powerUpActive) {
                        damage = Math.max(1, Math.floor(damage * 0.2)); // 80% damage reduction
                    } else if (player.armor >= 10) {
                        damage = Math.max(1, Math.floor(damage * 0.5)); // 50% damage reduction
                    }
                    
                    // Player hit
                    player.health -= damage;
                    player.isHit = true;
                    player.hitTimer = 20;
                    
                    // Remove bullet
                    enemyBullets.splice(i, 1);
                }
            }
        }
        
        function searchLocker(locker) {
            locker.searched = true;
            
            // Give reward based on locker type
            switch (locker.type) {
                case 'ammo':
                    player.ammo += 20 + Math.floor(Math.random() * 20);
                    break;
                case 'armor':
                    player.armor += 1;
                    if (player.armor > 10) player.armor = 10;
                    break;
                case 'key':
                    player.keys += 1;
                    break;
            }
            
            // Update UI
            updateUI();
        }
        
        function openDoor(door) {
            door.isOpen = true;
            player.keys -= door.keysRequired;
            
            // Activate powerup
            player.powerUpActive = true;
            player.powerUpTimer = 60 * 60; // 60 seconds at 60fps
            
            // Set full ammo and health
            player.ammo = 100;
            player.health = 100;
            
            // Make enemies harder
            for (let i = 0; i < enemies.length; i++) {
                enemies[i].health += 20;
                enemies[i].shootDelay = Math.max(30, enemies[i].shootDelay - 20);
                enemies[i].speed += 0.5;
            }
            
            // Spawn boss
            createBoss();
            
            // Update UI
            updateUI();
        }
        
        function gameOver() {
            gameActive = false;
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        
        function levelComplete() {
            gameActive = false;
            document.getElementById('levelCompleteScreen').style.display = 'block';
        }
        
        function restartGame() {
            createLevel(levelConfig.currentLevel);
            document.getElementById('gameOverScreen').style.display = 'none';
            gameActive = true;
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw background
            ctx.fillStyle = '#87CEEB'; // Sky blue background as placeholder
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw platforms
            ctx.fillStyle = '#8B4513'; // Brown for platforms
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                ctx.fillRect(platform.x - platformScroll, platform.y, platform.width, platform.height);
            }
            
            // Draw lockers
            for (let i = 0; i < lockers.length; i++) {
                const locker = lockers[i];
                ctx.fillStyle = locker.searched ? '#555555' : '#999999';
                ctx.fillRect(locker.x - platformScroll, locker.y, locker.width, locker.height);
                
                // Draw locker icon based on type
                ctx.fillStyle = locker.searched ? '#555555' : 
                               (locker.type === 'ammo' ? '#FF0000' : 
                                locker.type === 'armor' ? '#0000FF' : '#FFFF00');
                ctx.fillRect(locker.x - platformScroll + locker.width/4, locker.y + locker.height/4, locker.width/2, locker.height/2);
            }
            
            // Draw crates
            ctx.fillStyle = '#A0522D'; // Sienna for crates
            for (let i = 0; i < crates.length; i++) {
                const crate = crates[i];
                ctx.fillRect(crate.x - platformScroll, crate.y, crate.width, crate.height);
                
                // Draw crate details
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.strokeRect(crate.x - platformScroll + 5, crate.y + 5, crate.width - 10, crate.height - 10);
            }
            
            // Draw doors
            for (let i = 0; i < doors.length; i++) {
                const door = doors[i];
                ctx.fillStyle = door.isOpen ? '#00FF00' : '#FF0000';
                ctx.fillRect(door.x - platformScroll, door.y, door.width, door.height);
                
                // Draw door details
                ctx.fillStyle = '#000000';
                ctx.fillRect(door.x - platformScroll + door.width/2 - 5, door.y + door.height/2 - 15, 10, 30);
            }
            
            // Draw bullets
            ctx.fillStyle = '#FFFF00'; // Yellow for player bullets
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            }
            
            // Draw enemy bullets
            ctx.fillStyle = '#FF0000'; // Red for enemy bullets
            for (let i = 0; i < enemyBullets.length; i++) {
                const bullet = enemyBullets[i];
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            }
            
            // Draw enemies
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                ctx.fillStyle = enemy.isHit ? '#FF6347' : '#FF0000'; // Red for enemies, lighter when hit
                ctx.fillRect(enemy.x - platformScroll, enemy.y, enemy.width, enemy.height);
                
                // Draw enemy face direction
                ctx.fillStyle = '#000000';
                const eyeX = enemy.direction > 0 ? enemy.x - platformScroll + 3*enemy.width/4 : enemy.x - platformScroll + enemy.width/4;
                ctx.fillRect(eyeX, enemy.y + 15, 5, 5);
                
                // Draw enemy health bar
                const healthPercent = enemy.health / (30 + levelConfig.currentLevel * 10);
                ctx.fillStyle = '#000000';
                ctx.fillRect(enemy.x - platformScroll, enemy.y - 10, enemy.width, 5);
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(enemy.x - platformScroll, enemy.y - 10, enemy.width * healthPercent, 5);
            }
            
            // Draw boss
            if (boss) {
                ctx.fillStyle = boss.isHit ? '#8B0000' : '#800000'; // Dark red for boss
                ctx.fillRect(boss.x - platformScroll, boss.y, boss.width, boss.height);
                
                // Draw boss details
                ctx.fillStyle = '#000000';
                ctx.fillRect(boss.x - platformScroll + 15, boss.y + 20, 10, 10); // Left eye
                ctx.fillRect(boss.x - platformScroll + boss.width - 25, boss.y + 20, 10, 10); // Right eye
                ctx.fillRect(boss.x - platformScroll + 20, boss.y + 50, boss.width - 40, 5); // Mouth
                
                // Boss health bar
                const bossHealthPercent = boss.health / boss.maxHealth;
                ctx.fillStyle = '#000000';
                ctx.fillRect(boss.x - platformScroll, boss.y - 20, boss.width, 10);
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(boss.x - platformScroll, boss.y - 20, boss.width * bossHealthPercent, 10);
            }
            
            // Draw player
            ctx.fillStyle = player.isHit ? '#ADD8E6' : '#0000FF'; // Blue for player, lighter when hit
            
            const playerHeight = player.isCrouching ? player.height / 2 : player.height;
            const playerY = player.isCrouching ? player.y + player.height / 2 : player.y;
            
            ctx.fillRect(player.x, playerY, player.width, playerHeight);
            
            // Draw player direction
            ctx.fillStyle = '#FFFFFF';
            const playerEyeX = player.direction > 0 ? player.x + 3*player.width/4 : player.x + player.width/4;
            ctx.fillRect(playerEyeX, playerY + 15, 5, 5);
            
            // Draw power-up effect if active
            if (player.powerUpActive) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, playerY + playerHeight/2, playerHeight, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw HUD info
            renderHUD();
        }
        
        function renderHUD() {
            // Draw power-up timer if active
            if (player.powerUpActive) {
                const powerUpSeconds = Math.ceil(player.powerUpTimer / 60);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10, 100, 200, 30);
                ctx.fillStyle = '#FFFF00';
                ctx.font = '16px Arial';
                ctx.fillText(`Power-Up: ${powerUpSeconds}s`, 20, 120);
            }
        }
        
        function updateUI() {
            document.getElementById('healthDisplay').textContent = player.health;
            document.getElementById('ammoDisplay').textContent = player.ammo;
            document.getElementById('armorDisplay').textContent = player.armor;
            document.getElementById('keysDisplay').textContent = player.keys;
            document.getElementById('levelDisplay').textContent = levelConfig.currentLevel;
        }
        
        function handleKeyDown(e) {
            if (!gameActive) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                    player.velocityX = -PLAYER_SPEED;
                    player.direction = -1;
                    break;
                case 'ArrowRight':
                case 'd':
                    player.velocityX = PLAYER_SPEED;
                    player.direction = 1;
                    break;
                case 'ArrowUp':
                case 'w':
                    if (!player.isJumping) {
                        player.velocityY = -JUMP_FORCE;
                        player.isJumping = true;
                    }
                    break;
                case 'ArrowDown':
                case 's':
                    player.isCrouching = true;
                    break;
                case ' ':
                    playerShoot();
                    break;
                case 'e':
                    // Interact with lockers/doors
                    break;
            }
        }
        
        function handleKeyUp(e) {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                    if (player.velocityX < 0) player.velocityX = 0;
                    break;
                case 'ArrowRight':
                case 'd':
                    if (player.velocityX > 0) player.velocityX = 0;
                    break;
                case 'ArrowDown':
                case 's':
                    player.isCrouching = false;
                    break;
            }
        }
        
        // Scroll the platforms and objects
        function scrollLevel() {
            if (player.x > CANVAS_WIDTH / 3) {
                const scrollAmount = PLATFORM_SPEED;
                platformScroll += scrollAmount;
                player.x -= scrollAmount;
            }
        }
        
        // Start the game when page loads
        window.onload = init;
		
		
		---------------------------------------------------------
		
		
		// ==========================================
// IMAGE LOADING IMPROVEMENTS
// ==========================================

// Create game assets folder structure and image loading system
function loadGameAssets() {
    // Replace placeholder images with actual game sprites
    backgroundImage.src = '/api/placeholder/1920/1080'; // Replace with actual background
    playerSprite.src = '/api/placeholder/40/80';        // Replace with actual player sprite
    enemySprite.src = '/api/placeholder/40/80';         // Replace with actual enemy sprite
    crateSprite.src = '/api/placeholder/60/60';         // Replace with actual crate sprite
    lockerSprite.src = '/api/placeholder/50/80';        // Replace with actual locker sprite
    doorSprite.src = '/api/placeholder/80/120';         // Replace with actual door sprite
    bossSprite.src = '/api/placeholder/80/120';         // Replace with actual boss sprite
    
    // Add weapon sprites
    bulletSprite = new Image();
    bulletSprite.src = '/api/placeholder/10/5';         // Replace with actual bullet sprite
    enemyBulletSprite = new Image();
    enemyBulletSprite.src = '/api/placeholder/8/4';     // Replace with actual enemy bullet sprite
    
    // Add effect sprites
    explosionSprite = new Image();
    explosionSprite.src = '/api/placeholder/50/50';     // Replace with actual explosion sprite
    
    // Track loaded assets
    let assetsToLoad = 9;
    let assetsLoaded = 0;
    
    function assetLoaded() {
        assetsLoaded++;
        if (assetsLoaded === assetsToLoad) {
            console.log('All assets loaded!');
            startGame();
        }
    }
    
    // Add load event listeners to all images
    backgroundImage.onload = assetLoaded;
    playerSprite.onload = assetLoaded;
    enemySprite.onload = assetLoaded;
    crateSprite.onload = assetLoaded;
    lockerSprite.onload = assetLoaded;
    doorSprite.onload = assetLoaded;
    bossSprite.onload = assetLoaded;
    bulletSprite.onload = assetLoaded;
    enemyBulletSprite.onload = assetLoaded;
}

// ==========================================
// SOUND SYSTEM
// ==========================================

// Sound effects management
let audioContext = null;
let sounds = {};

function initAudio() {
    try {
        // Create audio context
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Load sound effects
        loadSound('shoot', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js'); // Replace with actual URL
        loadSound('hit', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js');    // Replace with actual URL
        loadSound('jump', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js');   // Replace with actual URL
        loadSound('pickup', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js'); // Replace with actual URL
        loadSound('door', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js');   // Replace with actual URL
        loadSound('explosion', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js'); // Replace with actual URL
        loadSound('boss', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js');   // Replace with actual URL
        loadSound('powerup', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js'); // Replace with actual URL
        loadSound('gameover', 'https://cdnjs.cloudflare.com/ajax/libs/placeholder-loading/0.5.0/placeholders.min.js'); // Replace with actual URL
    } catch (e) {
        console.error('Web Audio API not supported:', e);
    }
}

function loadSound(name, url) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
            sounds[name] = audioBuffer;
        })
        .catch(error => console.error('Error loading sound:', error));
}

function playSound(name, volume = 1.0) {
    if (!audioContext || !sounds[name]) return;
    
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    
    const gainNode = audioContext.createGain();
    gainNode.gain.value = volume;
    
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    source.start(0);
    return source;
}

// ==========================================
// PARTICLE EFFECTS SYSTEM
// ==========================================

// Add particle effects for visual feedback
let particles = [];

class Particle {
    constructor(x, y, color, size, velocityX, velocityY, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = size;
        this.velocityX = velocityX;
        this.velocityY = velocityY;
        this.life = life;
        this.maxLife = life;
    }
    
    update() {
        this.x += this.velocityX;
        this.y += this.velocityY;
        this.velocityY += 0.1; // Gravity
        this.life--;
        this.size = Math.max(0, this.size * (this.life / this.maxLife));
        return this.life > 0;
    }
    
    draw(ctx) {
        const alpha = this.life / this.maxLife;
        ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

function createExplosion(x, y, color, count = 20, size = 5) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 3;
        const velocityX = Math.cos(angle) * speed;
        const velocityY = Math.sin(angle) * speed;
        const life = 30 + Math.random() * 30;
        
        particles.push(new Particle(
            x, 
            y, 
            color, 
            size * (0.5 + Math.random() * 0.5), 
            velocityX, 
            velocityY, 
            life
        ));
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        if (!particles[i].update()) {
            particles.splice(i, 1);
        }
    }
}

function drawParticles() {
    for (let i = 0; i < particles.length; i++) {
        particles[i].draw(ctx);
    }
}

// ==========================================
// IMPROVED ANIMATION SYSTEM
// ==========================================

// Animation system for sprites
class SpriteAnimation {
    constructor(sprite, frameWidth, frameHeight, numFrames, frameRate) {
        this.sprite = sprite;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
        this.numFrames = numFrames;
        this.frameRate = frameRate;
        this.currentFrame = 0;
        this.frameCounter = 0;
    }
    
    update() {
        this.frameCounter++;
        if (this.frameCounter >= this.frameRate) {
            this.frameCounter = 0;
            this.currentFrame = (this.currentFrame + 1) % this.numFrames;
        }
    }
    
    draw(ctx, x, y, width, height, direction = 1) {
        const sourceX = this.currentFrame * this.frameWidth;
        const sourceY = 0;
        
        ctx.save();
        if (direction < 0) {
            ctx.translate(x + width, y);
            ctx.scale(-1, 1);
            ctx.drawImage(
                this.sprite,
                sourceX, sourceY, this.frameWidth, this.frameHeight,
                0, 0, width, height
            );
        } else {
            ctx.drawImage(
                this.sprite,
                sourceX, sourceY, this.frameWidth, this.frameHeight,
                x, y, width, height
            );
        }
        ctx.restore();
    }
}

// Player animations
let playerAnimations = {
    idle: null,
    run: null,
    jump: null,
    crouch: null,
    shoot: null
};

function initPlayerAnimations() {
    // These would be replaced with actual sprite sheets
    playerAnimations.idle = new SpriteAnimation(playerSprite, 40, 80, 1, 10);
    playerAnimations.run = new SpriteAnimation(playerSprite, 40, 80, 1, 5);
    playerAnimations.jump = new SpriteAnimation(playerSprite, 40, 80, 1, 10);
    playerAnimations.crouch = new SpriteAnimation(playerSprite, 40, 40, 1, 10);
    playerAnimations.shoot = new SpriteAnimation(playerSprite, 40, 80, 1, 5);
}

// ==========================================
// ENHANCED GAME MECHANICS
// ==========================================

// Double jump ability
function updatePlayerJump() {
    if (player.jumpCount < 2 && player.keys >= 3) { // Double jump unlocked with 3+ keys
        player.velocityY = -JUMP_FORCE * 0.8; // Slightly weaker second jump
        player.jumpCount++;
        playSound('jump', 0.7);
        
        // Create jump dust effect
        createExplosion(
            player.x + player.width / 2,
            player.y + player.height,
            [200, 200, 200], // Gray dust
            10,
            3
        );
    }
}

// Dash ability
function playerDash() {
    if (player.dashCooldown <= 0 && player.armor >= 5) { // Dash unlocked with 5+ armor
        player.isDashing = true;
        player.dashTimer = 10;
        player.dashCooldown = 120; // 2 seconds at 60fps
        player.invulnerable = true;
        player.invulnerableTimer = 15;
        
        // Create dash effect
        createExplosion(
            player.x + player.width / 2,
            player.y + player.height / 2,
            [0, 100, 255], // Blue trail
            15,
            4
        );
        
        // Apply dash force
        player.velocityX = PLAYER_SPEED * 3 * player.direction;
        
        playSound('powerup', 0.5);
    }
}

// Power-up system enhancements
const POWERUPS = {
    SPEED: 0,
    DAMAGE: 1,
    SHIELD: 2
};

function activatePowerUp(type) {
    player.powerUpActive = true;
    player.powerUpTimer = 60 * 30; // 30 seconds
    player.powerUpType = type;
    
    switch (type) {
        case POWERUPS.SPEED:
            player.speedMultiplier = 1.5;
            break;
        case POWERUPS.DAMAGE:
            player.damageMultiplier = 2;
            break;
        case POWERUPS.SHIELD:
            player.shield = true;
            break;
    }
    
    playSound('powerup', 0.8);
}

// Update player mechanics
function enhancedPlayerUpdate() {
    // Apply gravity
    player.velocityY += GRAVITY;
    
    // Apply friction
    player.velocityX *= FRICTION;
    
    // Apply dash mechanic
    if (player.isDashing) {
        player.dashTimer--;
        if (player.dashTimer <= 0) {
            player.isDashing = false;
        }
    } else {
        // Apply regular movement
        if (player.moveLeft) {
            player.velocityX = -PLAYER_SPEED * (player.speedMultiplier || 1);
            player.direction = -1;
        }
        if (player.moveRight) {
            player.velocityX = PLAYER_SPEED * (player.speedMultiplier || 1);
            player.direction = 1;
        }
    }
    
    // Update dash cooldown
    if (player.dashCooldown > 0) {
        player.dashCooldown--;
    }
    
    // Update invulnerability
    if (player.invulnerable) {
        player.invulnerableTimer--;
        if (player.invulnerableTimer <= 0) {
            player.invulnerable = false;
        }
    }
    
    // Update position
    player.x += player.velocityX;
    player.y += player.velocityY;
    
    // Constrain player to canvas
    if (player.x < 0) player.x = 0;
    if (player.x > CANVAS_WIDTH / 2) player.x = CANVAS_WIDTH / 2;
    
    // Handle hit animation
    if (player.isHit) {
        player.hitTimer--;
        if (player.hitTimer <= 0) {
            player.isHit = false;
        }
    }
    
    // Check for game over
    if (player.health <= 0) {
        gameOver();
    }
    
    // Update animations
    if (player.isJumping) {
        playerAnimations.jump.update();
    } else if (player.isCrouching) {
        playerAnimations.crouch.update();
    } else if (Math.abs(player.velocityX) > 0.5) {
        playerAnimations.run.update();
    } else {
        playerAnimations.idle.update();
    }
    
    if (player.isShooting) {
        playerAnimations.shoot.update();
    }
}

// ==========================================
// IMPROVED RENDERING
// ==========================================

// Enhanced rendering with sprite animations
function drawPlayer() {
    const playerHeight = player.isCrouching ? player.height / 2 : player.height;
    const playerY = player.isCrouching ? player.y + player.height / 2 : player.y;
    
    // Flash effect when hit or invulnerable
    if ((player.isHit || player.invulnerable) && Math.floor(Date.now() / 100) % 2 === 0) {
        ctx.globalAlpha = 0.5;
    }
    
    // Choose appropriate animation
    if (player.isJumping) {
        playerAnimations.jump.draw(ctx, player.x, playerY, player.width, playerHeight, player.direction);
    } else if (player.isCrouching) {
        playerAnimations.crouch.draw(ctx, player.x, playerY, player.width, playerHeight, player.direction);
    } else if (Math.abs(player.velocityX) > 0.5) {
        playerAnimations.run.draw(ctx, player.x, playerY, player.width, playerHeight, player.direction);
    } else {
        playerAnimations.idle.draw(ctx, player.x, playerY, player.width, playerHeight, player.direction);
    }
    
    ctx.globalAlpha = 1.0;
    
    // Draw power-up effect if active
    if (player.powerUpActive) {
        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(player.x + player.width/2, playerY + playerHeight/2, playerHeight, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Draw shield if active
    if (player.shield) {
        ctx.strokeStyle = 'rgba(0, 200, 255, 0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x + player.width/2, playerY + playerHeight/2, playerHeight * 0.8, 0, Math.PI * 2);
        ctx.stroke();
    }
}

// Draw using actual sprites instead of colored rectangles
function improvedRender() {
    // Clear canvas
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw parallax background (3 layers)
    drawBackground();
    
    // Draw platforms
    for (let i = 0; i < platforms.length; i++) {
        const platform = platforms[i];
        // Use pattern or stretched sprite for platform
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(platform.x - platformScroll, platform.y, platform.width, platform.height);
    }
    
    // Draw lockers
    for (let i = 0; i < lockers.length; i++) {
        const locker = lockers[i];
        ctx.drawImage(
            lockerSprite,
            locker.searched ? 50 : 0, 0, 50, 80,
            locker.x - platformScroll, locker.y, locker.width, locker.height
        );
    }
    
    // Draw crates
    for (let i = 0; i < crates.length; i++) {
        const crate = crates[i];
        ctx.drawImage(
            crateSprite,
            crate.x - platformScroll, crate.y, crate.width, crate.height
        );
    }
    
    // Draw doors
    for (let i = 0; i < doors.length; i++) {
        const door = doors[i];
        ctx.drawImage(
            doorSprite,
            door.isOpen ? 80 : 0, 0, 80, 120,
            door.x - platformScroll, door.y, door.width, door.height
        );
    }
    
    // Draw bullets
    for (let i = 0; i < bullets.length; i++) {
        const bullet = bullets[i];
        ctx.drawImage(
            bulletSprite,
            bullet.x, bullet.y, bullet.width, bullet.height
        );
    }
    
    // Draw enemy bullets
    for (let i = 0; i < enemyBullets.length; i++) {
        const bullet = enemyBullets[i];
        ctx.drawImage(
            enemyBulletSprite,
            bullet.x, bullet.y, bullet.width, bullet.height
        );
    }
    
    // Draw enemies
    for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        
        // Flash effect when hit
        if (enemy.isHit && Math.floor(Date.now() / 100) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        ctx.drawImage(
            enemySprite,
            enemy.x - platformScroll, enemy.y, enemy.width, enemy.height
        );
        
        ctx.globalAlpha = 1.0;
        
        // Draw enemy health bar
        const healthPercent = enemy.health / (30 + levelConfig.currentLevel * 10);
        ctx.fillStyle = '#000000';
        ctx.fillRect(enemy.x - platformScroll, enemy.y - 10, enemy.width, 5);
        ctx.fillStyle = '#00FF00';
        ctx.fillRect(enemy.x - platformScroll, enemy.y - 10, enemy.width * healthPercent, 5);
    }
    
    // Draw boss
    if (boss) {
        // Flash effect when hit
        if (boss.isHit && Math.floor(Date.now() / 100) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        ctx.drawImage(
            bossSprite,
            boss.x - platformScroll, boss.y, boss.width, boss.height
        );
        
        ctx.globalAlpha = 1.0;
        
        // Boss health bar
        const bossHealthPercent = boss.health / boss.maxHealth;
        ctx.fillStyle = '#000000';
        ctx.fillRect(boss.x - platformScroll - 20, boss.y - 20, boss.width + 40, 10);
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(boss.x - platformScroll - 20, boss.y - 20, (boss.width + 40) * bossHealthPercent, 10);
    }
    
    // Draw particles
    drawParticles();
    
    // Draw player
    drawPlayer();
    
    // Draw HUD
    renderHUD();
}

// Parallax background
function drawBackground() {
    // Draw sky
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw distant mountains (slowest parallax)
    ctx.fillStyle = '#6B8E23';
    for (let i = 0; i < 5; i++) {
        const mountainX = (i * 500 - (platformScroll * 0.1) % 500);
        const mountainHeight = 200 + Math.sin(i * 1.5) * 100;
        
        ctx.beginPath();
        ctx.moveTo(mountainX - 100, CANVAS_HEIGHT);
        ctx.lineTo(mountainX + 250, CANVAS_HEIGHT - mountainHeight);
        ctx.lineTo(mountainX + 600, CANVAS_HEIGHT);
        ctx.closePath();
        ctx.fill();
    }
    
    // Draw middle layer hills (medium parallax)
    ctx.fillStyle = '#2E8B57';
    for (let i = 0; i < 7; i++) {
        const hillX = (i * 400 - (platformScroll * 0.3) % 400);
        const hillHeight = 150 + Math.sin(i * 2.5) * 50;
        
        ctx.beginPath();
        ctx.moveTo(hillX - 50, CANVAS_HEIGHT);
        ctx.quadraticCurveTo(hillX + 200, CANVAS_HEIGHT - hillHeight * 2, hillX + 450, CANVAS_HEIGHT);
        ctx.closePath();
        ctx.fill();
    }
    
    // Draw closest layer (fastest parallax)
    ctx.fillStyle = '#3CB371';
    for (let i = 0; i < 10; i++) {
        const bushX = (i * 300 - (platformScroll * 0.6) % 300);
        const bushHeight = 100 + Math.sin(i * 3.5) * 30;
        
        ctx.beginPath();
        ctx.moveTo(bushX - 30, CANVAS_HEIGHT);
        ctx.quadraticCurveTo(bushX + 150, CANVAS_HEIGHT - bushHeight, bushX + 330, CANVAS_HEIGHT);
        ctx.closePath();
        ctx.fill();
    }
}

// Enhanced HUD
function enhancedHUD() {
    // Draw stats
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(10, 10, 200, 130);
    
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '16px Arial';
    ctx.fillText(`Level: ${levelConfig.currentLevel}`, 20, 35);
    
    // Health bar
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(20, 45, 150 * (player.health / 100), 10);
    ctx.strokeStyle = '#FFFFFF';
    ctx.strokeRect(20, 45, 150, 10);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText(`Health: ${player.health}`, 20, 70);
    
    // Ammo counter
    ctx.fillStyle = '#FFFF00';
    ctx.fillRect(20, 80, 150 * (player.ammo / 100), 10);
    ctx.strokeStyle = '#FFFFFF';
    ctx.strokeRect(20, 80, 150, 10);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText(`Ammo: ${player.ammo}`, 20, 105);
    
    // Armor indicator
    ctx.fillStyle = '#0000FF';
    ctx.fillRect(20, 115, 15 * player.armor, 10);
    ctx.strokeStyle = '#FFFFFF';
    ctx.strokeRect(20, 115, 150, 10);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText(`Armor: ${player.armor}/10`, 20, 140);
    
    // Keys
    for (let i = 0; i < player.keys; i++) {
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        ctx.moveTo(20 + i * 20, 155);
        ctx.lineTo(25 + i * 20, 150);
        ctx.lineTo(35 + i * 20, 150);
        ctx.lineTo(35 + i * 20, 165);
        ctx.lineTo(30 + i * 20, 170);
        ctx.lineTo(20 + i * 20, 170);
        ctx.closePath();
        ctx.fill();
    }
    
    // Power-up indicator
    if (player.powerUpActive) {
        const powerUpSeconds = Math.ceil(player.powerUpTimer / 60);
        let powerUpName;
        
        switch (player.powerUpType) {
            case POWERUPS.SPEED: powerUpName = "Speed Boost"; break;
            case POWERUPS.DAMAGE: powerUpName = "Damage Boost"; break;
            case POWERUPS.SHIELD: powerUpName = "Shield"; break;
            default: powerUpName = "Power-Up";
        }
        
        ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
        ctx.fillRect(10, 180, 200, 30);
        ctx.fillStyle = '#000000';
        ctx.fillText(`${powerUpName}: ${powerUpSeconds}s`, 20, 200);
    }
    
    // Dash cooldown
    if (player.dashCooldown > 0 && player.armor >= 5) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(10, 220, 200, 30);
        
        const dashReady = player.dashCooldown <= 0;
        ctx.fillStyle = dashReady ? '#00FF00' : '#FF0000';
        ctx.fillText(`Dash: ${dashReady ? 'Ready' : Math.ceil(player.dashCooldown / 60) + 's'}`, 20, 240);
    }
    
    // Double jump indicator
    if (player.keys >= 3) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(10, 260, 200, 30);
        
        ctx.fillStyle = '#00FF00';
        ctx.fillText(`Double Jump: ${player.jumpCount < 2 ? 'Ready' : 'Used'}`, 20, 280);
    }
    
    // Minimap
    drawMinimap();
}

// Add minimap
function drawMinimap() {
    const minimapWidth = 200;
    const minimapHeight = 80;
    const minimapX = CANVAS_WIDTH - minimapWidth - 10;
    const minimapY = 10;
    
    // Background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(minimapX, minimapY, minimapWidth, minimapHeight);
    
    // Calculate scale
    const levelWidth = platforms[0].width;
    const scale = minimapWidth / levelWidth;
    
    // Draw platforms
    ctx.fillStyle = '#8B4513';
    for (let i = 0; i < platforms.length; i++) {
        const platform = platforms[i];
        ctx.fillRect(
            minimapX + platform.x * scale,
            minimapY + platform.y * scale * 0.1,
            platform.width * scale,
            platform.height * scale * 0.1
        );
    }
    
    // Draw doors
    ctx.fillStyle = '#FF0000';
    for (let i = 0; i < doors.length; i++) {
        const door = doors[i];
        ctx.fillRect(
            minimapX + door.x * scale,
            minimapY + door.y * scale * 0.1,
            door.width * scale,
            door.height * scale * 0.1
        );
    }
    
    // Draw boss
    if (boss) {
        ctx.fillStyle = '#800000';
        ctx.fillRect(
            minimapX + boss.x * scale,
            minimapY + boss.y * scale * 0.1,
            boss.width * scale,
            boss.height * scale * 0.1
        );
    }
    
    // Draw player position
    const viewportStart = platformScroll;
    const viewportEnd = platformScroll + CANVAS_WIDTH;
    
    // Draw viewport rectangle
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 1;
    ctx.strokeRect(
        minimapX + viewportStart * scale,
        minimapY,
        (viewportEnd - viewportStart) * scale,
        minimapHeight
    );
    
    // Draw player
    ctx.fillStyle = '#0000FF';
    ctx.fillRect(
        minimapX + (platformScroll + player.x) * scale - 1,
        minimapY + player.y * scale * 0.1 - 1,
        3,
        3
    );
}

// ==========================================
// ENHANCED CONTROLS
// ==========================================

function enhancedControls() {
    // Add support for gamepad
    window.