<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Gauntlet 3D</title>
    <style>
        /* CSS remains the same as provided */
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 10;
        }
        #playerStats {
            display: flex;
            gap: 20px;
        }
        .playerInfo {
            padding: 5px;
            border-radius: 5px;
            background-color: rgba(0,0,0,0.5);
        }
        #messageLog {
            position: absolute;
            bottom: 70px; /* Adjusted position */
            left: 50%;
            transform: translateX(-50%);
            color: gold; /* Changed color */
            font-size: 24px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            z-index: 10;
            min-height: 30px; /* Ensure space even when empty */
            opacity: 1; /* Start visible */
            pointer-events: none; /* Prevent stealing clicks */
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
             pointer-events: none;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #characterSelection {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
        }
        .characterCard {
            background-color: rgba(50,50,50,0.8);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s;
            width: 180px; /* Slightly smaller */
        }
        .characterCard:hover {
            transform: scale(1.05);
            background-color: rgba(70,70,70,0.8);
        }
        .characterCard h3 {
            margin-top: 0;
            color: gold;
        }
        .characterStats {
            text-align: left;
            margin-top: 10px;
            font-size: 14px; /* Smaller stats text */
        }
        #gameOverScreen, #levelCompleteScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none; /* Start hidden */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        button {
            background-color: #8a5a00;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #b87700;
        }
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex; /* Start shown */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }
        #loadingBar {
            width: 300px;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            margin-top: 20px;
            overflow: hidden;
        }
        #loadingProgress {
            height: 100%;
            width: 0%;
            background-color: gold;
            transition: width 0.3s;
        }
        .healthBar {
            width: 100%;
            height: 8px;
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        .healthFill {
            height: 100%;
            background-color: #0f0; /* Green */
            transition: width 0.3s;
        }
         /* Enemy and Generator Health Bars are created via Babylon GUI */
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <div id="gameUI">
        <div id="playerStats">
            <!-- Will be populated with player info -->
        </div>
    </div>

    <div id="messageLog"></div>

    <div id="controls">
        <p>WASD: Move | SPACE: Attack | E: Use Potion | F: Use Special | Mouse: Aim</p>
    </div>

    <div id="startScreen">
        <h1>GAUNTLET 3D</h1>
        <p>Choose your character to begin the adventure</p>
        <div id="characterSelection">
            <div class="characterCard" data-type="WARRIOR">
                <h3>WARRIOR</h3>
                <p>A mighty melee fighter with high strength</p>
                <div class="characterStats">
                    <p>Health: ★★★★☆ (800)</p>
                    <p>Attack: ★★★★☆ (40)</p>
                    <p>Magic: ★☆☆☆☆ (10)</p>
                    <p>Speed: ★★☆☆☆ (5)</p>
                </div>
            </div>
            <div class="characterCard" data-type="VALKYRIE">
                <h3>VALKYRIE</h3>
                <p>A balanced fighter with shield defense</p>
                <div class="characterStats">
                    <p>Health: ★★★☆☆ (600)</p>
                    <p>Attack: ★★★☆☆ (30)</p>
                    <p>Magic: ★★☆☆☆ (20)</p>
                    <p>Speed: ★★★☆☆ (7)</p>
                </div>
            </div>
            <div class="characterCard" data-type="WIZARD">
                <h3>WIZARD</h3>
                <p>A powerful spellcaster with magical attacks</p>
                <div class="characterStats">
                    <p>Health: ★★☆☆☆ (400)</p>
                    <p>Attack: ★☆☆☆☆ (10)</p>
                    <p>Magic: ★★★★★ (50)</p>
                    <p>Speed: ★★☆☆☆ (5)</p>
                </div>
            </div>
            <div class="characterCard" data-type="ELF">
                <h3>ELF</h3>
                <p>An agile archer with high speed</p>
                <div class="characterStats">
                    <p>Health: ★★☆☆☆ (450)</p>
                    <p>Attack: ★★★☆☆ (25)</p>
                    <p>Magic: ★★★☆☆ (30)</p>
                    <p>Speed: ★★★★★ (10)</p>
                </div>
            </div>
        </div>
    </div>

    <div id="gameOverScreen">
        <h1>GAME OVER</h1>
        <p id="gameOverMessage">Your quest has ended...</p>
        <button id="restartButton">Play Again</button>
    </div>

    <div id="levelCompleteScreen">
        <h1>LEVEL COMPLETE</h1>
        <p>You've conquered this dungeon!</p>
        <div id="levelStats">Score: <span id="finalLevelScore">0</span></div>
        <button id="nextLevelButton">Enter Next Dungeon</button>
    </div>

    <div id="loadingScreen">
        <h1>LOADING GAUNTLET 3D</h1>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
        <p id="loadingText">Preparing the dungeon...</p>
    </div>

    <!-- Babylon.js Libraries -->
    <script src="babylon.js"></script>
    <script src="babylonjs.loaders.min.js"></script>
    <script src="babylon.gui.min.js"></script>
    <!-- Physics Engine -->
    <script src="cannon.js"></script>
    <!-- Sound Engine -->
    <script src="howler.min.js"></script>

    <script>
        // Game Constants
        const GAME_STATES = {
            LOADING: 0,
            START_SCREEN: 1,
            PLAYING: 2,
            GAME_OVER: 3,
            LEVEL_COMPLETE: 4
        };

        // Character classes
        const CHARACTER_CLASSES = {
            WARRIOR: { name: "Warrior", health: 800, attack: 40, magic: 10, speed: 5, special: "Whirlwind Attack", color: new BABYLON.Color3(0.8, 0.1, 0.1), shotCooldown: 600, specialCooldown: 12000 },
            VALKYRIE: { name: "Valkyrie", health: 600, attack: 30, magic: 20, speed: 7, special: "Shield Bash", color: new BABYLON.Color3(0.1, 0.6, 0.8), shotCooldown: 500, specialCooldown: 10000 },
            WIZARD: { name: "Wizard", health: 400, attack: 10, magic: 50, speed: 5, special: "Arcane Nova", color: new BABYLON.Color3(0.6, 0.1, 0.8), shotCooldown: 700, specialCooldown: 15000 },
            ELF: { name: "Elf", health: 450, attack: 25, magic: 30, speed: 10, special: "Rapid Fire", color: new BABYLON.Color3(0.1, 0.8, 0.3), shotCooldown: 350, specialCooldown: 8000 }
        };

        // Enemy types
        const ENEMY_TYPES = {
            GHOST: { name: "Ghost", health: 60, attack: 15, speed: 3.5, color: new BABYLON.Color3(0.85, 0.85, 0.95), score: 10, meshType: 'sphere', size: 0.8, alpha: 0.7 },
            GRUNT: { name: "Grunt", health: 120, attack: 20, speed: 2.8, color: new BABYLON.Color3(0.8, 0.4, 0), score: 20, meshType: 'box', size: [0.8, 1.2, 0.8] },
            DEMON: { name: "Demon", health: 180, attack: 30, speed: 2.2, color: new BABYLON.Color3(0.9, 0.1, 0), score: 30, meshType: 'box', size: [1, 1.5, 1] },
            SORCERER: { name: "Sorcerer", health: 90, attack: 35, speed: 3.0, color: new BABYLON.Color3(0.5, 0, 0.5), score: 40, meshType: 'cylinder', size: { diameter: 0.8, height: 1.5 }, canShoot: true, shootRange: 15, shootCooldown: 2500 },
            DEATH: { name: "Death", health: 400, attack: 50, speed: 1.8, color: new BABYLON.Color3(0.1, 0.1, 0.1), score: 100, meshType: 'box', size: [1.2, 2, 1.2], isInvulnerable: false, specialAttack: false, alpha: 0.8 } // Made Death vulnerable, removed special attack for simplicity
        };

        // Item types
        const ITEM_TYPES = {
            FOOD: { name: "Food", health: 100, color: new BABYLON.Color3(0, 0.8, 0), meshType: 'box', size: [0.8, 0.3, 0.8], score: 5 },
            POTION: { name: "Potion", special: "potion", color: new BABYLON.Color3(0, 0.5, 0.8), meshType: 'cylinder', size: { diameter: 0.5, height: 0.8 }, score: 10 },
            KEY: { name: "Key", special: "key", color: new BABYLON.Color3(0.8, 0.8, 0), meshType: 'box', size: [0.5, 0.5, 0.1], score: 20 },
            TREASURE: { name: "Treasure", score: 50, color: new BABYLON.Color3(0.9, 0.7, 0.1), meshType: 'sphere', size: 0.6 }
        };

        // Game state variables
        let gameState = GAME_STATES.LOADING;
        let currentLevel = 1;
        let player = null;
        let playerClassInfo = null; // Store selected class details
        let enemies = [];
        let projectiles = [];
        let items = [];
        let doors = [];
        let walls = []; // Keep track for potential destruction? Or just collision.
        let generators = [];
        let exitKey = null;
        let exitDoor = null;
        let score = 0;
        let keys = 0;
        let potions = 0;
        let hasExitKey = false;

        // Game engine variables
        let canvas, engine, scene;
        let camera, light;
        let inputMap = {};
        let gameTime = 0; // Simple timer using engine delta time
        let lastMessageTime = 0; // Track time of last message for throttling

        // Sound effects
        let sounds = {};

        // Map generation constants
        const TILE_SIZE = 4;
        const MAP_WIDTH = 20;
        const MAP_HEIGHT = 20;
        let dungeon = []; // 2D array representing the level layout

        // UI Elements
        let playerHealthBarFill; // Reference to the fill element in the player's UI stat block (not GUI)
        let enemyHealthBars = new Map(); // Map enemy ID to its GUI health bar object { healthBar, healthBarFill }
        let generatorHealthBars = new Map(); // Map generator ID to its GUI health bar object { healthBar, healthBarFill }
        let playerStatsDiv, messageLogDiv, gameOverScreen, levelCompleteScreen, startScreen, loadingScreen;
        let advancedTextureGUI; // Single AdvancedDynamicTexture for all overlaid GUI elements

        // Initialize BabylonJS
        window.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('renderCanvas');
            playerStatsDiv = document.getElementById('playerStats');
            messageLogDiv = document.getElementById('messageLog');
            gameOverScreen = document.getElementById('gameOverScreen');
            levelCompleteScreen = document.getElementById('levelCompleteScreen');
            startScreen = document.getElementById('startScreen');
            loadingScreen = document.getElementById('loadingScreen');

            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

            loadGame(); // Start the loading process

            // Use engine's delta time for game time updates within the render loop
            engine.runRenderLoop(function() {
                if (scene && engine && gameState !== GAME_STATES.LOADING) { // Only run if scene exists and not loading
                    let deltaTime = engine.getDeltaTime(); // Time since last frame in ms
                    gameTime += deltaTime; // Update game time

                    if (gameState === GAME_STATES.PLAYING) {
                         updateGame(deltaTime); // Pass delta time to main game update logic
                    }
                    // Only render if the scene hasn't been disposed (e.g., during restart)
                    if (scene && !scene.isDisposed) {
                        scene.render();
                    }
                }
            });

            window.addEventListener('resize', function() {
                engine.resize();
            });
        });

        // Register input
        window.addEventListener('keydown', function(e) { inputMap[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', function(e) { inputMap[e.key.toLowerCase()] = false; });

        // Load game assets and setup
        async function loadGame() {
            gameState = GAME_STATES.LOADING;
            loadingScreen.style.display = 'flex';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';

            let loadingProgress = document.getElementById('loadingProgress');
            let loadingText = document.getElementById('loadingText');
            let progress = 0;

            try {
                // Simulate loading steps with progress updates
                await new Promise(resolve => setTimeout(resolve, 300));
                loadingText.innerText = 'Loading Sounds...';
                await loadSounds(); // Wait for sounds to attempt loading
                progress = 30;
                loadingProgress.style.width = progress + '%';
                await new Promise(resolve => setTimeout(resolve, 300));

                loadingText.innerText = 'Initializing Engine...';
                await setupEngine(); // Setup basic scene, physics, etc.
                progress = 60;
                loadingProgress.style.width = progress + '%';
                await new Promise(resolve => setTimeout(resolve, 300));

                loadingText.innerText = 'Setting up UI Listeners...';
                setupUIListeners(); // Set up button clicks etc.
                progress = 100;
                loadingProgress.style.width = progress + '%';
                await new Promise(resolve => setTimeout(resolve, 500)); // Short pause before showing start screen

                loadingScreen.style.display = 'none';
                startScreen.style.display = 'flex';
                gameState = GAME_STATES.START_SCREEN;

            } catch (error) {
                console.error("Error during game loading:", error);
                loadingText.innerText = 'Error loading game! Please refresh.';
                // Optionally display an error message to the user on the loading screen
            }
        }

        // Load sound effects
        function loadSounds() {
          return new Promise((resolve) => {
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // !! CRITICAL: REPLACE ALL '#' BELOW WITH ACTUAL VALID URLS TO YOUR SOUND FILES !!
            // !!          You need to host these files somewhere accessible.           !!
            // !!          Example: src: ['sounds/background_music.mp3']                !!
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            console.warn("SOUND SYSTEM: Using placeholder URLs. Replace '#' in loadSounds() with actual sound file paths!");
            sounds = {
                background: new Howl({ src: ['#'], loop: true, volume: 0.3, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading background:', err); checkSoundsLoaded(); } }),
                attack_melee: new Howl({ src: ['#'], volume: 0.4, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading attack_melee:', err); checkSoundsLoaded(); } }),
                attack_ranged: new Howl({ src: ['#'], volume: 0.4, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading attack_ranged:', err); checkSoundsLoaded(); } }),
                hit_player: new Howl({ src: ['#'], volume: 0.5, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading hit_player:', err); checkSoundsLoaded(); } }),
                hit_enemy: new Howl({ src: ['#'], volume: 0.3, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading hit_enemy:', err); checkSoundsLoaded(); } }),
                death_enemy: new Howl({ src: ['#'], volume: 0.5, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading death_enemy:', err); checkSoundsLoaded(); } }),
                pickup_item: new Howl({ src: ['#'], volume: 0.6, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading pickup_item:', err); checkSoundsLoaded(); } }),
                pickup_key: new Howl({ src: ['#'], volume: 0.7, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading pickup_key:', err); checkSoundsLoaded(); } }),
                door_open: new Howl({ src: ['#'], volume: 0.5, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading door_open:', err); checkSoundsLoaded(); } }),
                door_locked: new Howl({ src: ['#'], volume: 0.5, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading door_locked:', err); checkSoundsLoaded(); } }),
                special_warrior: new Howl({ src: ['#'], volume: 0.7, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading special_warrior:', err); checkSoundsLoaded(); } }),
                special_valkyrie: new Howl({ src: ['#'], volume: 0.7, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading special_valkyrie:', err); checkSoundsLoaded(); } }),
                special_wizard: new Howl({ src: ['#'], volume: 0.8, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading special_wizard:', err); checkSoundsLoaded(); } }),
                special_elf: new Howl({ src: ['#'], volume: 0.6, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading special_elf:', err); checkSoundsLoaded(); } }),
                levelComplete: new Howl({ src: ['#'], volume: 0.8, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading levelComplete:', err); checkSoundsLoaded(); } }),
                gameOver: new Howl({ src: ['#'], volume: 0.8, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading gameOver:', err); checkSoundsLoaded(); } }),
                potion_use: new Howl({ src: ['#'], volume: 0.6, onload: checkSoundsLoaded, onloaderror: (id, err) => { console.error('Error loading potion_use:', err); checkSoundsLoaded(); } })
            };

            let loadedCount = 0;
            const totalSounds = Object.keys(sounds).length;
            let resolved = false; // Prevent multiple resolves

            function checkSoundsLoaded() {
              loadedCount++;
              // console.log(`Sound processed (${loadedCount}/${totalSounds})`);
              if (!resolved && loadedCount >= totalSounds) { // Use >= in case errors fire quickly
                console.log("All sounds processed (loaded or failed).");
                resolved = true;
                resolve();
              }
            }

            // Timeout failsafe
            setTimeout(() => {
                 if (!resolved) {
                    console.warn(`Sound loading timed out (${loadedCount}/${totalSounds} processed). Proceeding anyway.`);
                    resolved = true;
                    resolve();
                 }
            }, 7000); // 7 second timeout
          });
        }

        function setupUIListeners() {
            // Set up character selection
            let characterCards = document.querySelectorAll('.characterCard');
            characterCards.forEach(card => {
                card.addEventListener('click', function() {
                    let type = this.getAttribute('data-type');
                    if (gameState === GAME_STATES.START_SCREEN) {
                        selectCharacter(type);
                    }
                });
            });

            // Set up restart button
            document.getElementById('restartButton').addEventListener('click', function() {
                if (gameState === GAME_STATES.GAME_OVER) {
                    restartGame();
                }
            });

            // Set up next level button
            document.getElementById('nextLevelButton').addEventListener('click', function() {
                if (gameState === GAME_STATES.LEVEL_COMPLETE) {
                    loadNextLevel();
                }
            });
        }

        // Set up game scene (can be called multiple times for new levels)
        function setupEngine() {
          return new Promise((resolve) => {
            // Dispose previous scene if exists to prevent resource leaks
            if (scene) {
                console.log("Disposing previous scene...");
                scene.dispose();
                scene = null; // Ensure scene is nullified
            }
            // Dispose previous GUI texture if it exists
            if(advancedTextureGUI) {
                console.log("Disposing previous GUI Texture...");
                advancedTextureGUI.dispose();
                advancedTextureGUI = null;
            }

            console.log("Creating new scene...");
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1);
            scene.collisionsEnabled = true; // Enable scene collisions for camera/player
            scene.gravity = new BABYLON.Vector3(0, -9.81 * 2.5, 0); // Slightly stronger gravity? Adjust as needed

            // Set up lighting
            light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;
            light.diffuse = new BABYLON.Color3(0.8, 0.8, 1); // Cool ambient light
            light.groundColor = new BABYLON.Color3(0.4, 0.4, 0.5); // Darker ground ambient

            // Add some fog for atmosphere
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            scene.fogDensity = 0.015; // Controls fog intensity
            scene.fogColor = new BABYLON.Color3(0.1, 0.1, 0.15); // Dark fog color

            // Setup physics - Use Cannon.js
            if (window.CANNON) {
                scene.enablePhysics(scene.gravity, new BABYLON.CannonJSPlugin());
                console.log("Physics enabled.");
            } else {
                console.error("Cannon.js physics engine not found!");
            }

             // Create the single AdvancedDynamicTexture for GUI overlays
            advancedTextureGUI = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            console.log("Fullscreen GUI Texture created.");

            console.log("Engine setup complete.");
            resolve();
          });
        }

        // Select character and start game
        async function selectCharacter(type) {
            if (!CHARACTER_CLASSES[type]) {
                console.error(`Invalid character type selected: ${type}`);
                return;
            }
            startScreen.style.display = 'none';
            playerClassInfo = CHARACTER_CLASSES[type];

            resetFullGameState(); // Reset score, level etc. for a new game
            await setupEngine(); // Ensure engine/scene is ready *before* starting level
            startGameLevel(); // Start the first level
        }

        // Starts or restarts the game at the current level
        function startGameLevel() {
            if (!scene) {
              console.error("Scene not initialized! Cannot start level.");
              return;
            }
            console.log(`Starting Level ${currentLevel}`);
            clearLevel();       // Clear meshes, arrays from previous level (if any)
            generateLevel();    // Create dungeon layout data and meshes
            createPlayer();     // Create the player mesh and data object
            setupPlayerCamera(); // Set up the camera after player exists
            setupUI();          // Initialize UI text/stats display
            lastMessageTime = 0; // Reset message timer
            inputMap = {};       // Reset input map to prevent stuck keys

            // Start background music (if loaded and valid)
            if (sounds.background && sounds.background.state() === 'loaded') {
                 if (!sounds.background.playing()) {
                     sounds.background.play();
                     console.log("Playing background music.");
                 }
            } else if (sounds.background) {
                console.warn("Background music loaded but not playing, state:", sounds.background.state());
            } else {
                console.warn("Background music not loaded or failed to load.");
            }

            gameState = GAME_STATES.PLAYING;
            showMessage(`${playerClassInfo.name} enters the dungeon! LEVEL ${currentLevel}`, 5000);
        }

        // Reset game state for a completely new game
        function resetFullGameState() {
            console.log("Resetting full game state.");
            score = 0;
            keys = 0;
            potions = 3; // Start with 3 potions
            currentLevel = 1;
            hasExitKey = false;
            gameTime = 0; // Reset game timer as well
        }

        // Clear current level entities and scene elements
        function clearLevel() {
            if (!scene) {
                console.warn("Attempted to clear level, but scene does not exist.");
                return;
            }
            console.log("Clearing level entities...");

             // --- Dispose GUI Elements First ---
             if (advancedTextureGUI) {
                 console.log(`Disposing ${enemyHealthBars.size} enemy health bars from GUI.`);
                 enemyHealthBars.forEach(enemyData => {
                     if (enemyData && enemyData.healthBar && !enemyData.healthBar.isDisposed) {
                        advancedTextureGUI.removeControl(enemyData.healthBar); // Remove from texture first
                        enemyData.healthBar.dispose(); // Dispose the control itself
                     }
                 });
                 enemyHealthBars.clear(); // Clear the tracking map

                 console.log(`Disposing ${generatorHealthBars.size} generator health bars from GUI.`);
                 generatorHealthBars.forEach(genData => {
                     if (genData && genData.healthBar && !genData.healthBar.isDisposed) {
                         advancedTextureGUI.removeControl(genData.healthBar); // Remove from texture first
                         genData.healthBar.dispose(); // Dispose the control itself
                     }
                 });
                 generatorHealthBars.clear(); // Clear the tracking map
             } else {
                console.warn("AdvancedTextureGUI not found during clearLevel, cannot dispose health bars.");
             }


            // --- Dispose Meshes and Physics Impostors ---
            console.log("Disposing entity meshes and physics impostors...");
            // Combine arrays for iteration
            let entitiesToClear = [enemies, projectiles, items, walls, doors, generators];
            entitiesToClear.forEach(arr => {
                let count = 0;
                // Iterate backwards for safe removal within loop (though we clear after)
                for(let i = arr.length - 1; i >= 0; i--) {
                    let entity = arr[i];
                     if (entity && entity.mesh) {
                         // Dispose physics first if it exists
                        if (entity.mesh.physicsImpostor) {
                             entity.mesh.physicsImpostor.dispose();
                             entity.mesh.physicsImpostor = null; // Help GC
                        }
                        // Dispose mesh if it exists and is not already disposed
                        if (!entity.mesh.isDisposed()) {
                            entity.mesh.dispose();
                        }
                        entity.mesh = null; // Help GC
                        count++;
                    }
                }
                // console.log(`Disposed ${count} entities from an array.`);
                arr.length = 0; // Clear the array itself
            });

            // Dispose Exit Key if it exists
            if (exitKey && exitKey.mesh && !exitKey.mesh.isDisposed()) {
                 if (exitKey.mesh.physicsImpostor) exitKey.mesh.physicsImpostor.dispose();
                 exitKey.mesh.dispose();
                 console.log("Disposed exit key mesh.");
            }
            exitKey = null;

            // Dispose Exit Door if it exists
            if (exitDoor && exitDoor.mesh && !exitDoor.mesh.isDisposed()) {
                 if (exitDoor.mesh.physicsImpostor) exitDoor.mesh.physicsImpostor.dispose();
                 exitDoor.mesh.dispose();
                 console.log("Disposed exit door mesh.");
            }
            exitDoor = null;

            // Dispose Player mesh if it exists
            if (player && player.mesh && !player.mesh.isDisposed()) {
                if (player.mesh.physicsImpostor) {
                     player.mesh.physicsImpostor.dispose();
                     player.mesh.physicsImpostor = null;
                }
                player.mesh.dispose();
                console.log("Disposed previous player mesh.");
                 // Keep player object for stat carry-over, but clear mesh ref
                 player.mesh = null;
            } else {
                player = null; // Nullify player if mesh didn't exist
            }


            // Remove ground/ceiling
            let ground = scene.getMeshByName("ground");
            if (ground && !ground.isDisposed()) {
                 if (ground.physicsImpostor) ground.physicsImpostor.dispose();
                 ground.dispose();
                 console.log("Disposed ground mesh.");
            }
            let ceiling = scene.getMeshByName("ceiling");
            if (ceiling && !ceiling.isDisposed()) {
                ceiling.dispose(); // Ceiling unlikely to have physics
                console.log("Disposed ceiling mesh.");
            }

            // Clear other level-specific data
            dungeon = []; // Reset dungeon map data
            hasExitKey = false; // Reset key status for the level
            console.log("Level clear complete.");
        }


        // Generate a random dungeon level (simplified BSP or room/corridor approach)
        function generateLevel() {
            console.log("Generating dungeon layout...");
            // Initialize empty dungeon grid (0: Floor, 1: Wall, 2: Door, 3: Generator, 4: Exit Key, 5: Exit Door, 6: Item, 7: Enemy Start)
            dungeon = new Array(MAP_HEIGHT).fill(0).map(() => new Array(MAP_WIDTH).fill(1)); // Start with all walls

            let rooms = [];
            const maxRooms = 5 + Math.floor(currentLevel * 1.5);
            const minRoomSize = 3;
            const maxRoomSize = 6 + Math.min(5, Math.floor(currentLevel / 2)); // Cap max room size increase
            const maxTries = maxRooms * 10; // Increase tries to place rooms

            for (let i = 0; i < maxTries && rooms.length < maxRooms; i++) {
                let w = minRoomSize + Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));
                let h = minRoomSize + Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));
                // Ensure coordinates are within bounds (need +1 buffer from edge walls)
                let x = 1 + Math.floor(Math.random() * (MAP_WIDTH - w - 2));
                let y = 1 + Math.floor(Math.random() * (MAP_HEIGHT - h - 2));

                 // Ensure x, y are valid before creating room object
                if (x < 1 || y < 1 || x+w >= MAP_WIDTH-1 || y+h >= MAP_HEIGHT-1) {
                    continue; // Skip invalid room placement
                }

                let newRoom = { x, y, w, h, cx: x + Math.floor(w / 2), cy: y + Math.floor(h / 2) };

                // Check for overlap with existing rooms (with a 1-tile buffer)
                let overlaps = false;
                for (let existingRoom of rooms) {
                    if (x < existingRoom.x + existingRoom.w + 1 && x + w + 1 > existingRoom.x &&
                        y < existingRoom.y + existingRoom.h + 1 && y + h + 1 > existingRoom.y) {
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    // Carve out the room
                    for (let ry = y; ry < y + h; ry++) {
                        for (let rx = x; rx < x + w; rx++) {
                             // Double check bounds just in case
                             if (ry >= 0 && ry < MAP_HEIGHT && rx >=0 && rx < MAP_WIDTH) {
                                dungeon[ry][rx] = 0; // Floor
                             }
                        }
                    }
                    rooms.push(newRoom);
                }
            }

             if (rooms.length === 0) { // Failsafe: create one central room if generation failed
                console.warn("Room generation failed, creating failsafe room.");
                let w = 5, h = 5;
                let x = Math.max(1, Math.floor(MAP_WIDTH/2 - w/2));
                let y = Math.max(1, Math.floor(MAP_HEIGHT/2 - h/2));
                 let newRoom = { x, y, w, h, cx: x + Math.floor(w / 2), cy: y + Math.floor(h / 2) };
                 for (let ry = y; ry < y + h; ry++) {
                     for (let rx = x; rx < x + w; rx++) {
                          if (ry >= 0 && ry < MAP_HEIGHT && rx >=0 && rx < MAP_WIDTH) {
                            dungeon[ry][rx] = 0; // Floor
                          }
                     }
                 }
                 rooms.push(newRoom);
            }
            console.log(`Generated ${rooms.length} rooms.`);


            // Connect rooms with corridors
            for (let i = 0; i < rooms.length - 1; i++) {
                let c1 = rooms[i];
                let c2 = rooms[i + 1]; // Connect sequentially for simplicity
                let x1 = c1.cx, y1 = c1.cy;
                let x2 = c2.cx, y2 = c2.cy;

                // Dig L-shaped corridor - ensure digging stays within bounds
                if (Math.random() > 0.5) { // Horizontal first
                    for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                         if (y1 >= 0 && y1 < MAP_HEIGHT && x >=0 && x < MAP_WIDTH) dungeon[y1][x] = 0;
                    }
                    for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                         if (y >= 0 && y < MAP_HEIGHT && x2 >=0 && x2 < MAP_WIDTH) dungeon[y][x2] = 0;
                    }
                } else { // Vertical first
                    for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                         if (y >= 0 && y < MAP_HEIGHT && x1 >=0 && x1 < MAP_WIDTH) dungeon[y][x1] = 0;
                    }
                    for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                         if (y2 >= 0 && y2 < MAP_HEIGHT && x >=0 && x < MAP_WIDTH) dungeon[y2][x] = 0;
                    }
                }
            }

            // Place doors in walls between floor tiles (more robust check)
            let placedDoors = 0;
            let doorCandidates = [];
             for (let y = 1; y < MAP_HEIGHT - 1; y++) {
                 for (let x = 1; x < MAP_WIDTH - 1; x++) {
                     if (dungeon[y][x] === 1) { // Is it a wall?
                        // Check for horizontal passage potential: Floor left/right, Wall above/below
                         if (dungeon[y][x - 1] === 0 && dungeon[y][x + 1] === 0 && dungeon[y - 1][x] === 1 && dungeon[y + 1][x] === 1) {
                             doorCandidates.push({x, y});
                         }
                         // Check for vertical passage potential: Floor above/below, Wall left/right
                         else if (dungeon[y - 1][x] === 0 && dungeon[y + 1][x] === 0 && dungeon[y][x - 1] === 1 && dungeon[y][x + 1] === 1) {
                             doorCandidates.push({x, y});
                         }
                     }
                 }
             }
            shuffleArray(doorCandidates);
            let numDoorsToPlace = Math.min(doorCandidates.length, rooms.length + Math.floor(currentLevel / 2)); // Max doors based on candidates or formula
            for(let i=0; i < numDoorsToPlace; i++) {
                let pos = doorCandidates[i];
                dungeon[pos.y][pos.x] = 2; // Place Door
                placedDoors++;
            }
            console.log(`Placed ${placedDoors} doors.`);


            // --- Place Player Start ---
            let playerStartRoom = rooms[0]; // Start in the first room
             // Set start coords on a temporary object or directly if player object exists from level transition
             let startX = playerStartRoom.cx;
             let startY = playerStartRoom.cy;
             // If player object already exists (from level transition), update its start coords
             if (player) {
                 player.startX = startX;
                 player.startY = startY;
             } else {
                 // Otherwise, create a placeholder to hold the coords
                 player = { startX: startX, startY: startY };
             }
             console.log(`Player start planned at grid (${startX}, ${startY})`);

            // --- Place Exit Door and Key in different rooms ---
            let exitRoomIndex = rooms.length > 1 ? rooms.length - 1 : 0; // Place in last room
            // Try placing key somewhere in the middle, but not start or exit room
            let keyRoomIndex = 0;
            if (rooms.length > 2) {
                keyRoomIndex = Math.floor(1 + Math.random() * (rooms.length - 2)); // Index between 1 and length-2
                if (keyRoomIndex === exitRoomIndex) { // Avoid exit room if possible
                    keyRoomIndex = (exitRoomIndex > 1) ? exitRoomIndex - 1 : 1;
                }
            } else if (rooms.length > 1) {
                 keyRoomIndex = 1; // Place in second room if only two exist
                 if (keyRoomIndex === exitRoomIndex) keyRoomIndex = 0; // Failsafe if exit is also room 1
            }
            // Ensure keyRoomIndex is valid
            keyRoomIndex = Math.max(0, Math.min(rooms.length - 1, keyRoomIndex));
             if (keyRoomIndex === 0 && exitRoomIndex === 0 && rooms.length > 1) { // Further failsafe if start=key=exit
                 exitRoomIndex = 1;
             }


            let exitRoom = rooms[exitRoomIndex];
            let keyRoom = rooms[keyRoomIndex];

            // Place exit door and key at the center of their rooms
             dungeon[exitRoom.cy][exitRoom.cx] = 5; // Exit Door
             console.log(`Exit door at grid (${exitRoom.cx}, ${exitRoom.cy})`);
             dungeon[keyRoom.cy][keyRoom.cx] = 4; // Exit Key
             console.log(`Exit key at grid (${keyRoom.cx}, ${keyRoom.cy})`);


            // --- Collect Valid Floor Tiles for Spawning Items/Enemies/Generators ---
             let floorTiles = [];
             for (let y = 1; y < MAP_HEIGHT - 1; y++) {
                 for (let x = 1; x < MAP_WIDTH - 1; x++) {
                     if (dungeon[y][x] === 0) { // Is a floor tile
                        // Check distance from critical points to avoid clutter
                        let distPlayer = Math.abs(x - startX) + Math.abs(y - startY); // Use calculated start pos
                        let distExit = Math.abs(x - exitRoom.cx) + Math.abs(y - exitRoom.cy);
                        let distKey = Math.abs(x - keyRoom.cx) + Math.abs(y - keyRoom.cy);
                         // Ensure it's not the exact spot of player, key, or exit, and not too close to player start
                         if(distPlayer > 3 && distExit > 0 && distKey > 0) {
                            floorTiles.push({x, y});
                         }
                     }
                 }
             }
            shuffleArray(floorTiles); // Randomize placement order
            console.log(`Found ${floorTiles.length} valid floor tiles for placement.`);

            // Place Generators
            let numGenerators = Math.min(floorTiles.length, 1 + Math.floor(currentLevel / 3));
            for(let i=0; i < numGenerators && floorTiles.length > 0; i++) { // Check floorTiles.length
                let pos = floorTiles.pop();
                dungeon[pos.y][pos.x] = 3;
            }
            console.log(`Placed ${numGenerators} generators.`);

            // Place Items (Food, Potions, Keys, Treasure)
            let numItems = Math.min(floorTiles.length, 4 + Math.floor(currentLevel * 1.2));
            for(let i=0; i < numItems && floorTiles.length > 0; i++) {
                let pos = floorTiles.pop();
                dungeon[pos.y][pos.x] = 6; // Mark as item spot
            }
             console.log(`Placed ${numItems} item spots.`);

            // Place Initial Enemies
            let numEnemies = Math.min(floorTiles.length, 3 + Math.floor(currentLevel * 1.5));
            for(let i=0; i < numEnemies && floorTiles.length > 0; i++) {
                let pos = floorTiles.pop();
                dungeon[pos.y][pos.x] = 7; // Mark as enemy spawn spot
            }
             console.log(`Placed ${numEnemies} initial enemy spots.`);

            // Build 3D level from dungeon grid
            console.log("Building 3D level geometry...");
            buildLevel();
            console.log("Level generation complete.");
        }

        // Fisher-Yates Shuffle
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }


        // Build the 3D level from the dungeon grid
        function buildLevel() {
            // --- Materials (Define once for efficiency) ---
            let groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png", scene); // Example texture
            groundMaterial.diffuseTexture.uScale = MAP_WIDTH / 4;
            groundMaterial.diffuseTexture.vScale = MAP_HEIGHT / 4;
            groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            let ceilingMaterial = new BABYLON.StandardMaterial("ceilingMat", scene);
            ceilingMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.25); // Darker ceiling
            ceilingMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            ceilingMaterial.backFaceCulling = false; // Ensure ceiling is visible from below

            let wallMaterial = new BABYLON.StandardMaterial("wallMat", scene);
            wallMaterial.diffuseTexture = new BABYLON.Texture("bricktile.jpg", scene); // Example texture
             wallMaterial.diffuseTexture.uScale = 1; // Scale texture per tile if needed
             wallMaterial.diffuseTexture.vScale = 1;
            wallMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Create ground plane
            let ground = BABYLON.MeshBuilder.CreateGround("ground", {width: MAP_WIDTH * TILE_SIZE, height: MAP_HEIGHT * TILE_SIZE}, scene);
            ground.position.y = 0; // Set ground at y=0
            ground.material = groundMaterial;
            ground.checkCollisions = true; // Enable collision checking
            // Add physics impostor to ground (static box)
             if (scene.isPhysicsEnabled) {
                ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.8, restitution: 0.1 }, scene);
             }


             // Create ceiling plane
            let ceiling = BABYLON.MeshBuilder.CreatePlane("ceiling", {width: MAP_WIDTH * TILE_SIZE, height: MAP_HEIGHT * TILE_SIZE}, scene);
            ceiling.position.y = TILE_SIZE; // Ceiling height (adjust if walls are different height)
            ceiling.rotation.x = Math.PI; // Flip it to face down
            ceiling.material = ceilingMaterial;
            ceiling.checkCollisions = true; // Enable collision checking (e.g., for camera)


            // Process each cell in the dungeon grid
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    // Convert grid coordinates to 3D world coordinates (center of tile)
                    let worldX = (x - MAP_WIDTH / 2 + 0.5) * TILE_SIZE;
                    let worldZ = (y - MAP_HEIGHT / 2 + 0.5) * TILE_SIZE;

                    switch (dungeon[y][x]) {
                        case 1: createWall(worldX, worldZ, wallMaterial); break; // Pass shared material
                        case 2: createDoor(worldX, worldZ); break;
                        case 3: createGenerator(worldX, worldZ); break;
                        case 4: createExitKey(worldX, worldZ); break;
                        case 5: createExitDoor(worldX, worldZ); break;
                        case 6: createRandomItem(worldX, worldZ); break;
                        case 7: createRandomEnemy(worldX, worldZ); break;
                        // case 0: Floor - handled by the ground plane
                    }
                }
            }
            console.log(`Created ${walls.length} walls, ${doors.length} doors, ${generators.length} generators, ${items.length} items, ${enemies.length} enemies.`);
        }

        // Create a wall - Accepts shared material
        function createWall(x, z, material) {
            // Create wall mesh
            let wall = BABYLON.MeshBuilder.CreateBox("wall_" + x + "_" + z, {width: TILE_SIZE, height: TILE_SIZE, depth: TILE_SIZE}, scene);
            wall.position = new BABYLON.Vector3(x, TILE_SIZE / 2, z); // Center the wall vertically

            // Assign shared material
            wall.material = material;

            wall.checkCollisions = true; // Enable collision checking
             // Add physics impostor (static box)
            if (scene.isPhysicsEnabled) {
                wall.physicsImpostor = new BABYLON.PhysicsImpostor(
                    wall,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, friction: 0.6, restitution: 0.2 },
                    scene
                );
            }

            walls.push({ mesh: wall, x: x, z: z }); // Add to walls array (mainly for potential future use like destruction)
        }

        // Create a door
        function createDoor(x, z) {
            const doorHeight = TILE_SIZE * 0.9; // Make doors slightly shorter than tile height
            const doorWidth = TILE_SIZE * 0.9; // Make doors slightly narrower than tile width
            const doorDepth = 0.3; // Make doors thin

            let door = BABYLON.MeshBuilder.CreateBox("door_" + x + "_" + z, {width: doorWidth, height: doorHeight, depth: doorDepth}, scene);
            door.position = new BABYLON.Vector3(x, doorHeight / 2, z); // Position based on its own height

            let doorMaterial = new BABYLON.StandardMaterial("doorMat_" + x + "_" + z, scene);
            doorMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.1); // Wood color
            doorMaterial.specularColor = new BABYLON.Color3(0.1, 0.05, 0);
            door.material = doorMaterial;

            door.checkCollisions = true; // Start with collisions enabled
             if (scene.isPhysicsEnabled) {
                door.physicsImpostor = new BABYLON.PhysicsImpostor(
                    door,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, friction: 0.5, restitution: 0.3 }, // Static until opened
                    scene
                );
             }

            // Determine if door requires a key (chance increases with level, capped)
            let requiresKey = Math.random() < Math.min(0.6, 0.15 + currentLevel * 0.05);
            let doorData = {
                mesh: door,
                x: x,
                z: z,
                isOpen: false,
                isOpening: false,
                requiresKey: requiresKey,
                originalY: door.position.y // Store original position for animation
            };
            doors.push(doorData);

            // Add visual indicator if key is required
            if (requiresKey) {
                 doorMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0); // Slight yellow glow if locked
            }
        }

        // Open a door
        function openDoor(door) {
            if (!door || door.isOpen || door.isOpening || !door.mesh || door.mesh.isDisposed()) return; // Basic checks

            // Check if key is required and if player has one
            if (door.requiresKey) {
                if (player && player.keys > 0) {
                    player.keys--;
                    keys = player.keys; // Update global state
                    showMessage("Used a key to open the door.", 2000);
                     // Remove locked visual indicator
                     if (door.mesh.material) door.mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                } else {
                    showMessage("This door requires a key!", 2000);
                    if (sounds.door_locked && sounds.door_locked.state() === 'loaded') sounds.door_locked.play();
                    return; // Can't open
                }
            } else {
                 showMessage("Door opened.", 1500);
            }

            door.isOpening = true;
            if (sounds.door_open && sounds.door_open.state() === 'loaded') sounds.door_open.play();
            updatePlayerStats(); // Update key count display

            // Animate door opening (sliding up)
            let targetY = door.originalY + TILE_SIZE; // Move up full tile height to clear passage
            let animation = new BABYLON.Animation("doorOpenAnim", "position.y", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            let keysAnim = [];
            keysAnim.push({ frame: 0, value: door.mesh.position.y });
            keysAnim.push({ frame: 30, value: targetY }); // Open over 0.5 seconds
            animation.setKeys(keysAnim);

            // Disable collisions and physics *after* animation completes for smoother transition
            scene.beginDirectAnimation(door.mesh, [animation], 0, 30, false, 1, () => {
                // Animation finished callback
                 if (door.mesh && !door.mesh.isDisposed()) { // Check if mesh still exists
                    door.mesh.checkCollisions = false;
                     if (door.mesh.physicsImpostor) {
                        door.mesh.physicsImpostor.dispose();
                        door.mesh.physicsImpostor = null;
                    }
                    door.isOpen = true; // Mark as fully open
                    console.log(`Door at (${door.x.toFixed(1)}, ${door.z.toFixed(1)}) opened.`);
                 } else {
                     console.warn("Door mesh was disposed before open animation finished.");
                 }
                 door.isOpening = false;
            });
        }


        // Create an enemy generator
        function createGenerator(x, z) {
            let genMesh = BABYLON.MeshBuilder.CreateCylinder("generator_" + x + "_" + z, {diameter: 1.5, height: 1.5, tessellation: 12}, scene);
            genMesh.position = new BABYLON.Vector3(x, 0.75, z); // Position based on own height

            let genMaterial = new BABYLON.StandardMaterial("genMat_" + x + "_" + z, scene);
            genMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.1, 0.7); // Purple
            genMaterial.emissiveColor = new BABYLON.Color3(0.4, 0, 0.4); // Glowing purple
            genMaterial.specularColor = new BABYLON.Color3(0.2, 0, 0.2);
            genMesh.material = genMaterial;

            genMesh.checkCollisions = true;
             if (scene.isPhysicsEnabled) {
                genMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    genMesh,
                    BABYLON.PhysicsImpostor.CylinderImpostor,
                    { mass: 0, friction: 0.5, restitution: 0.3 }, // Static
                    scene
                );
            }

            let health = 150 + currentLevel * 30;
            let generator = {
                mesh: genMesh,
                x: x,
                z: z,
                health: health,
                maxHealth: health,
                lastSpawnTime: gameTime, // Use game time from engine
                spawnRate: Math.max(3000, 8000 - currentLevel * 500), // Spawn rate gets faster, min 3s
                isDestroyed: false,
                id: "gen_" + BABYLON.Tools.RandomId() // Unique ID for health bar map
            };
            generators.push(generator);

            // Create Generator Health Bar using the main GUI texture
            createGeneratorHealthBar(generator);
        }

         // Create GUI health bar for a generator (using shared Fullscreen GUI)
        function createGeneratorHealthBar(generator) {
            if (!advancedTextureGUI) {
                console.error("Cannot create generator health bar, advancedTextureGUI is not initialized.");
                return;
            }
            let healthBar = new BABYLON.GUI.Rectangle(generator.id + "_bar");
            healthBar.width = "60px";
            healthBar.height = "6px";
            healthBar.cornerRadius = 3;
            healthBar.color = "#111"; // Border color
            healthBar.thickness = 1;
            healthBar.background = "#333"; // Background color
            healthBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP; // Align based on linked mesh

            let healthFill = new BABYLON.GUI.Rectangle(generator.id + "_fill");
            healthFill.width = 1.0; // Start full (relative width, 1.0 = 100%)
            healthFill.height = 1.0; // Full height (relative)
            healthFill.cornerRadius = 3;
            healthFill.color = "transparent"; // No border for fill
            healthFill.background = "#ff00ff"; // Magenta fill
            healthFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT; // Fill from left

            healthBar.addControl(healthFill);

            // Add to the main fullscreen GUI texture
            advancedTextureGUI.addControl(healthBar);

            // Link GUI element to the generator mesh position in screen space
            healthBar.linkWithMesh(generator.mesh);
            // Adjust vertical offset to appear above the mesh
            let meshHeight = 1.5; // From createGenerator
            healthBar.linkOffsetY = -(meshHeight * 10 + 10); // Negative Y moves it up in screen space (pixels) - adjust as needed

            // Store references to the GUI elements on the generator object
            generator.healthBar = healthBar;
            generator.healthBarFill = healthFill;
            generatorHealthBars.set(generator.id, generator); // Add to map for easy access/disposal
            healthBar.isVisible = false; // Initially hidden until damaged
        }

        // Update generator health bar display
        function updateGeneratorHealthBar(generator) {
             // Check if generator, healthBar, and fill exist and are not disposed
            if (generator && generator.healthBar && !generator.healthBar.isDisposed && generator.healthBarFill) {
                let healthPercent = Math.max(0, generator.health / generator.maxHealth);
                generator.healthBarFill.width = healthPercent; // Update fill width (relative value)

                // Show bar only when damaged but not destroyed
                generator.healthBar.isVisible = (healthPercent > 0 && healthPercent < 1);
            }
        }


        // Create the exit key
        function createExitKey(x, z) {
            let keyMesh = BABYLON.MeshBuilder.CreateBox("exitKey", {width: 0.5, height: 0.5, depth: 0.1}, scene);
            keyMesh.position = new BABYLON.Vector3(x, 0.6, z); // Slightly above ground
            keyMesh.rotation.y = Math.PI / 4; // Initial rotation

            let keyMaterial = new BABYLON.StandardMaterial("keyMat", scene);
            keyMaterial.diffuseColor = new BABYLON.Color3(1, 0.85, 0); // Gold color
            keyMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.4, 0); // Make it glow slightly
            keyMaterial.specularColor = new BABYLON.Color3(1, 1, 0.7);
            keyMesh.material = keyMaterial;

            // No physics needed, just collision check for pickup
             keyMesh.checkCollisions = false; // We'll use intersectsMesh for pickup
             keyMesh.isPickable = false; // Prevent accidental scene picking

            // Add rotation and bobbing animation
            let rotateAnim = new BABYLON.Animation("keyRotate", "rotation.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            rotateAnim.setKeys([ { frame: 0, value: keyMesh.rotation.y }, { frame: 60, value: keyMesh.rotation.y + 2 * Math.PI }]);

            let bobAnim = new BABYLON.Animation("keyBob", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            let startY = keyMesh.position.y;
            bobAnim.setKeys([
                 { frame: 0, value: startY - 0.1 },
                 { frame: 30, value: startY + 0.1 },
                 { frame: 60, value: startY - 0.1 }
            ]);

            keyMesh.animations = [rotateAnim, bobAnim];
            scene.beginAnimation(keyMesh, 0, 60, true); // Loop animations

            exitKey = { mesh: keyMesh, x: x, z: z, collected: false };
        }

        // Create the exit door
        function createExitDoor(x, z) {
            // Make exit door visually distinct, maybe larger or different shape
            let doorMesh = BABYLON.MeshBuilder.CreateBox("exitDoor", {width: TILE_SIZE * 0.8, height: TILE_SIZE * 0.9, depth: 0.4}, scene);
            doorMesh.position = new BABYLON.Vector3(x, TILE_SIZE * 0.9 / 2, z); // Position based on own height

            let doorMaterial = new BABYLON.StandardMaterial("exitDoorMat", scene);
            doorMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.7, 0.1); // Greenish
            doorMaterial.emissiveColor = new BABYLON.Color3(0, 0.3, 0); // Glowing green
            doorMaterial.specularColor = new BABYLON.Color3(0.2, 0.5, 0.2);
            doorMesh.material = doorMaterial;

            doorMesh.checkCollisions = true; // Player must touch it to trigger level end
            // Static physics impostor for collision detection
            if (scene.isPhysicsEnabled) {
                doorMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    doorMesh,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, friction: 0.5, restitution: 0.3 },
                    scene
                );
            }

            exitDoor = { mesh: doorMesh, x: x, z: z, isOpen: false }; // isOpen technically not used for exit, but consistent
        }

        // Create a random item based on type percentages
        function createRandomItem(x, z) {
             // Determine item type based on probability
             let rand = Math.random();
             let type;
             if (rand < 0.50) type = 'FOOD';       // 50% Food
             else if (rand < 0.75) type = 'TREASURE';// 25% Treasure
             else if (rand < 0.90) type = 'POTION';  // 15% Potion
             else type = 'KEY';                    // 10% Key (non-exit key)

            let itemData = ITEM_TYPES[type];
            if (!itemData) {
                console.error("Could not find data for item type:", type);
                return;
            }

            // Create item mesh based on type
            let itemMesh;
            let meshName = type + "_" + BABYLON.Tools.RandomId(); // Unique name
            if (itemData.meshType === 'box') {
                itemMesh = BABYLON.MeshBuilder.CreateBox(meshName, {width: itemData.size[0], height: itemData.size[1], depth: itemData.size[2]}, scene);
            } else if (itemData.meshType === 'cylinder') {
                itemMesh = BABYLON.MeshBuilder.CreateCylinder(meshName, {diameter: itemData.size.diameter, height: itemData.size.height, tessellation: 12}, scene);
            } else { // sphere (treasure)
                itemMesh = BABYLON.MeshBuilder.CreateSphere(meshName, {diameter: itemData.size, segments: 12}, scene);
            }

            // Position slightly above ground
            let baseY = (itemData.meshType === 'box' ? itemData.size[1] : (itemData.meshType === 'cylinder' ? itemData.size.height : itemData.size)) / 2 + 0.1;
            itemMesh.position = new BABYLON.Vector3(x, baseY, z);

            // Apply rotation if needed (e.g., for keys)
            if (type === 'KEY') itemMesh.rotation.y = Math.PI / 4 + Math.random() * Math.PI / 2; // Random rotation for keys

            // Create item material
            let itemMaterial = new BABYLON.StandardMaterial("itemMat_" + meshName, scene);
            itemMaterial.diffuseColor = itemData.color.clone(); // Clone color to avoid shared modification issues
            itemMaterial.specularColor = new BABYLON.Color3(0.6, 0.6, 0.6); // Slightly less shiny
             if (type === 'TREASURE' || type === 'POTION' || type === 'KEY') {
                 itemMaterial.emissiveColor = itemData.color.scale(0.3); // Make important items glow slightly
             }
            itemMesh.material = itemMaterial;

            itemMesh.checkCollisions = false; // Use intersectsMesh for pickup
            itemMesh.isPickable = false; // Prevent picking

            // Add floating/bobbing animation
            itemMesh.animations = []; // Initialize animations array
            let bobAnim = new BABYLON.Animation("itemBob", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            let startY = itemMesh.position.y;
            bobAnim.setKeys([
                 { frame: 0, value: startY - 0.1 },
                 { frame: 30, value: startY + 0.1 },
                 { frame: 60, value: startY - 0.1 }
            ]);
             itemMesh.animations.push(bobAnim);

             // Add rotation animation for specific items
             if (type === 'KEY' || type === 'POTION' || type === 'TREASURE') {
                let rotateAnim = new BABYLON.Animation("itemRotate", "rotation.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                 let startRotY = itemMesh.rotation.y;
                rotateAnim.setKeys([ { frame: 0, value: startRotY }, { frame: 90, value: startRotY + 2 * Math.PI }]); // Slower rotation (90 frames)
                itemMesh.animations.push(rotateAnim);
             }

            scene.beginAnimation(itemMesh, 0, 90, true); // Use longest frame duration (90 for rotation)

            items.push({
                mesh: itemMesh,
                type: type, // Store the determined type
                x: x,
                z: z,
                health: itemData.health || 0,
                special: itemData.special || null,
                score: itemData.score || 0
            });
        }


        // Create a random enemy at a specific location
        function createRandomEnemy(x, z, specificType = null) {
            // Select an enemy type
            let type;
            if (specificType && ENEMY_TYPES[specificType]) {
                type = specificType;
            } else {
                // Weighted enemy selection based on level
                let possibleTypes = [];
                let weightSum = 0;
                let weights = {
                    GHOST: 20 - currentLevel,         // Less common later
                    GRUNT: 30 + currentLevel,         // More common
                    DEMON: (currentLevel > 2) ? 15 + currentLevel : 0, // Appear after level 2
                    SORCERER: (currentLevel > 3) ? 10 + currentLevel : 0, // Appear after level 3
                    DEATH: (currentLevel > 5) ? 5 + currentLevel * 0.5 : 0  // Appear after level 5
                };

                for (const key in weights) {
                     if (weights[key] > 0) {
                         possibleTypes.push({ type: key, weight: weights[key] });
                         weightSum += weights[key];
                     }
                }

                 if (weightSum === 0 || possibleTypes.length === 0) { // Failsafe if no types possible
                     type = 'GHOST';
                 } else {
                    let rand = Math.random() * weightSum;
                    let cumulativeWeight = 0;
                    for(let item of possibleTypes) {
                        cumulativeWeight += item.weight;
                        if (rand < cumulativeWeight) {
                            type = item.type;
                            break;
                        }
                    }
                    if (!type) type = possibleTypes[possibleTypes.length - 1].type; // Failsafe select last possible
                 }
            }

            let enemyData = ENEMY_TYPES[type];
             if (!enemyData) {
                 console.error(`Failed to get data for enemy type: ${type}, defaulting to GRUNT`);
                 type = 'GRUNT';
                 enemyData = ENEMY_TYPES[type];
             }

            // Create enemy mesh
            let enemyMesh;
            let meshHeight = 1.5; // Default height assumption
            let meshName = "enemy_" + type + "_" + BABYLON.Tools.RandomId(); // Unique name

            if (enemyData.meshType === 'box') {
                enemyMesh = BABYLON.MeshBuilder.CreateBox(meshName, {width: enemyData.size[0], height: enemyData.size[1], depth: enemyData.size[2]}, scene);
                meshHeight = enemyData.size[1];
            } else if (enemyData.meshType === 'cylinder') {
                enemyMesh = BABYLON.MeshBuilder.CreateCylinder(meshName, {diameter: enemyData.size.diameter, height: enemyData.size.height, tessellation: 12}, scene);
                 meshHeight = enemyData.size.height;
            } else { // sphere (ghost)
                enemyMesh = BABYLON.MeshBuilder.CreateSphere(meshName, {diameter: enemyData.size, segments: 12}, scene);
                 meshHeight = enemyData.size;
            }

             // Position based on calculated height to sit on ground
            enemyMesh.position = new BABYLON.Vector3(x, meshHeight / 2 + 0.05, z); // Add small offset Y

            // Create enemy material
            let enemyMaterial = new BABYLON.StandardMaterial("enemyMat_" + meshName, scene);
            enemyMaterial.diffuseColor = enemyData.color.clone(); // Clone color
            enemyMaterial.specularColor = enemyData.color.scale(0.3); // Less specular
             if (enemyData.alpha && enemyData.alpha < 1.0) {
                 enemyMaterial.alpha = enemyData.alpha;
             }
            enemyMesh.material = enemyMaterial;

            enemyMesh.checkCollisions = true; // Enable collisions

            // Add physics impostor (dynamic)
            if (scene.isPhysicsEnabled) {
                let impostorType;
                if (enemyData.meshType === 'sphere') impostorType = BABYLON.PhysicsImpostor.SphereImpostor;
                else if (enemyData.meshType === 'cylinder') impostorType = BABYLON.PhysicsImpostor.CylinderImpostor;
                else impostorType = BABYLON.PhysicsImpostor.BoxImpostor;

                enemyMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    enemyMesh,
                    impostorType,
                    { mass: 40 + Math.random() * 20, friction: 0.4, restitution: 0.1 }, // Give enemies some mass
                    scene
                );
                // Prevent excessive spinning
                enemyMesh.physicsImpostor.physicsBody.angularDamping = 0.98;
                // Lock rotation around X and Z axes to prevent falling over
                if (impostorType !== BABYLON.PhysicsImpostor.SphereImpostor) {
                    enemyMesh.physicsImpostor.physicsBody.fixedRotation = true; // Simpler than angular constraints
                    enemyMesh.physicsImpostor.physicsBody.updateMassProperties(); // Apply fixedRotation
                }
            }


            // Scale stats based on level
            let health = enemyData.health + Math.floor(currentLevel * enemyData.health * 0.1);
            let attack = enemyData.attack + Math.floor(currentLevel * enemyData.attack * 0.08);
            let speed = enemyData.speed * (1 + Math.min(0.5, currentLevel * 0.03)); // Cap speed increase

            let enemy = {
                mesh: enemyMesh,
                id: "enemy_" + BABYLON.Tools.RandomId(), // Unique ID for health bar map
                type: type,
                x: x, // Store initial grid position for reference if needed
                z: z,
                health: health,
                maxHealth: health,
                attack: attack,
                speed: speed,
                lastAttackTime: 0, // Use gameTime
                lastShotTime: 0, // For ranged enemies
                shootCooldown: enemyData.shootCooldown || 2000,
                shootRange: enemyData.shootRange || 0,
                canShoot: enemyData.canShoot || false,
                isInvulnerable: enemyData.isInvulnerable || false,
                specialAttack: enemyData.specialAttack || false,
                score: enemyData.score,
                state: 'idle', // 'idle', 'chasing', 'attacking'
                targetPosition: null, // For AI navigation (currently unused)
                healthBar: null, // Reference to GUI health bar
                healthBarFill: null, // Reference to GUI health bar fill
                markedForDeath: false // Flag for death sequence
            };
            enemies.push(enemy);

             // Create Enemy Health Bar GUI
            createEnemyHealthBar(enemy);
        }

        // Create GUI health bar for an enemy (using shared Fullscreen GUI)
        function createEnemyHealthBar(enemy) {
             if (!advancedTextureGUI) {
                console.error("Cannot create enemy health bar, advancedTextureGUI is not initialized.");
                return;
            }
            let healthBar = new BABYLON.GUI.Rectangle(enemy.id + "_bar");
            healthBar.width = "50px";
            healthBar.height = "5px";
            healthBar.cornerRadius = 2;
            healthBar.color = "#300"; // Dark red border
            healthBar.thickness = 1;
            healthBar.background = "#500"; // Dark red background
            healthBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP; // Align relative to linked mesh

            let healthFill = new BABYLON.GUI.Rectangle(enemy.id + "_fill");
            healthFill.width = 1.0; // Start full (relative)
            healthFill.height = 1.0; // Full height (relative)
            healthFill.cornerRadius = 2;
            healthFill.color = "transparent"; // No border for fill
            healthFill.background = "#f00"; // Bright red fill
            healthFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT; // Align fill left

            healthBar.addControl(healthFill);

            // Add to the main fullscreen GUI texture
            advancedTextureGUI.addControl(healthBar);

            // Link GUI element to the enemy mesh position
            healthBar.linkWithMesh(enemy.mesh);
            // Adjust vertical offset based on enemy mesh height
            let meshHeight = enemy.mesh.getBoundingInfo().boundingBox.extendSize.y * 2; // Get actual height
            healthBar.linkOffsetY = -(meshHeight * 10 + 8); // Position above enemy (pixels) - adjust spacing as needed

            // Store references on the enemy object
            enemy.healthBar = healthBar;
            enemy.healthBarFill = healthFill;
            enemyHealthBars.set(enemy.id, enemy); // Add to map for easy access/disposal
            healthBar.isVisible = false; // Initially hidden
        }

        // Update enemy health bar display
        function updateEnemyHealthBar(enemy) {
             // Check if enemy, healthBar, and fill exist and are not disposed
            if (enemy && enemy.healthBar && !enemy.healthBar.isDisposed && enemy.healthBarFill) {
                let healthPercent = Math.max(0, enemy.health / enemy.maxHealth);
                enemy.healthBarFill.width = healthPercent; // Update fill width (relative)

                // Show bar only when damaged but not destroyed
                enemy.healthBar.isVisible = (healthPercent > 0 && healthPercent < 1);
            }
        }


        // Create player character
        function createPlayer() {
            if (!playerClassInfo) {
                console.error("Player class not selected! Cannot create player.");
                return;
            }
             // Check if player start position was set during level generation
             if (!player || player.startX === undefined || player.startY === undefined) {
                 console.error("Player start position not defined! Cannot create player.");
                 // Failsafe: place at center?
                 player = { startX: Math.floor(MAP_WIDTH/2), startY: Math.floor(MAP_HEIGHT/2) };
             }

            // Convert grid coordinates to 3D world coordinates
            let worldX = (player.startX - MAP_WIDTH / 2 + 0.5) * TILE_SIZE;
            let worldZ = (player.startY - MAP_HEIGHT / 2 + 0.5) * TILE_SIZE;

            // Create player mesh (Capsule is good for physics)
            let playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", { radius: 0.4, height: 1.8 }, scene);
             // Position slightly above ground to avoid initial physics issues
            playerMesh.position = new BABYLON.Vector3(worldX, 1.0, worldZ);

            // Create player material
            let playerMaterial = new BABYLON.StandardMaterial("playerMat", scene);
            playerMaterial.diffuseColor = playerClassInfo.color;
            playerMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            playerMesh.material = playerMaterial;
            playerMesh.checkCollisions = true; // Enable collisions for the player mesh itself

            // Add physics impostor to player
             if (scene.isPhysicsEnabled) {
                playerMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    playerMesh,
                    BABYLON.PhysicsImpostor.CapsuleImpostor,
                    { mass: 70, friction: 0.5, restitution: 0.1 },
                    scene
                );
                 // Prevent tipping over
                 if (playerMesh.physicsImpostor.physicsBody) { // Check if body exists
                    playerMesh.physicsImpostor.physicsBody.angularDamping = 0.999; // Very high damping
                    playerMesh.physicsImpostor.physicsBody.fixedRotation = true; // Lock X/Z rotation axes completely
                    playerMesh.physicsImpostor.physicsBody.updateMassProperties();
                 } else {
                     console.warn("Player physics body not created immediately.");
                 }
             }


            // Update the existing player object with mesh and full stats
             // Carry over stats from previous level if player object exists
             let startingHealth = playerClassInfo.health;
             let currentScore = 0;
             let currentKeys = 0;
             let currentPotions = 3; // Default starting potions

             if (player) { // If player object exists from previous level or placeholder
                startingHealth = player.health !== undefined ? player.health : playerClassInfo.health;
                currentScore = player.score || 0;
                currentKeys = player.keys || 0;
                currentPotions = player.potions !== undefined ? player.potions : 3;
             }


            player = {
                mesh: playerMesh,
                type: playerClassInfo.name,
                health: startingHealth,
                maxHealth: playerClassInfo.health, // Max health is based on class default
                attack: playerClassInfo.attack,
                magic: playerClassInfo.magic,
                speed: playerClassInfo.speed,
                special: playerClassInfo.special,
                keys: currentKeys,
                potions: currentPotions,
                score: currentScore,
                lastShotTime: 0,
                lastSpecialTime: 0,
                invulnerableUntil: 0, // Timestamp until invulnerable
                shotCooldown: playerClassInfo.shotCooldown,
                specialCooldown: playerClassInfo.specialCooldown
            };
             console.log("Player created/updated:", player);

             // Ensure global state reflects player state after creation/update
             score = player.score;
             keys = player.keys;
             potions = player.potions;


            // Add a simple point light following the player for better visibility
            let playerLight = new BABYLON.PointLight("playerLight", new BABYLON.Vector3(0, 1.5, 0), scene);
            playerLight.diffuse = new BABYLON.Color3(0.9, 0.9, 1.0); // Slightly blueish white
            playerLight.specular = new BABYLON.Color3(0.5, 0.5, 0.7);
            playerLight.intensity = 0.5; // Adjust intensity
            playerLight.range = 10; // Adjust range
            playerLight.parent = playerMesh; // Attach light to player mesh
        }

        // Setup player camera
        function setupPlayerCamera() {
            if (!player || !player.mesh || player.mesh.isDisposed()) {
                console.error("Cannot setup camera, player mesh not found or disposed.");
                return;
            }
             // Detach previous camera control if exists from a previous level
            if (camera) {
                camera.detachControl(canvas);
            }

            // Create or update camera
            if (!camera) { // Create new if it doesn't exist
                camera = new BABYLON.FollowCamera("playerCamera", player.mesh.position.add(new BABYLON.Vector3(0, 5, -7)), scene);
                 console.log("Creating new FollowCamera.");
            } else { // Update target if reusing
                 camera.lockedTarget = player.mesh;
                 console.log("Updating existing FollowCamera target.");
            }

            camera.radius = 12; // Distance from target
            camera.heightOffset = 8; // Height above target
            camera.rotationOffset = 0; // Angle around target (0 = directly behind)
            camera.cameraAcceleration = 0.08; // Smoother acceleration
            camera.maxCameraSpeed = 15; // Max speed
            camera.attachControl(canvas, true); // Attach controls (true prevents default actions)
            camera.lockedTarget = player.mesh; // Ensure target is locked
            // Define camera limits
            camera.lowerRadiusLimit = 6; // Min zoom distance
            camera.upperRadiusLimit = 25; // Max zoom distance
            camera.lowerHeightOffsetLimit = 4; // Min height offset
            camera.upperHeightOffsetLimit = 15; // Max height offset

            // Prevent camera from going through walls/floor - Crucial!
            camera.checkCollisions = true;
            // Define a collision sphere around the camera's focal point
            camera.collisionRadius = new BABYLON.Vector3(0.8, 0.8, 0.8); // Adjust size as needed

             console.log("Camera setup complete.");
        }

        // Setup UI elements (like player stats display)
        function setupUI() {
            console.log("Setting up UI display.");
            updatePlayerStats(); // Initial update of stats display
            // Clear message log from previous level
            messageLogDiv.innerText = '';
            messageLogDiv.style.transition = ''; // Reset transition
            messageLogDiv.style.opacity = 1;
             // Clear any pending timeouts from previous level
             if (messageLogDiv.timeoutId) {
                clearTimeout(messageLogDiv.timeoutId);
                messageLogDiv.timeoutId = null;
             }
        }

        // Update player stats display in the HTML overlay
        function updatePlayerStats() {
            if (!player || !playerClassInfo || !playerStatsDiv) return; // Ensure everything exists

            playerStatsDiv.innerHTML = ''; // Clear previous stats

            let playerInfo = document.createElement('div');
            playerInfo.className = 'playerInfo';

            // Calculate special cooldown status using gameTime
            let now = gameTime;
            let timeSinceSpecial = now - player.lastSpecialTime;
            let specialReady = timeSinceSpecial >= player.specialCooldown;
            let specialCooldownRemaining = Math.max(0, player.specialCooldown - timeSinceSpecial);
            let specialStatus = specialReady ? '<span style="color:lime;">(Ready)</span>' : `<span style="color:yellow;">(${Math.ceil(specialCooldownRemaining / 1000)}s)</span>`;

            // Calculate health percentage, ensuring it's between 0 and 100
            let healthPercent = Math.max(0, Math.min(100, (player.health / player.maxHealth) * 100));

            // Use Math.ceil to avoid showing 0 health when there's a tiny fraction left
            let displayHealth = Math.max(0, Math.ceil(player.health));

            playerInfo.innerHTML = `
                <div><b>${player.type}</b> (Lvl ${currentLevel})</div>
                <div>Health: ${displayHealth} / ${player.maxHealth}</div>
                <div class="healthBar"><div class="healthFill" style="width: ${healthPercent}%"></div></div>
                <div>Score: ${player.score}</div>
                <div>Keys: ${player.keys}</div>
                <div>Potions: ${player.potions}</div>
                <div>Special: ${player.special} ${specialStatus}</div>
            `;

            playerStatsDiv.appendChild(playerInfo);
        }

        // Show a game message centered on screen with fadeout
        function showMessage(message, duration = 3000) {
             const fadeDuration = 500; // ms for fade out
             if (duration <= fadeDuration) duration = fadeDuration + 100; // Ensure duration is longer than fade

             // Clear any previous timeout to prevent premature clearing/fading
             if (messageLogDiv.timeoutId) {
                 clearTimeout(messageLogDiv.timeoutId);
                 messageLogDiv.timeoutId = null;
             }

             messageLogDiv.innerText = message;
             messageLogDiv.style.transition = ''; // Remove previous transition (important if previous fade was interrupted)
             messageLogDiv.style.opacity = 1; // Make sure it's fully visible
             lastMessageTime = gameTime; // Track when this message appeared

            // Set a new timeout to fade and clear the message
            messageLogDiv.timeoutId = setTimeout(() => {
                // Start fade out
                 messageLogDiv.style.transition = `opacity ${fadeDuration}ms ease-out`;
                 messageLogDiv.style.opacity = 0;

                 // Set another timeout to clear text after fade completes (optional, but good practice)
                 setTimeout(() => {
                    // Only clear if the message hasn't changed since the fade started
                    // (Could happen if a new message arrived very quickly)
                    if (messageLogDiv.style.opacity == 0) { // Check if it actually faded out
                       // messageLogDiv.innerText = ''; // Clearing text isn't strictly necessary if opacity is 0
                    }
                    messageLogDiv.timeoutId = null; // Clear the stored timeout ID
                 }, fadeDuration);

            }, duration - fadeDuration); // Start fading before full duration ends
        }

        // --- Game Update Logic ---

        // Main game update loop (called by engine.runRenderLoop)
        function updateGame(deltaTime) { // Receive deltaTime from render loop
             // Add a try-catch block for robustness during development
             try {
                if (!player || !player.mesh || player.mesh.isDisposed() || !scene || scene.isDisposed) return; // Ensure player and scene exist and are valid

                handlePlayerInput(deltaTime); // Pass delta time
                updateEnemies(deltaTime);
                updateGenerators(deltaTime);
                updateProjectiles(deltaTime); // Pass delta time
                checkCollisions(); // Player collisions with items, doors, etc.

                // UI updates are less critical per-frame, can be throttled if needed
                updateUI();

            } catch (error) {
                 console.error("Error during game update:", error);
                 // Consider pausing the game or showing an error message
                 // gameOver("A critical error occurred!"); // Pass optional error message
            }
        }

        // Handle player input
        function handlePlayerInput(deltaTime) {
            if (!player || !player.mesh || player.mesh.isDisposed() || !player.mesh.physicsImpostor || player.health <= 0) return;

            let currentVelocity = player.mesh.physicsImpostor.getLinearVelocity();
            // If physics body doesn't exist (e.g., disposed on game over), exit
             if (!currentVelocity) return;

             // Camera-relative movement directions
             let camForward = camera.getDirection(BABYLON.Axis.Z); // Camera's local forward
             camForward.y = 0; // Project onto ground plane
             camForward.normalize();
             let camRight = camera.getDirection(BABYLON.Axis.X); // Camera's local right
             camRight.y = 0; // Project onto ground plane
             camRight.normalize();

            let moveDirection = BABYLON.Vector3.Zero();
            let inputForceMagnitude = player.speed * 30; // Factor for physics force/velocity

            // Handle WASD movement based on camera direction
            if (inputMap['w'] || inputMap['arrowup']) moveDirection.addInPlace(camForward);
            if (inputMap['s'] || inputMap['arrowdown']) moveDirection.subtractInPlace(camForward); // Use subtractInPlace
            if (inputMap['a'] || inputMap['arrowleft']) moveDirection.subtractInPlace(camRight);
            if (inputMap['d'] || inputMap['arrowright']) moveDirection.addInPlace(camRight);

             if (moveDirection.lengthSquared() > 0.001) { // Check if there's significant input
                moveDirection.normalize(); // Ensure consistent speed diagonally

                // Set Velocity (Simpler, arcade feel)
                let targetVelocity = moveDirection.scale(player.speed); // Scale normalized direction by player speed
                player.mesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(targetVelocity.x, currentVelocity.y, targetVelocity.z));

             } else {
                 // Apply Damping when no input
                 let dampingFactor = 0.85; // Adjust for desired stopping speed
                 player.mesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(currentVelocity.x * dampingFactor, currentVelocity.y, currentVelocity.z * dampingFactor));
             }


            // --- Player Rotation ---
            // Make player face mouse cursor direction on the ground plane
            let pickInfo = scene.pick(scene.pointerX, scene.pointerY, (mesh) => mesh.name === "ground"); // Pick only the ground
            if (pickInfo && pickInfo.hit && pickInfo.pickedPoint) {
                let targetPoint = pickInfo.pickedPoint;
                let direction = targetPoint.subtract(player.mesh.getAbsolutePosition()); // Use absolute position
                direction.y = 0; // Keep rotation horizontal
                if (direction.lengthSquared() > 0.01) { // Avoid issues near player center
                     let targetAngle = Math.atan2(direction.x, direction.z);

                     // Apply rotation directly (works well with fixedRotation = true)
                     player.mesh.rotation.y = targetAngle;
                }
            }


            // Handle attack (space) - Use gameTime for cooldown
            if (inputMap[' '] && gameTime > player.lastShotTime + player.shotCooldown) {
                playerAttack();
            }

            // Handle special attack (f) - Use gameTime for cooldown
            if (inputMap['f'] && gameTime > player.lastSpecialTime + player.specialCooldown) {
                playerSpecialAttack();
            }

            // Use potion (e) - Consume the input flag immediately after use
             if (inputMap['e']) {
                 usePotion();
                 inputMap['e'] = false; // Prevent continuous potion use if key held down
             }
        }

        // Player normal attack
        function playerAttack() {
            if (!player || !player.mesh || player.mesh.isDisposed() || player.health <= 0) return;

            player.lastShotTime = gameTime;

            // Get player's forward direction based on current mesh rotation
            // For a capsule created with default orientation, Z axis is usually along the height.
            // We need the direction the *character* is facing, which depends on how the mesh is rotated.
            // Using mesh.forward assumes the mesh's local -Z is its "front". Adjust if needed.
            // If mesh.forward points *away* from where player aims, scale by -1.
             let forward = player.mesh.forward.scale(-1); // ASSUMPTION: player aims opposite to mesh's local Z
             // --- OR ---
             // let forward = player.mesh.getDirection(BABYLON.Axis.Z).scale(-1); // Might be more reliable


            if (player.type === 'Warrior') {
                 // --- Warrior Melee Attack ---
                 if (sounds.attack_melee && sounds.attack_melee.state() === 'loaded') sounds.attack_melee.play();

                let attackRange = 1.8; // How far the swing reaches
                let attackArcDegrees = 120; // Angle of the attack cone
                let attackArcRadians = BABYLON.Tools.ToRadians(attackArcDegrees / 2);
                let playerPos = player.mesh.getAbsolutePosition();

                 // Check for enemies in a cone in front of the player
                let hitSomething = false;
                enemies.forEach(enemy => {
                    if (enemy && enemy.mesh && !enemy.mesh.isDisposed() && enemy.health > 0 && enemy.mesh.isEnabled()) {
                        let enemyPos = enemy.mesh.getAbsolutePosition();
                        let vecToEnemy = enemyPos.subtract(playerPos);
                        let distSqr = vecToEnemy.lengthSquared();

                        // 1. Check distance
                        if (distSqr < attackRange * attackRange) {
                            // 2. Check angle
                            vecToEnemy.y = 0; // Project to horizontal plane for angle check
                             if (vecToEnemy.lengthSquared() < 0.001) return; // Avoid normalizing zero vector if enemy is exactly at player pos
                            vecToEnemy.normalize();
                            let forwardHorizontal = forward.clone(); forwardHorizontal.y = 0; forwardHorizontal.normalize(); // Normalize forward vector too
                            let dotProduct = BABYLON.Vector3.Dot(forwardHorizontal, vecToEnemy);

                             if (dotProduct > Math.cos(attackArcRadians)) {
                                 damageEnemy(enemy, player.attack);
                                 hitSomething = true;
                                 // Add knockback impulse
                                 if(enemy.mesh.physicsImpostor) {
                                     let knockbackDir = vecToEnemy; // Use already normalized vector
                                     enemy.mesh.physicsImpostor.applyImpulse(knockbackDir.scale(50), enemyPos);
                                 }
                            }
                        }
                    }
                });

                 // Check Generators in the same cone
                 generators.forEach(gen => {
                     if (gen && !gen.isDestroyed && gen.mesh && !gen.mesh.isDisposed() && gen.mesh.isEnabled()) {
                          let genPos = gen.mesh.getAbsolutePosition();
                          let vecToGen = genPos.subtract(playerPos);
                          let distSqr = vecToGen.lengthSquared();
                          if (distSqr < attackRange * attackRange) {
                             vecToGen.y = 0;
                             if (vecToGen.lengthSquared() < 0.001) return;
                             vecToGen.normalize();
                              let forwardHorizontal = forward.clone(); forwardHorizontal.y = 0; forwardHorizontal.normalize();
                             let dotProduct = BABYLON.Vector3.Dot(forwardHorizontal, vecToGen);
                              if (dotProduct > Math.cos(attackArcRadians)) {
                                 damageGenerator(gen, player.attack);
                                 hitSomething = true;
                             }
                         }
                     }
                 });

                 // Visual effect for melee attack (e.g., a quick slash arc)
                if (hitSomething) { // Optional: Show effect even on miss?
                    let slash = BABYLON.MeshBuilder.CreateTorus("slash", {diameter: attackRange * 1.2, thickness: 0.1, tessellation: 16}, scene);
                    slash.position = playerPos.add(forward.scale(attackRange * 0.5)).add(new BABYLON.Vector3(0, 1.0, 0)); // In front, waist height
                    slash.rotation.x = Math.PI / 2; // Lay flat initially
                    slash.rotation.y = player.mesh.rotation.y; // Align with player Y rotation
                    slash.isPickable = false;

                    let slashMat = new BABYLON.StandardMaterial("slashMat", scene);
                    slashMat.diffuseColor = new BABYLON.Color3(1, 1, 0.8);
                    slashMat.emissiveColor = new BABYLON.Color3(1, 1, 0.5);
                    slashMat.alpha = 0.8;
                    slashMat.disableLighting = true; // Make it bright regardless of light
                    slash.material = slashMat;

                    let fadeAnim = new BABYLON.Animation("fade", "material.alpha", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    fadeAnim.setKeys([{ frame: 0, value: 0.8 }, { frame: 6, value: 0 }]); // Fade out very quickly (0.1s)
                    let scaleAnim = new BABYLON.Animation("scale", "scaling.x", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    scaleAnim.setKeys([{ frame: 0, value: 0.5 }, { frame: 4, value: 1.2 }]); // Quick expand X
                    let scaleAnimZ = new BABYLON.Animation("scaleZ", "scaling.z", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    scaleAnimZ.setKeys([{ frame: 0, value: 0.5 }, { frame: 4, value: 1.2 }]); // Quick expand Z

                    scene.beginDirectAnimation(slash, [fadeAnim, scaleAnim, scaleAnimZ], 0, 6, false, 1, () => {
                         if (slash && !slash.isDisposed()) slash.dispose();
                    });
                 }


            } else {
                // --- Ranged Attack (Valkyrie, Wizard, Elf) ---
                 if (sounds.attack_ranged && sounds.attack_ranged.state() === 'loaded') sounds.attack_ranged.play();

                // Calculate starting position slightly in front and above player center
                let projectileStartPos = player.mesh.getAbsolutePosition() // World position
                                             .add(new BABYLON.Vector3(0, 1.0, 0)) // Raise to approx shoulder height
                                             .add(forward.scale(0.6)); // Move slightly forward from center

                // Calculate damage (mix of attack/magic, varies by class)
                let damage = player.attack; // Base damage
                 if (player.type === 'Wizard') damage = player.magic * 1.2; // Wizard uses magic primarily
                 else if (player.type === 'Elf') damage = player.attack * 0.8 + player.magic * 0.4; // Elf mix
                 else if (player.type === 'Valkyrie') damage = player.attack * 1.1 + player.magic * 0.2; // Valkyrie more attack focused

                createProjectile(
                    projectileStartPos,
                    forward, // Direction player is facing
                    true, // isPlayerProjectile
                    damage,
                    player.type // Pass player type for projectile visuals/behavior
                );
            }
        }

        // Player special attack
        function playerSpecialAttack() {
             if (!player || !player.mesh || player.mesh.isDisposed() || player.health <= 0) return;

            player.lastSpecialTime = gameTime;
             showMessage(`${player.special}!`, 2000);
             updatePlayerStats(); // Update cooldown display immediately


            if (player.type === 'Warrior') {
                 // --- Whirlwind Attack ---
                 if (sounds.special_warrior && sounds.special_warrior.state() === 'loaded') sounds.special_warrior.play();
                let range = 4.0;
                let rangeSqr = range * range;
                let damage = player.attack * 2.0;
                let playerPos = player.mesh.getAbsolutePosition();

                // Visual effect: Expanding Torus
                let whirl = BABYLON.MeshBuilder.CreateTorus("whirl", {diameter: 0.2, thickness: 0.3, tessellation: 32}, scene);
                whirl.position = playerPos.add(new BABYLON.Vector3(0, 0.5, 0)); // Centered on player, slightly above ground
                let mat = new BABYLON.StandardMaterial("whirlMat", scene);
                mat.diffuseColor = new BABYLON.Color3(1, 0.4, 0.4);
                mat.emissiveColor = new BABYLON.Color3(0.8, 0.2, 0.2);
                mat.alpha = 0.7;
                mat.disableLighting = true;
                whirl.material = mat;
                whirl.rotation.x = Math.PI / 2; // Lay flat
                whirl.isPickable = false;

                // Hit enemies and generators in range
                 enemies.forEach(enemy => {
                     if (enemy && enemy.mesh && !enemy.mesh.isDisposed() && enemy.health > 0 && enemy.mesh.isEnabled()) {
                          let enemyPos = enemy.mesh.getAbsolutePosition();
                          if (BABYLON.Vector3.DistanceSquared(playerPos, enemyPos) < rangeSqr) {
                             damageEnemy(enemy, damage);
                             // Stronger Knockback
                             if (enemy.mesh.physicsImpostor) {
                                 let knockbackDir = enemyPos.subtract(playerPos).normalize();
                                 enemy.mesh.physicsImpostor.applyImpulse(knockbackDir.scale(150), enemyPos);
                             }
                         }
                     }
                 });
                 generators.forEach(gen => {
                     if (gen && !gen.isDestroyed && gen.mesh && !gen.mesh.isDisposed() && gen.mesh.isEnabled()) {
                         let genPos = gen.mesh.getAbsolutePosition();
                         if (BABYLON.Vector3.DistanceSquared(playerPos, genPos) < rangeSqr) {
                             damageGenerator(gen, damage);
                         }
                     }
                 });

                 // Animation for the effect (expand and fade)
                let scaleAnim = new BABYLON.Animation("whirlScale", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                scaleAnim.setKeys([{ frame: 0, value: new BABYLON.Vector3(0.1, 0.1, 0.1)}, { frame: 15, value: new BABYLON.Vector3(range * 2, range * 2, 1)}]); // Expand diameter quickly
                let fadeAnim = new BABYLON.Animation("whirlFade", "material.alpha", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                fadeAnim.setKeys([{ frame: 5, value: 0.7 }, { frame: 20, value: 0 }]); // Fade out slightly slower

                 scene.beginDirectAnimation(whirl, [scaleAnim, fadeAnim], 0, 20, false, 1, () => {
                     if (whirl && !whirl.isDisposed()) whirl.dispose();
                 });

            } else if (player.type === 'Valkyrie') {
                 // --- Shield Bash --- (Dash forward, damage/push first hit, brief invulnerability)
                 if (sounds.special_valkyrie && sounds.special_valkyrie.state() === 'loaded') sounds.special_valkyrie.play();
                 let dashForce = player.speed * 150; // Apply a strong forward force/impulse
                 let dashDuration = 300; // ms duration of the effect / invulnerability
                 let damage = player.attack * 1.5;
                 let forward = player.mesh.forward.scale(-1); // Use mesh forward assumption

                 // Apply impulse for a short dash
                 if (player.mesh.physicsImpostor) {
                    player.mesh.physicsImpostor.applyImpulse(forward.scale(dashForce), player.mesh.getAbsolutePosition());
                 }

                 // Add temporary invulnerability during dash
                 player.invulnerableUntil = gameTime + dashDuration + 100; // Invulnerable for slightly longer than dash effect

                 // Check for collision *during* the dash period (simplification: check after a short delay)
                 let checkInterval = 50; // Check every 50ms
                 let checksDone = 0;
                 let maxChecks = Math.floor(dashDuration / checkInterval);
                 let hitEnemy = null; // Store hit enemy to only hit one

                 let intervalId = setInterval(() => {
                      // Stop interval if game state changes, check limit reached, or enemy hit
                      if (gameState !== GAME_STATES.PLAYING || !player || !player.mesh || player.mesh.isDisposed() || checksDone >= maxChecks || hitEnemy) {
                          clearInterval(intervalId);
                          return;
                      }
                      checksDone++;

                      let checkRange = 2.0; // Check slightly in front
                      let playerPos = player.mesh.getAbsolutePosition();
                      let checkPos = playerPos.add(forward.scale(checkRange * 0.5));

                      enemies.forEach(enemy => {
                          if (!hitEnemy && enemy && enemy.mesh && !enemy.mesh.isDisposed() && enemy.health > 0 && enemy.mesh.isEnabled()) {
                              let enemyPos = enemy.mesh.getAbsolutePosition();
                              if (BABYLON.Vector3.DistanceSquared(checkPos, enemyPos) < (checkRange * checkRange)) {
                                  let dirToEnemy = enemyPos.subtract(playerPos);
                                  if(dirToEnemy.lengthSquared() < 0.001) return; // Skip if exactly overlapping
                                  dirToEnemy.normalize();
                                  if (BABYLON.Vector3.Dot(forward, dirToEnemy) > 0.7) { // Must be generally in front
                                      damageEnemy(enemy, damage);
                                      // Strong knockback
                                      if (enemy.mesh.physicsImpostor) {
                                          enemy.mesh.physicsImpostor.applyImpulse(dirToEnemy.scale(250), enemyPos);
                                      }
                                      hitEnemy = enemy; // Mark as hit to stop checking others
                                  }
                              }
                          }
                      });

                 }, checkInterval);

            } else if (player.type === 'Wizard') {
                 // --- Arcane Nova --- (Area damage centered on the player)
                 if (sounds.special_wizard && sounds.special_wizard.state() === 'loaded') sounds.special_wizard.play();
                 let range = 5.0;
                 let rangeSqr = range * range;
                 let damage = player.magic * 2.5;
                 let playerPos = player.mesh.getAbsolutePosition();

                 // Visual effect (expanding sphere)
                 let nova = BABYLON.MeshBuilder.CreateSphere("nova", {diameter: 0.2, segments: 16}, scene);
                 nova.position = playerPos.add(new BABYLON.Vector3(0, 1.0, 0)); // Start slightly above ground
                 let mat = new BABYLON.StandardMaterial("novaMat", scene);
                 mat.diffuseColor = playerClassInfo.color.scale(0.8);
                 mat.emissiveColor = playerClassInfo.color;
                 mat.alpha = 0.8;
                 mat.disableLighting = true;
                 nova.material = mat;
                 nova.isPickable = false;

                 // Hit enemies and generators within range
                 enemies.forEach(enemy => {
                     if (enemy && enemy.mesh && !enemy.mesh.isDisposed() && enemy.health > 0 && enemy.mesh.isEnabled()) {
                          let enemyPos = enemy.mesh.getAbsolutePosition();
                          if (BABYLON.Vector3.DistanceSquared(playerPos, enemyPos) < rangeSqr) {
                              damageEnemy(enemy, damage);
                         }
                     }
                 });
                  generators.forEach(gen => {
                     if (gen && !gen.isDestroyed && gen.mesh && !gen.mesh.isDisposed() && gen.mesh.isEnabled()) {
                          let genPos = gen.mesh.getAbsolutePosition();
                           if (BABYLON.Vector3.DistanceSquared(playerPos, genPos) < rangeSqr) {
                              damageGenerator(gen, damage);
                         }
                     }
                 });


                 // Animation for the effect (expand and fade)
                 let novaDiameter = range * 2;
                 let scaleFactor = novaDiameter / 0.2; // Scale needed to reach diameter from initial 0.2
                let scaleAnim = new BABYLON.Animation("novaScale", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                 scaleAnim.setKeys([
                     { frame: 0, value: new BABYLON.Vector3(1, 1, 1)}, // Start scale 1 (diameter 0.2)
                     { frame: 20, value: new BABYLON.Vector3(scaleFactor, scaleFactor, scaleFactor)} // Expand to full size
                 ]);
                 let fadeAnim = new BABYLON.Animation("novaFade", "material.alpha", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                 fadeAnim.setKeys([{ frame: 5, value: 0.8 }, { frame: 25, value: 0 }]); // Fade out over duration

                 scene.beginDirectAnimation(nova, [scaleAnim, fadeAnim], 0, 25, false, 1, () => {
                     if (nova && !nova.isDisposed()) nova.dispose();
                 });


            } else if (player.type === 'Elf') {
                // --- Rapid Fire --- (Shoot multiple arrows quickly in a slight cone)
                 if (sounds.special_elf && sounds.special_elf.state() === 'loaded') sounds.special_elf.play(); // Play main sound once
                 let numShots = 5;
                 let shotDelay = 80; // ms between shots
                 let damagePerShot = (player.attack + player.magic * 0.5) * 0.7; // Slightly reduced damage per shot
                 let spreadAngle = 5; // Degrees of spread cone

                 let baseForward = player.mesh.forward.scale(-1); // Player's facing direction assumption

                 for (let i = 0; i < numShots; i++) {
                     setTimeout(() => {
                         // Check if still valid state *inside* the timeout
                         if (gameState === GAME_STATES.PLAYING && player && player.mesh && !player.mesh.isDisposed() && player.health > 0) {
                             // Calculate spread
                             let angleOffset = BABYLON.Tools.ToRadians((Math.random() - 0.5) * spreadAngle);
                             let finalDirection = baseForward.clone(); // Clone base direction
                             // Rotate the cloned vector horizontally using a Quaternion
                             let rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, angleOffset);
                             finalDirection.rotateByQuaternionToRef(rotationQuaternion, finalDirection); // Rotates vector in place

                             let projectileStartPos = player.mesh.getAbsolutePosition()
                                                          .add(new BABYLON.Vector3(0, 1.0, 0))
                                                          .add(finalDirection.scale(0.6)); // Start in front

                             createProjectile(projectileStartPos, finalDirection, true, damagePerShot, player.type);

                             // Play sound per shot for more impact (if desired)
                              if (sounds.attack_ranged && sounds.attack_ranged.state() === 'loaded') {
                                 sounds.attack_ranged.play();
                              }
                         }
                     }, i * shotDelay);
                 }
                 // Set overall shot cooldown after the special finishes to prevent immediate normal attack
                 player.lastShotTime = gameTime + numShots * shotDelay;
            }
        }

        // Use a health potion
        function usePotion() {
             if (!player || player.health <= 0) return; // Can't use if dead or no player

            if (player.potions > 0 && player.health < player.maxHealth) {
                if (sounds.potion_use && sounds.potion_use.state() === 'loaded') sounds.potion_use.play();
                player.potions--;
                potions = player.potions; // Update global state
                let healAmount = player.maxHealth * 0.5; // Heal 50% of max health
                let healthBefore = player.health;
                player.health = Math.min(player.maxHealth, player.health + healAmount);
                let healedAmount = Math.round(player.health - healthBefore); // Calculate actual healed amount
                showMessage(`Used a potion! +${healedAmount} Health`, 2000);
                updatePlayerStats();

                // Add a visual effect (e.g., green particles rising from player)
                 if (player.mesh && !player.mesh.isDisposed()) { // Check if player mesh exists
                    let particleSystem = new BABYLON.ParticleSystem("potionParticles", 500, scene);
                    particleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene); // Simple flare texture
                    particleSystem.emitter = player.mesh; // Emit from player mesh center
                    particleSystem.minEmitBox = new BABYLON.Vector3(-0.3, 0, -0.3);
                    particleSystem.maxEmitBox = new BABYLON.Vector3(0.3, 1.5, 0.3);
                    particleSystem.color1 = new BABYLON.Color4(0.2, 1, 0.2, 1.0);
                    particleSystem.color2 = new BABYLON.Color4(0.5, 1, 0.5, 0.8);
                    particleSystem.colorDead = new BABYLON.Color4(0, 0.5, 0, 0.0);
                    particleSystem.minSize = 0.1;
                    particleSystem.maxSize = 0.3;
                    particleSystem.minLifeTime = 0.4;
                    particleSystem.maxLifeTime = 0.9;
                    particleSystem.emitRate = 400;
                    particleSystem.manualEmitCount = 200;
                    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                    particleSystem.gravity = new BABYLON.Vector3(0, 2.0, 0);
                    particleSystem.minEmitPower = 0.5;
                    particleSystem.maxEmitPower = 1.5;
                    particleSystem.updateSpeed = 0.01;
                    particleSystem.start();

                     // Dispose the system after particles have likely faded
                     setTimeout(() => {
                         if (particleSystem) particleSystem.dispose();
                     }, (particleSystem.maxLifeTime * 1000) + 200); // Dispose slightly after max lifetime
                 }


            } else if (player.potions <= 0) {
                showMessage("No potions left!", 1500);
            } else { // Health is full
                 showMessage("Health is already full!", 1500);
            }
        }

        // Create a projectile (used by player ranged and enemy sorcerers)
        function createProjectile(position, direction, isPlayerProjectile, damage, ownerType) {
            // Basic projectile mesh (small sphere)
            let projectileMesh = BABYLON.MeshBuilder.CreateSphere("projectile_" + BABYLON.Tools.RandomId(), {diameter: 0.3, segments: 6}, scene);
            projectileMesh.position = position.clone(); // Start at the calculated position

            // Projectile Material
            let mat = new BABYLON.StandardMaterial("projMat_" + projectileMesh.name, scene);
            mat.specularColor = new BABYLON.Color3(0,0,0); // No specular highlight
            mat.disableLighting = true; // Make projectile glow regardless of light

            // Color based on owner
            if (isPlayerProjectile) {
                 let baseColor = CHARACTER_CLASSES[ownerType]?.color || new BABYLON.Color3(1,1,1);
                 mat.diffuseColor = baseColor.scale(1.2); // Slightly brighter than base
                 mat.emissiveColor = baseColor;
            } else { // Enemy projectile
                mat.diffuseColor = new BABYLON.Color3(1, 0.2, 0); // Generic evil red/orange
                mat.emissiveColor = mat.diffuseColor.scale(0.8); // Slightly less intense glow
            }
            projectileMesh.material = mat;

            // We are using raycasting for collisions, so no physics impostor needed
            projectileMesh.checkCollisions = false;
            projectileMesh.isPickable = false; // Not pickable by mouse


            let projectile = {
                mesh: projectileMesh,
                direction: direction.normalize(), // Ensure direction is normalized
                speed: isPlayerProjectile ? 25 : 18, // Player projectiles faster
                damage: damage,
                isPlayerProjectile: isPlayerProjectile,
                spawnTime: gameTime, // Record spawn time using game time
                lifeTime: 3000 // Projectile disappears after 3 seconds (in milliseconds)
            };
            projectiles.push(projectile);
        }


        // Update enemy behavior (AI)
        function updateEnemies(deltaTime) { // Receive deltaTime
             if (!player || !player.mesh || player.mesh.isDisposed() || player.health <= 0) return; // No player, no chase

             let playerPos = player.mesh.getAbsolutePosition(); // Use absolute position

             enemies.forEach((enemy, index) => {
                 // Basic checks for validity
                 if (!enemy || !enemy.mesh || enemy.mesh.isDisposed() || enemy.health <= 0 || !enemy.mesh.isEnabled()) {
                     // Skip dead, disposed or disabled enemies
                      return;
                 }
                 // Ensure physics impostor exists before proceeding
                 if (!enemy.mesh.physicsImpostor) return;


                 let enemyPos = enemy.mesh.getAbsolutePosition();
                 let distanceToPlayerSqr = BABYLON.Vector3.DistanceSquared(playerPos, enemyPos);
                 let detectionRangeSqr = 20 * 20; // Detection range
                 let attackRange = (enemy.canShoot ? enemy.shootRange : 1.6); // Melee range check slightly larger
                 let attackRangeSqr = attackRange * attackRange;

                 // --- AI State Logic ---
                 if (distanceToPlayerSqr > detectionRangeSqr) {
                     enemy.state = 'idle';
                 } else if (distanceToPlayerSqr <= attackRangeSqr) {
                     enemy.state = 'attacking';
                 } else { // Between attack range and detection range
                     enemy.state = 'chasing';
                 }

                 // --- Actions based on state ---
                 let currentVelocity = enemy.mesh.physicsImpostor.getLinearVelocity();
                 if (!currentVelocity) return; // Skip if physics body missing


                 let directionToPlayer = playerPos.subtract(enemyPos);
                 directionToPlayer.y = 0; // Ignore vertical difference for movement/rotation

                 // Rotate enemy to face player (only if needed and moving/attacking)
                 if ((enemy.state === 'chasing' || enemy.state === 'attacking') && directionToPlayer.lengthSquared() > 0.01) {
                     let directionNormalized = directionToPlayer.normalize(); // Normalize only when needed
                     let targetAngle = Math.atan2(directionNormalized.x, directionNormalized.z);
                     // Direct set works with fixedRotation
                     enemy.mesh.rotation.y = targetAngle;
                 }

                 // --- Velocity / Force Application ---
                 if (enemy.state === 'chasing') {
                     // Move towards player using velocity
                      if (directionToPlayer.lengthSquared() > 0.01) { // Ensure we have a direction
                         let directionNormalized = directionToPlayer.normalize(); // Use normalized direction from above if available
                         let targetVelocity = directionNormalized.scale(enemy.speed);
                         enemy.mesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(targetVelocity.x, currentVelocity.y, targetVelocity.z));
                     }

                 } else if (enemy.state === 'attacking') {
                     // Stop moving horizontally
                     enemy.mesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, currentVelocity.y, 0));

                     // Perform attack if cooldown ready
                     let attackCooldown = enemy.canShoot ? enemy.shootCooldown : 1500; // Melee cooldown 1.5s
                     if (gameTime > enemy.lastAttackTime + attackCooldown) {
                         enemy.lastAttackTime = gameTime;

                         if (enemy.canShoot) {
                             // Ranged Attack
                             if (directionToPlayer.lengthSquared() > 0.01) {
                                 let directionNormalized = directionToPlayer.normalize();
                                 let projectileStartPos = enemyPos.add(new BABYLON.Vector3(0,1,0)) // Approx shoot height
                                                             .add(directionNormalized.scale(0.5)); // Start slightly in front
                                 createProjectile(projectileStartPos, directionNormalized, false, enemy.attack, enemy.type);
                                  // Add enemy shoot sound?
                             }
                         } else {
                             // Melee Attack - Double check range just before dealing damage
                             // Use a slightly larger check than the state transition range
                              if (BABYLON.Vector3.DistanceSquared(playerPos, enemyPos) < (attackRange + 0.5) * (attackRange + 0.5)) {
                                 damagePlayer(enemy.attack);
                                  // Add small knockback to player?
                                 if (player.mesh && player.mesh.physicsImpostor) {
                                     let knockbackDir = playerPos.subtract(enemyPos);
                                     if(knockbackDir.lengthSquared() > 0.001) {
                                         knockbackDir.normalize();
                                         player.mesh.physicsImpostor.applyImpulse(knockbackDir.scale(30), playerPos);
                                     }
                                 }
                                 // Add enemy melee swing sound?
                             }
                         }
                     }

                 } else { // Idle state
                     // Gradually slow down horizontal movement
                     let dampingFactor = 0.85;
                      enemy.mesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(currentVelocity.x * dampingFactor, currentVelocity.y, currentVelocity.z * dampingFactor));
                 }

                 // Update health bar position/visibility (called regardless of state)
                 updateEnemyHealthBar(enemy);
             });
        }

        // Update enemy generators (Spawning logic)
        function updateGenerators(deltaTime) { // Receive deltaTime (not currently used here)
            generators.forEach((gen, index) => {
                 // Skip if destroyed or mesh invalid
                 if (!gen || gen.isDestroyed || !gen.mesh || gen.mesh.isDisposed() || !gen.mesh.isEnabled()) return;

                 // Check spawn timer
                 if (gameTime > gen.lastSpawnTime + gen.spawnRate) {
                     gen.lastSpawnTime = gameTime; // Reset timer immediately

                     // Check if player is too close to prevent spawn-camping
                     if (!player || !player.mesh || player.mesh.isDisposed()) return; // Need valid player reference
                     let genPos = gen.mesh.getAbsolutePosition();
                     let playerPos = player.mesh.getAbsolutePosition();
                     let distanceToPlayerSqr = BABYLON.Vector3.DistanceSquared(playerPos, genPos);
                     let minSpawnDistSqr = 4 * 4; // Don't spawn if player closer than 4 units

                      let maxEnemies = 20 + currentLevel * 2; // Example limit
                      if (enemies.length < maxEnemies && distanceToPlayerSqr > minSpawnDistSqr) {

                         // Try to find a valid spawn point near the generator
                         let validSpawnFound = false;
                         let spawnPos = new BABYLON.Vector3.Zero(); // Store spawn position

                         for (let tryCount = 0; tryCount < 5 && !validSpawnFound; tryCount++) {
                              // Calculate potential world coordinates around the generator
                             let offsetX = (Math.random() - 0.5) * TILE_SIZE * 1.8; // Wider spawn area
                             let offsetZ = (Math.random() - 0.5) * TILE_SIZE * 1.8;
                             let spawnX = genPos.x + offsetX;
                             let spawnZ = genPos.z + offsetZ;

                             // Convert world coords to grid coords to check dungeon map
                             let gridX = Math.floor((spawnX / TILE_SIZE) + MAP_WIDTH / 2);
                             let gridY = Math.floor((spawnZ / TILE_SIZE) + MAP_HEIGHT / 2);

                             // Check if within map bounds and is a floor tile (type 0)
                             if (gridX >= 1 && gridX < MAP_WIDTH - 1 && gridY >= 1 && gridY < MAP_HEIGHT - 1 && dungeon[gridY][gridX] === 0) {
                                 // Check if space is clear using a small sphere check? (More advanced)
                                 // For simplicity, just use grid check for now.
                                 spawnPos.set(spawnX, 1.0, spawnZ); // Store valid position (Y=1 for spawning above ground)
                                 validSpawnFound = true;
                             }
                         }

                         if (validSpawnFound) {
                              console.log(`Generator ${gen.id} spawning enemy near (${spawnPos.x.toFixed(1)}, ${spawnPos.z.toFixed(1)})`);
                             createRandomEnemy(spawnPos.x, spawnPos.z); // Create enemy at the valid world coords
                             // Play spawn sound?

                             // Visual effect for spawning
                             let spawnEffect = new BABYLON.ParticleSystem("spawnParticles", 300, scene);
                             spawnEffect.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
                             spawnEffect.emitter = genPos.add(new BABYLON.Vector3(0, 0.5, 0)); // Emit from near generator center
                             spawnEffect.minEmitBox = new BABYLON.Vector3(-0.5, 0, -0.5);
                             spawnEffect.maxEmitBox = new BABYLON.Vector3(0.5, 1, 0.5);
                             spawnEffect.color1 = new BABYLON.Color4(0.8, 0.2, 0.8, 1.0); // Magenta/Purple
                             spawnEffect.color2 = new BABYLON.Color4(1, 0.5, 1, 1.0);
                             spawnEffect.colorDead = new BABYLON.Color4(0.5, 0, 0.5, 0.0);
                             spawnEffect.minSize = 0.2;
                             spawnEffect.maxSize = 0.5;
                             spawnEffect.minLifeTime = 0.4;
                             spawnEffect.maxLifeTime = 1.0;
                             spawnEffect.emitRate = 400; // Burst rate
                              spawnEffect.manualEmitCount = 150; // Emit a fixed number
                             spawnEffect.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                             spawnEffect.gravity = new BABYLON.Vector3(0, 3.0, 0); // Particles go up
                             spawnEffect.minEmitPower = 1;
                             spawnEffect.maxEmitPower = 4;
                             spawnEffect.updateSpeed = 0.01;
                             spawnEffect.start();
                              // Dispose after lifetime
                              setTimeout(() => { if (spawnEffect) spawnEffect.dispose(); }, (spawnEffect.maxLifeTime * 1000) + 200);
                         } else {
                              // console.log(`Generator ${gen.id} failed to find valid spawn point.`); // Reduce log spam
                         }
                     }
                 }
                 // Update health bar (regardless of spawn)
                 updateGeneratorHealthBar(gen);
            });
        }

        // Update projectiles using Raycasting
        function updateProjectiles(deltaTime) { // Receive deltaTime
             let dt = deltaTime / 1000.0; // Delta time in seconds

             // Iterate backwards for safe removal while looping
             for (let i = projectiles.length - 1; i >= 0; i--) {
                 let proj = projectiles[i];

                 // Basic validity check
                 if (!proj || !proj.mesh || proj.mesh.isDisposed()) {
                     projectiles.splice(i, 1); // Remove invalid entry
                     continue;
                 }

                 // Check lifetime first
                 if (gameTime > proj.spawnTime + proj.lifeTime) {
                     createImpactEffect(proj.mesh.position); // Optional: effect on timeout
                     proj.mesh.dispose();
                     projectiles.splice(i, 1);
                     continue;
                 }

                 // --- Raycasting Logic ---
                 let currentPos = proj.mesh.position.clone();
                 let moveVector = proj.direction.scale(proj.speed * dt);
                 let nextPos = currentPos.add(moveVector);
                 let rayLength = moveVector.length();

                  if (rayLength < 0.001) continue; // Skip update if not moving

                 let ray = new BABYLON.Ray(currentPos, proj.direction, rayLength);

                 // Define predicate for what the ray should hit
                 let predicate = function (mesh) {
                    // Basic checks: mesh exists, enabled, not disposed, checkCollisions enabled?
                    if (!mesh || mesh.isDisposed() || !mesh.isEnabled()) { // || !mesh.checkCollisions <- Raycasting often ignores this
                        return false;
                    }
                     // Don't hit self or other projectiles
                    if (mesh === proj.mesh || mesh.name.startsWith("projectile_")) return false;
                     // Don't hit items or the exit key
                     if (mesh.name.startsWith("FOOD_") || mesh.name.startsWith("POTION_") || mesh.name.startsWith("KEY_") || mesh.name.startsWith("TREASURE_") || mesh.name === "exitKey") return false;
                     // Don't hit ceiling or ground
                     if (mesh.name === "ground" || mesh.name === "ceiling") return false;
                    // Player projectiles should not hit the player
                    if (proj.isPlayerProjectile && mesh.name === "player") return false;
                     // Enemy projectiles should not hit other enemies or generators
                     if (!proj.isPlayerProjectile && (mesh.name.startsWith("enemy_") || mesh.name.startsWith("generator_"))) return false;

                     // Hit walls, closed doors, generators (if player proj), enemies (if player proj), player (if enemy proj), exit door
                     return true; // If none of the above excluded it, consider it hittable
                 };

                 let pickInfo = scene.pickWithRay(ray, predicate, true); // `true` = pick first match only

                 if (pickInfo && pickInfo.hit && pickInfo.pickedMesh && !pickInfo.pickedMesh.isDisposed()) { // Check hit mesh validity
                     // --- Collision Occurred ---
                     let hitMesh = pickInfo.pickedMesh;
                     let hitPoint = pickInfo.pickedPoint;

                     // Determine impact color based on what was hit
                     let impactColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Default grey
                     if (hitMesh.material && hitMesh.material.diffuseColor) {
                          impactColor = hitMesh.material.diffuseColor.scale(1.2);
                     } else if (hitMesh.name === "player" && playerClassInfo) { // Player color
                         impactColor = playerClassInfo.color.scale(1.2);
                     }
                     createImpactEffect(hitPoint, impactColor);

                     // --- Handle Damage / Interaction ---
                     if (hitMesh.name.startsWith("wall")) { /* Hit wall */ }
                      else if (hitMesh.name.startsWith("door")) { /* Hit closed door */ }
                      else if (hitMesh.name.startsWith("generator")) {
                         let gen = generators.find(g => g.mesh === hitMesh);
                         if (gen && !gen.isDestroyed) damageGenerator(gen, proj.damage);
                     } else if (hitMesh.name.startsWith("enemy_")) {
                         let enemy = enemies.find(e => e.mesh === hitMesh);
                         if (enemy && enemy.health > 0) damageEnemy(enemy, proj.damage);
                     } else if (hitMesh.name === "player") {
                         if (player && player.health > 0) damagePlayer(proj.damage);
                     } else if (hitMesh.name === "exitDoor") { /* Hit exit door */ }
                      else { /* Hit something else? */ }

                     // Destroy projectile after hit
                     proj.mesh.dispose();
                     projectiles.splice(i, 1); // Remove from array

                 } else {
                     // --- No Collision ---
                     proj.mesh.position = nextPos; // Move projectile
                 }
             } // End loop backwards
        }


        // Create particle effect for projectile impact
        function createImpactEffect(position, color) {
             let C = color || new BABYLON.Color3(0.8, 0.8, 0.8);

             let particleSystem = new BABYLON.ParticleSystem("impactParticles", 100, scene);
             particleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
             particleSystem.emitter = position.clone(); // Emit from impact point
             particleSystem.minEmitBox = BABYLON.Vector3.Zero(); // Emit from point
             particleSystem.maxEmitBox = BABYLON.Vector3.Zero();
             particleSystem.color1 = new BABYLON.Color4(C.r, C.g, C.b, 0.9);
             particleSystem.color2 = new BABYLON.Color4(C.r * 0.8, C.g * 0.8, C.b * 0.8, 0.6);
             particleSystem.colorDead = new BABYLON.Color4(C.r * 0.5, C.g * 0.5, C.b * 0.5, 0.0);
             particleSystem.minSize = 0.1;
             particleSystem.maxSize = 0.3;
             particleSystem.minLifeTime = 0.1;
             particleSystem.maxLifeTime = 0.3;
             particleSystem.emitRate = 600; // Emit a quick burst
             particleSystem.manualEmitCount = 50; // Emit fixed number
             particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE; // Bright additive sparks
             particleSystem.gravity = new BABYLON.Vector3(0, -2.0, 0); // Slight downward gravity
             particleSystem.direction1 = new BABYLON.Vector3(-1, -1, -1); // Emit outwards
             particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);
             particleSystem.minEmitPower = 1;
             particleSystem.maxEmitPower = 4; // Speed of particles
             particleSystem.updateSpeed = 0.01;
             particleSystem.start(); // Start the burst

             // Dispose the system after particles have faded
              setTimeout(() => {
                  if(particleSystem) particleSystem.dispose();
              }, 500); // Dispose after ~0.5 seconds
        }


        // Check Player Collisions with items, doors, exit using intersectsMesh
        function checkCollisions() {
            if (!player || !player.mesh || player.mesh.isDisposed() || player.health <= 0) return;

            // 1. Items Pickup
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                 if (item && item.mesh && !item.mesh.isDisposed() && player.mesh.intersectsMesh(item.mesh, false)) {
                    let message = `Picked up ${item.type}`;
                    let playSound = sounds.pickup_item; // Default pickup sound

                    if (item.type === 'FOOD') {
                        if (player.health < player.maxHealth) {
                            let healthBefore = player.health;
                            player.health = Math.min(player.maxHealth, player.health + item.health);
                            let healedAmount = Math.round(player.health - healthBefore);
                            message += ` (+${healedAmount} Health)`;
                        } else {
                             message += " (Health Full)"; // Still give score
                        }
                    } else if (item.type === 'POTION') {
                        player.potions++;
                        potions = player.potions; // Update global
                        message += "!";
                    } else if (item.type === 'KEY') {
                        player.keys++;
                        keys = player.keys; // Update global
                        message += "!";
                        playSound = sounds.pickup_key; // Specific sound for keys
                    } else if (item.type === 'TREASURE') {
                        message += ` (+${item.score} Score)`;
                    }

                    player.score += item.score;
                    score = player.score; // Update global
                    showMessage(message, 1500);
                    updatePlayerStats(); // Update UI display

                     if (playSound && playSound.state() === 'loaded') playSound.play();

                    item.mesh.dispose(); // Dispose mesh
                    items.splice(i, 1); // Remove from items array
                }
            }

            // 2. Doors Interaction
            doors.forEach(door => {
                if (!door.isOpen && !door.isOpening && door.mesh && !door.mesh.isDisposed()) {
                     if (player.mesh.intersectsMesh(door.mesh, true)) { // Precise check
                        openDoor(door);
                    }
                 }
            });

            // 3. Exit Key Pickup
             if (exitKey && !exitKey.collected && exitKey.mesh && !exitKey.mesh.isDisposed()) {
                 if (player.mesh.intersectsMesh(exitKey.mesh, false)) {
                     console.log("Player picked up Exit Key");
                     exitKey.collected = true;
                     hasExitKey = true; // Set global flag for this level

                     if (sounds.pickup_key && sounds.pickup_key.state() === 'loaded') sounds.pickup_key.play();
                     showMessage("Picked up the EXIT KEY!", 3000);
                     player.score += 100; // Score bonus for exit key
                     score = player.score;
                     updatePlayerStats();

                     // Animate key disappearing
                     let scaleAnim = new BABYLON.Animation("keyCollectScale", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                     scaleAnim.setKeys([{ frame: 0, value: exitKey.mesh.scaling }, { frame: 15, value: BABYLON.Vector3.Zero()}]);
                     scene.beginDirectAnimation(exitKey.mesh, [scaleAnim], 0, 15, false, 1, () => {
                          if (exitKey && exitKey.mesh && !exitKey.mesh.isDisposed()) {
                              exitKey.mesh.dispose(); // Dispose mesh after animation
                              exitKey.mesh = null; // Clear mesh reference
                          }
                     });
                 }
             }

             // 4. Exit Door Interaction
             if (exitDoor && exitDoor.mesh && !exitDoor.mesh.isDisposed()) {
                 if (player.mesh.intersectsMesh(exitDoor.mesh, true)) { // Precise check
                     if (hasExitKey) {
                         console.log("Player touched Exit Door with key!");
                         levelComplete(); // Trigger level completion
                     } else {
                         if (gameTime > lastMessageTime + 2500) { // Throttle message
                             showMessage("The exit is locked. Find the key!", 2500);
                              if (sounds.door_locked && sounds.door_locked.state() === 'loaded') sounds.door_locked.play();
                         }
                     }
                 }
             }
        }

        // --- Damage Handling ---

        // Damage the player
        function damagePlayer(amount) {
             if (!player || player.health <= 0 || gameState !== GAME_STATES.PLAYING) return; // Check player exists and state
            // Check invulnerability
            if (gameTime < player.invulnerableUntil) {
                return;
            }

            let damageAmount = Math.max(1, Math.round(amount)); // Ensure at least 1 damage, integer
            player.health -= damageAmount;
            console.log(`Player damaged by ${damageAmount}, Health: ${player.health}`);

            if (sounds.hit_player && sounds.hit_player.state() === 'loaded') sounds.hit_player.play();
            updatePlayerStats(); // Update UI immediately

             // Add brief invulnerability period
             player.invulnerableUntil = gameTime + 300; // 0.3 seconds invulnerability

             // Add visual feedback (e.g., screen flash red vignette)
             if (camera) { // Check camera exists
                let redFlash = new BABYLON.ImageProcessingPostProcess("redFlash", 1.0, camera);
                redFlash.vignetteEnabled = true;
                redFlash.vignetteWeight = 2.5; // Intensity of vignette
                redFlash.vignetteColor = new BABYLON.Color4(1, 0, 0, 0.3); // Red, semi-transparent
                redFlash.vignetteBlendMode = BABYLON.ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY; // Darken edges

                // Remove the effect after a short duration
                setTimeout(() => {
                    if (redFlash) redFlash.dispose();
                }, 150); // Duration of flash effect
             }


            // Check for game over
            if (player.health <= 0) {
                player.health = 0; // Clamp health at 0
                updatePlayerStats(); // Update UI one last time
                gameOver(); // Trigger game over sequence
            }
        }

        // Damage an enemy
        function damageEnemy(enemy, amount) {
            if (!enemy || !enemy.mesh || enemy.mesh.isDisposed() || enemy.isInvulnerable || enemy.health <= 0 || !enemy.mesh.isEnabled() || enemy.markedForDeath) return;

             let damageAmount = Math.max(1, Math.round(amount));
            enemy.health -= damageAmount;

            if (sounds.hit_enemy && sounds.hit_enemy.state() === 'loaded') sounds.hit_enemy.play();
             updateEnemyHealthBar(enemy); // Update health bar display

             // Visual feedback: Flash white emissive color
             if (enemy.mesh.material) {
                 let originalEmissive = enemy.mesh.material.emissiveColor?.clone() || new BABYLON.Color3(0,0,0); // Clone or default
                 enemy.mesh.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                 setTimeout(() => {
                     if (enemy.mesh && !enemy.mesh.isDisposed() && enemy.mesh.material) {
                        enemy.mesh.material.emissiveColor = originalEmissive;
                     }
                 }, 100); // Flash duration (ms)
             }

            // Check for death
            if (enemy.health <= 0) {
                 if (!enemy.markedForDeath) { // Prevent multiple death calls
                     enemy.markedForDeath = true; // Mark immediately
                     console.log(`Enemy ${enemy.id} (${enemy.type}) died.`);
                     enemyDeath(enemy); // Handle death sequence
                 }
            } else {
                 // Aggro on hit
                 if (enemy.state === 'idle') enemy.state = 'chasing';
            }
        }

        // Handle enemy death sequence
        function enemyDeath(enemy) {
            if (!enemy || !enemy.mesh) { // Check if enemy object itself exists
                console.warn("enemyDeath called with invalid enemy object.");
                return;
            }

             // Double check mesh status (might have been disposed by another process?)
             if (enemy.mesh.isDisposed() || !enemy.mesh.isEnabled()) {
                 console.warn(`Enemy death called on already disabled/disposed mesh: ${enemy.id}`);
                  // Attempt cleanup of map entries just in case
                  if (enemy.healthBar && !enemy.healthBar.isDisposed) enemy.healthBar.dispose();
                  enemyHealthBars.delete(enemy.id);
                  // Removal from main array should happen only once, preferably after animation/disposal
                 return;
             }

             // Disable mesh immediately to prevent further interaction
             enemy.mesh.setEnabled(false);
             enemy.mesh.checkCollisions = false;

            if (sounds.death_enemy && sounds.death_enemy.state() === 'loaded') sounds.death_enemy.play();

            // Award score to player (check if player exists)
             if(player) {
                player.score += enemy.score;
                score = player.score; // Update global
                updatePlayerStats(); // Update UI
             }

            // Chance to drop an item
            if (Math.random() < 0.20) {
                 let dropRand = Math.random();
                 let dropType = (dropRand < 0.50) ? 'FOOD' : (dropRand < 0.75) ? 'TREASURE' : (dropRand < 0.90) ? 'POTION' : 'KEY';
                 console.log(`Enemy ${enemy.id} dropped ${dropType}`);
                 createRandomItem(enemy.mesh.position.x, enemy.mesh.position.z);
            }


            // Remove health bar from GUI and map
            if (enemy.healthBar && !enemy.healthBar.isDisposed) {
                 if(advancedTextureGUI) advancedTextureGUI.removeControl(enemy.healthBar);
                 enemy.healthBar.dispose();
                 enemy.healthBar = null;
            }
            enemyHealthBars.delete(enemy.id); // Remove from tracking map


             // Dispose physics impostor *before* animation/disposal
             if (enemy.mesh.physicsImpostor) {
                 enemy.mesh.physicsImpostor.dispose();
                 enemy.mesh.physicsImpostor = null;
             }


             // Death animation/effect (e.g., shrink and fade)
             let deathAnimDuration = 15; // Frames
             let scaleAnim = new BABYLON.Animation("deathScale", "scaling", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
             scaleAnim.setKeys([{ frame: 0, value: enemy.mesh.scaling.clone() }, { frame: deathAnimDuration, value: BABYLON.Vector3.Zero()}]);

             let fadeAnim = new BABYLON.Animation("deathFade", "material.alpha", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              let startAlpha = (enemy.mesh.material && enemy.mesh.material.alpha !== undefined) ? enemy.mesh.material.alpha : 1.0;
              fadeAnim.setKeys([{ frame: 0, value: startAlpha }, { frame: deathAnimDuration, value: 0 }]);


             // Start animation, dispose mesh in callback
             scene.beginDirectAnimation(enemy.mesh, [scaleAnim, fadeAnim], 0, deathAnimDuration, false, 1, () => {
                  let enemyId = enemy.id; // Store ID before potential object modification
                  if (enemy.mesh && !enemy.mesh.isDisposed()) {
                       enemy.mesh.dispose(); // Dispose mesh after animation
                       enemy.mesh = null; // Clear reference
                  }
                  // Remove enemy object from the main array *after* disposal/animation
                   let index = enemies.findIndex(e => e && e.id === enemyId); // Find by stored ID
                   if (index !== -1) {
                       enemies.splice(index, 1);
                       // console.log(`Removed enemy ${enemyId} from array.`);
                   } else {
                       // console.warn(`Could not find enemy ${enemyId} in array after death animation.`);
                   }
             });
        }


        // Damage a generator
        function damageGenerator(gen, amount) {
             if (!gen || gen.isDestroyed || gen.health <= 0 || !gen.mesh || gen.mesh.isDisposed() || !gen.mesh.isEnabled()) return;

             let damageAmount = Math.max(1, Math.round(amount));
             gen.health -= damageAmount;

             if (sounds.hit_enemy && sounds.hit_enemy.state() === 'loaded') sounds.hit_enemy.play(); // Reuse enemy hit sound?
             updateGeneratorHealthBar(gen); // Update health bar display

            // Visual feedback: Flash white emissive
             if (gen.mesh.material) {
                let originalEmissive = gen.mesh.material.emissiveColor?.clone() || new BABYLON.Color3(0,0,0);
                gen.mesh.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                setTimeout(() => {
                    if (gen.mesh && !gen.mesh.isDisposed() && gen.mesh.material) {
                       gen.mesh.material.emissiveColor = originalEmissive;
                    }
                }, 100);
             }

             // Check for destruction
             if (gen.health <= 0) {
                 if (!gen.isDestroyed) { // Prevent multiple calls
                    console.log(`Generator ${gen.id} destroyed.`);
                    generatorDestroyed(gen); // Handle destruction sequence
                 }
            }
        }

        // Handle generator destruction sequence
        function generatorDestroyed(gen) {
            if (!gen || !gen.mesh || gen.isDestroyed) return; // Basic checks

             // Check if already processed
             if (gen.mesh.isDisposed() || !gen.mesh.isEnabled()) {
                 console.warn(`Generator destroyed called on already disabled/disposed mesh: ${gen.id}`);
                  // Attempt cleanup
                  if (gen.healthBar && !gen.healthBar.isDisposed) gen.healthBar.dispose();
                  generatorHealthBars.delete(gen.id);
                 return;
             }

            gen.isDestroyed = true; // Mark as destroyed immediately
            gen.mesh.setEnabled(false); // Disable interactions
            gen.mesh.checkCollisions = false;

            showMessage("Generator destroyed!", 2000);
             if(player) { // Check player exists before giving score
                player.score += 50;
                score = player.score;
                updatePlayerStats(); // Update UI
             }

             if (sounds.death_enemy && sounds.death_enemy.state() === 'loaded') sounds.death_enemy.play(); // Reuse enemy death sound?

             // Remove health bar from GUI and map
             if (gen.healthBar && !gen.healthBar.isDisposed) {
                  if(advancedTextureGUI) advancedTextureGUI.removeControl(gen.healthBar);
                  gen.healthBar.dispose();
                  gen.healthBar = null;
             }
             generatorHealthBars.delete(gen.id); // Remove from tracking map


             // Destruction effect (e.g., explosion particles)
              let particleSystem = new BABYLON.ParticleSystem("genDestroyParticles", 1000, scene);
              particleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
              particleSystem.emitter = gen.mesh.position.clone(); // Emit from generator position
              particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, -0.5);
              particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 1, 0.5);
              particleSystem.color1 = new BABYLON.Color4(1, 0.2, 1, 1.0);
              particleSystem.color2 = new BABYLON.Color4(1, 0.8, 1, 1.0);
              particleSystem.colorDead = new BABYLON.Color4(0.5, 0, 0.5, 0.0);
              particleSystem.minSize = 0.2;
              particleSystem.maxSize = 0.7;
              particleSystem.minLifeTime = 0.5;
              particleSystem.maxLifeTime = 1.5;
              particleSystem.emitRate = 1000;
              particleSystem.manualEmitCount = 500;
              particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
              particleSystem.gravity = new BABYLON.Vector3(0, -6.0, 0);
              particleSystem.direction1 = new BABYLON.Vector3(-1, 0.5, -1);
              particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);
              particleSystem.minEmitPower = 3;
              particleSystem.maxEmitPower = 8;
              particleSystem.updateSpeed = 0.01;
              particleSystem.start();
              // Dispose system after particles fade
              setTimeout(() => { if (particleSystem) particleSystem.dispose(); }, 2000);


             // Dispose physics impostor *before* mesh disposal
             if (gen.mesh.physicsImpostor) {
                 gen.mesh.physicsImpostor.dispose();
                 gen.mesh.physicsImpostor = null;
             }

             // Dispose mesh after a short delay
             setTimeout(() => {
                 let genId = gen.id; // Store ID
                if (gen.mesh && !gen.mesh.isDisposed()) {
                     gen.mesh.dispose(); // Remove mesh
                     gen.mesh = null;
                }
                // Remove generator object from the main array after disposal
                 let index = generators.findIndex(g => g && g.id === genId);
                 if (index !== -1) {
                     generators.splice(index, 1);
                     // console.log(`Removed generator ${genId} from array.`);
                 }
             }, 100); // Short delay before final mesh removal
        }

        // --- Game Flow ---

        // Game Over
        function gameOver(optionalMessage = "") {
            if (gameState === GAME_STATES.GAME_OVER) return; // Prevent multiple triggers

            console.log("GAME OVER triggered.");
            gameState = GAME_STATES.GAME_OVER;

             // Stop sounds
             Howler.stop(); // Stop all Howler sounds

             // Play game over sound
             if (sounds.gameOver && sounds.gameOver.state() === 'loaded') sounds.gameOver.play();

             // Disable player controls / physics
             if(player && player.mesh && !player.mesh.isDisposed()) {
                  if (player.mesh.physicsImpostor) {
                      player.mesh.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                      player.mesh.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
                      // Dispose impostor for clean state
                      player.mesh.physicsImpostor.dispose();
                      player.mesh.physicsImpostor = null;
                  }
                  // Optional: player death animation
             }
              // Stop camera controls
              if (camera) camera.detachControl(canvas);
              inputMap = {}; // Clear inputs


            // Display game over screen
             let finalMessage = optionalMessage || `Your quest ended on level ${currentLevel} with a score of ${player?.score || 0}.`;
            document.getElementById('gameOverMessage').innerText = finalMessage;
            gameOverScreen.style.display = 'flex';
            console.log("Game Over screen displayed.");
        }

        // Restart Game (from Game Over screen) - Use page reload for cleanest state
        function restartGame() {
             if (gameState !== GAME_STATES.GAME_OVER) return; // Only restart from game over

            console.log("Restarting game via page reload...");
            gameOverScreen.style.display = 'none'; // Hide screen immediately
            // Reloading the page is the most reliable way to reset everything
            location.reload();

            // --- Old manual cleanup code (Commented out - use reload instead) ---
            /*
             console.log("Attempting manual restart...");
             gameState = GAME_STATES.LOADING; // Set state immediately
             loadingScreen.style.display = 'flex'; // Show loading screen

             // Stop render loop while resetting
             engine.stopRenderLoop();
             Howler.stop(); // Stop sounds

             // Dispose scene and GUI
             if (scene) {
                 scene.dispose();
                 scene = null;
             }
              if (advancedTextureGUI) {
                 advancedTextureGUI.dispose();
                 advancedTextureGUI = null;
             }

             // Reset game variables
             resetFullGameState();
             player = null; playerClassInfo = null;
             enemies = []; projectiles = []; items = []; doors = []; walls = []; generators = [];
             exitKey = null; exitDoor = null; dungeon = [];
             enemyHealthBars.clear(); generatorHealthBars.clear();
             inputMap = {};
             camera = null; // Force camera recreation

             console.log("Manual state reset complete. Reloading game...");

             // Re-run the initial load and setup process
             // Needs careful handling of async operations
             loadGame().then(() => {
                 console.log("Game reloaded, restarting render loop.");
                  engine.runRenderLoop(function() { // Restart render loop with updated logic
                     if (scene && engine && gameState !== GAME_STATES.LOADING) {
                         let deltaTime = engine.getDeltaTime();
                         gameTime += deltaTime;
                         if (gameState === GAME_STATES.PLAYING) {
                            updateGame(deltaTime);
                         }
                         if (scene && !scene.isDisposed) { // Check before rendering
                            scene.render();
                         }
                     }
                 });
             }).catch(error => {
                 console.error("Error reloading game after manual restart:", error);
                 gameOver("Error restarting game!");
             });
            */
        }

        // Level Complete
        function levelComplete() {
            if (gameState === GAME_STATES.LEVEL_COMPLETE || gameState === GAME_STATES.GAME_OVER) return; // Prevent triggers

            console.log(`Level ${currentLevel} Complete! Score: ${player?.score || 0}`);
            gameState = GAME_STATES.LEVEL_COMPLETE;

             // Stop background music, play level complete sound
             if (sounds.background && sounds.background.playing()) sounds.background.stop();
             if (sounds.levelComplete && sounds.levelComplete.state() === 'loaded') sounds.levelComplete.play();

             // Disable player controls temporarily, freeze player
             if(player && player.mesh && !player.mesh.isDisposed() && player.mesh.physicsImpostor) {
                  player.mesh.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
                  player.mesh.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
             }
             if (camera) camera.detachControl(canvas);
             inputMap = {}; // Clear inputs

            // Display level complete screen
            document.getElementById('finalLevelScore').innerText = player?.score || 0;
            levelCompleteScreen.style.display = 'flex';
        }

        // Load Next Level (from Level Complete screen)
        async function loadNextLevel() {
             if (gameState !== GAME_STATES.LEVEL_COMPLETE) return;

            console.log("Loading next level...");
            levelCompleteScreen.style.display = 'none';
            currentLevel++;

            // --- Carry Over Player Stats ---
            if (player) {
                // Restore some health (e.g., 25% of max health, up to max)
                let healthBonus = player.maxHealth * 0.25;
                player.health = Math.min(player.maxHealth, player.health + healthBonus);
                // Score, keys, potions are already updated globally and will be read by createPlayer
                score = player.score;
                keys = player.keys;
                potions = player.potions;
            } else {
                console.error("Cannot load next level: Player object is missing.");
                // Maybe trigger game over or restart?
                gameOver("Error loading next level - Player lost!");
                return;
            }

            // Reset level specific flags
            hasExitKey = false;

            // --- Restart the Level Loading Process ---
             console.log("Preparing to start next level...");
             // startGameLevel handles calling clearLevel, generateLevel, createPlayer (which reads carried-over stats), etc.
             // It reuses the existing scene object after clearing it.
             startGameLevel();
        }


        // Update UI (called in game loop)
        function updateUI() {
            // Throttle UI updates slightly? Not usually necessary unless complex.
            updatePlayerStats();
        }

    </script>
</body>
</html>